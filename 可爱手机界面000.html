<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Yetta以她小手机</title>
    <style>
        .settings-page,
        .config-page,
        .beautify-page,
        .contacts-page {
            position: absolute;
            left: 0;
            width: 100%;
            top: 0;
            bottom: 0;
            height: auto;
        }

        /* ========== 开始：粘贴这段全新的、修正后的代码块CSS ========== */

        .code-block-wrapper pre {
            background-color: #1e1e1e;
            color: #d4d4d4;
            padding: 36px 12px 12px 12px;
            border-radius: 8px;
            font-family: 'Consolas', 'Monaco', 'Menlo', monospace;
            font-size: 13px;
            line-height: 1.5;
            margin: 0;
            white-space: pre-wrap;
            word-break: break-all;
            box-sizing: border-box;

            /* ========== 新增：确保 pre 也受宽度约束 ========== */
            max-width: 100%;
            width: 100%; /* 填满父容器 */
            /* ========== 新增结束 ========== */
        }


        /* 3. 开启滚动条模式时，修改包裹容器和<pre>的行为 */

        /* --- 用下面这个新版本替换它 --- */
        body.code-scrolling-enabled .code-block-wrapper pre {
            white-space: pre;
            word-break: normal;
            overflow-x: auto; /* <<< --- 核心修改：滚动条在这里！--- <<< */
            flex: 1; /* <<< --- 新增：让pre元素占据所有可用空间 --- <<< */
            min-width: 0; /* <<< --- 新增：允许pre元素收缩 --- <<< */
        }


        .chat-bubble code {
            padding: 0;
            background: transparent;
            border-radius: 0;
            font-family: inherit;
        }

        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            display: flex;
            justify-content: center;
            min-height: 100vh;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', sans-serif;
            padding: 20px;
        }

        /* --- 聊天界面样式 --- */

        /* ===== 高级简约聊天界面样式 - 开始 ===== */

        .chat-page {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: #f7f8fa; /* 柔和的背景色 */
            z-index: 1005;
            display: flex;
            flex-direction: column;
            transform: translateY(100%);
            transition: transform 0.35s cubic-bezier(0.25, 0.46, 0.45, 0.94);
        }

        .chat-page.show {
            transform: translateY(0);
        }

        /* 当 chat-page 拥有 simple-style 类时触发 */
        .chat-page.simple-style .message-row {
            flex-direction: row !important; /* 强制 头像-内容 顺序 */
            justify-content: flex-start !important; /* 强制 左对齐 */
        }

        /* 并且，移除气泡的所有样式 */
        .chat-page.simple-style .chat-bubble {
            background: transparent;
            color: #333;
            padding: 0;
            border-radius: 0;
            box-shadow: none;
        }


        /* 消息内容容器，用于包裹发送者和消息文本 */
        /* 这是解决问题的关键！ */
        .chat-page.simple-style .message-content {
            display: flex;
            flex-direction: column;
            gap: 4px; /* 发送者和消息之间的间距 */
            min-width: 0; /* 关键修复！允许flex子项收缩，防止被内部内容撑开 */
        }


        /* 简洁模式下，发送消息的气泡也不再有特殊颜色 */
        .chat-page.simple-style .message-row.sent .chat-bubble {
            background: transparent;
            color: #333;
        }


        /* 发送者名称的样式 */
        .message-sender-name {
            font-size: 14px;
            font-weight: 600;
            color: #555;
        }

        /* 默认隐藏头像和名字，只在简洁模式下显示 */
        .message-chat-avatar,
        .message-sender-name {
            display: none;
        }

        .chat-page.simple-style .message-chat-avatar,
        .chat-page.simple-style .message-sender-name {
            display: block; /* 在简洁模式下显示它们 */
        }

        /* 聊天中的小头像样式 */
        .message-chat-avatar {
            width: 36px;
            height: 36px;
            border-radius: 8px;
            flex-shrink: 0;
            overflow: hidden;
            background: #ccc;
        }

        .message-chat-avatar img,
        .message-chat-avatar .initials {
            width: 100%;
            height: 100%;
            object-fit: cover;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 16px;
            font-weight: bold;
            color: white;
        }

        /* ========== 结束：【最终修正版】简洁聊天样式 ========== */


        .chat-header {
            display: flex;
            align-items: center;
            justify-content: space-between;
            padding: 45px 12px 12px; /* 调整内边距 */
            background: white;
            box-shadow: 0 1px 3px rgba(0, 0, 0, 0.08); /* 更柔和的阴影 */
            flex-shrink: 0;
            position: relative;
            z-index: 2;
        }

        .chat-header .back-btn {
            margin-right: 8px;
        }

        .chat-title {
            position: absolute;
            left: 50%;
            transform: translateX(-50%);
            font-size: 17px; /* 稍微调整字体大小 */
            font-weight: 600;
            color: #000;
            margin: 0;
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
            max-width: 55%;
        }

        .header-actions {
            display: flex;
            align-items: center;
            gap: 0; /* 按钮之间不留空隙 */
        }

        .edit-contact-btn, .chat-settings-btn {
            width: 38px;
            height: 38px;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 14px;
            font-weight: 500;
            color: #0A84FF; /* 统一为品牌蓝色 */
            cursor: pointer;
            border-radius: 8px;
            transition: background-color 0.2s;
        }

        .chat-settings-btn {
            font-size: 20px; /* 让图标稍大一些 */
        }

        .edit-contact-btn:hover, .chat-settings-btn:hover {
            background-color: #f0f2f5;
        }

        .chat-messages {
            flex: 1;
            overflow-y: auto;
            padding: 20px;
            display: flex;
            flex-direction: column;
            gap: 16px;
            background-color: rgba(247, 248, 250, 0.85); /* 新增此行 */
        }


        .chat-messages::-webkit-scrollbar {
            display: none;
        }

        /* ========== 开始：修复气泡对齐问题 ========== */

        /* 1. 让消息内容容器成为flex容器 */
        .message-content {
            display: flex;
            flex-direction: column;
            gap: 4px;
            min-width: 0;
            width: 100%; /* 占满可用宽度，这样align-items才能生效 */
        }

        /* 2. 气泡模式：发送消息右对齐 */
        .message-row.sent .message-content {
            align-items: flex-end;
        }

        /* 3. 气泡模式：接收消息左对齐 */
        .message-row.received .message-content {
            align-items: flex-start;
        }

        /* 4. 简洁模式：强制所有消息左对齐 */
        .chat-page.simple-style .message-row.sent .message-content,
        .chat-page.simple-style .message-row.received .message-content {
            align-items: flex-start !important;
        }

        /* ========== 结束：修复气泡对齐问题 ========== */

        /* --- 1. 消息行的基础布局 --- */
        .message-row {
            display: flex;
            max-width: 100%;
            gap: 12px;
            align-items: flex-start;
        }

        /* --- 2. 气泡模式：接收消息（头像在左，左对齐）--- */
        .message-row.received {
            flex-direction: row;
            justify-content: flex-start;
        }

        /* --- 3. 气泡模式：发送消息（头像在右，右对齐）--- */
        .message-row.sent {
            flex-direction: row-reverse;
            justify-content: flex-end;
        }

        /* --- 4. 简洁模式：所有消息都左对齐，头像都在左 --- */
        .chat-page.simple-style .message-row.sent,
        .chat-page.simple-style .message-row.received {
            flex-direction: row !important;
            justify-content: flex-start !important;
        }


        /* --- 5. 消息气泡样式 --- */
        .chat-bubble {
            max-width: calc(100vw - 120px);
            width: fit-content;
            padding: 12px 16px;
            border-radius: 20px;
            font-size: 16px;
            line-height: 1.5;
            box-shadow: 0 1px 2px rgba(0, 0, 0, 0.05);
            word-break: break-word;
        }

        /* --- 6. 图片消息样式 --- */
        .chat-bubble.image-only {
            padding: 0;
            background: transparent;
            box-shadow: none;
            max-width: 65%;
            border-radius: 12px;
            overflow: hidden;
        }

        .chat-bubble.image-only img {
            display: block;
            max-width: 240px;
            width: 100%;
            height: auto;
            border-radius: 12px;
        }

        /* --- 7. 接收消息气泡颜色 --- */
        .message-row.received .chat-bubble {
            background: #e9e9eb;
            color: #000;
            border-bottom-left-radius: 5px;
        }

        /* --- 8. 发送消息气泡颜色 --- */
        .message-row.sent .chat-bubble {
            background: #0A84FF;
            color: white;
            border-bottom-right-radius: 5px;
        }

        /* --- 9. 图片消息无特殊颜色 --- */
        .message-row .chat-bubble.image-only {
            background: transparent;
            border-radius: 12px;
        }


        .message-row:hover .delete-msg-btn {
            opacity: 1;
        }

        .delete-msg-btn:hover {
            background: #fecaca;
            color: #b91c1c;
        }

        .chat-input-area {
            display: flex;
            flex-direction: column; /* 核心修改：让子元素垂直排列 */
            align-items: stretch; /* 让子元素宽度撑满 */
            gap: 8px; /* 引用预览框和输入行之间的间距 */
            padding: 8px 12px;
            background: #fff;
            border-top: 1px solid #e5e5e5;
            flex-shrink: 0;
        }

        .chat-input-main-row {
            display: flex;
            align-items: center; /* 垂直居中对齐 */
            gap: 8px; /* 按钮和输入框之间的间距 */
            width: 100%; /* 确保它撑满父容器 */
        }

        .chat-input-area input {
            flex: 1;
            padding: 10px 16px;
            border: none;
            background: #f0f2f5;
            border-radius: 20px;
            font-size: 16px;
            outline: none;
        }

        /* ========== 开始： .chat-action-btn 规则 ========== */

        .chat-input-area .chat-action-btn {
            width: 38px;
            height: 38px;
            padding: 0;
            border: none;
            border-radius: 50%;
            /* 统一所有非主按钮的背景色 */
            background: #f0f2f5;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            transition: all 0.2s ease;
        }

        /* 默认隐藏新的发送按钮 */

        #sendMsgBtn {
            display: none;
        }

        /* 当输入框有内容时，通过JS添加 .has-text 类来显示发送按钮 */

        .chat-input-area.has-text #sendMsgBtn {
            display: flex; /* 使用 flex 保持居中 */
        }

        /* 同时隐藏信封按钮 */

        .chat-input-area.has-text #getReplyBtn {
            display: none;
        }

        /* 重新定义 primary 按钮的样式，确保它只作用于我们期望的按钮上 */

        #sendMsgBtn.primary {
            background: #0A84FF;
        }

        #sendMsgBtn.primary svg {
            fill: white;
        }

        .chat-input-area .chat-action-btn svg {
            width: 20px;
            height: 20px;
            fill: #6c757d;
        }

        .chat-settings-page {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: linear-gradient(180deg, #f8f9fa 0%, #e9ecef 100%);
            transform: translateX(100%);
            transition: transform 0.35s cubic-bezier(0.25, 0.46, 0.45, 0.94);
            z-index: 1006;
            display: flex;
            flex-direction: column;
        }

        .chat-settings-page.show {
            transform: translateX(0);
        }

        /* ===== 高级简约聊天界面样式 - 结束 ===== */

        /* 1. 引用预览条 (输入时) */
        .quote-preview {
            display: none; /* 默认隐藏 */
            padding: 8px 12px;
            background-color: #f0f2f5; /* 白色背景 */
            border-radius: 12px;
            border: none;
            align-items: flex-start; /* 垂直方向顶部对齐 */
            gap: 8px;
        }

        .quote-preview.show {
            display: flex; /* 当有 .show 类时显示 */
        }

        .quote-content {
            flex: 1;
            min-width: 0;
            display: flex;
            flex-direction: column;
            gap: 2px;
        }

        .quote-sender {
            font-size: 14px;
            font-weight: 600;
            color: #333;
        }

        .quote-text {
            font-size: 14px;
            color: #666;
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis; /* 超出部分显示省略号 */
        }

        .quote-close-btn {
            width: 20px;
            height: 20px;
            border-radius: 50%;
            background-color: #cccccc;
            color: white;
            border: none;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 16px;
            line-height: 1;
            flex-shrink: 0;
            transition: background-color 0.2s;
        }

        .quote-close-btn:hover {
            background-color: #aaaaaa;
        }

        /* 2. 最终渲染的引用消息样式 (发出时) */
        .quoted-message-wrapper {
            background: rgba(0, 0, 0, 0.1);
            padding: 8px 12px;
            margin-bottom: 8px;
            border-radius: 8px;
            border-left: 3px solid #0A84FF; /* 左侧的蓝色指示条 */
            display: flex;
            flex-direction: column;
            gap: 2px;
        }

        /* 接收到的消息，指示条颜色不同 */
        .message-row.received .quoted-message-wrapper {
            border-left-color: #a0a0a0;
        }


        .quoted-sender {
            font-size: 14px;
            font-weight: 600;
            color: #0A84FF; /* 蓝色高亮发送者 */
        }

        .message-row.received .quoted-sender {
            color: #555; /* 接收到的消息，发送者颜色不同 */
        }


        .quoted-text {
            font-size: 14px;
            color: inherit; /* 继承气泡的文字颜色 */
            opacity: 0.8;
            /* 防止过长的引用文本撑破气泡 */
            word-break: break-word;
        }

        /* 3. 主消息文本样式（引用消息下方的新消息） */
        .main-message-text {
            margin-top: 4px; /* 和引用内容之间留出一点空隙 */
        }


        .phone {
            width: 375px;
            height: 812px;
            background: #000;
            border-radius: 40px;
            padding: 12px;
            box-shadow: 0 30px 80px rgba(0, 0, 0, 0.4);
            position: relative;
            margin: auto;
        }

        .phone::before {
            content: '';
            position: absolute;
            top: 12px;
            left: 50%;
            transform: translateX(-50%);
            width: 120px;
            height: 28px;
            background: #000;
            border-radius: 0 0 20px 20px;
            z-index: 999;
        }

        /* ========== 开始：粘贴这段全新的 CSS 代码 ========== */

        /* 当 body 标签拥有 fullscreen-enabled 类时，激活以下样式 */

        body.fullscreen-enabled .phone {
            width: 100vw; /* 视口宽度，占满整个浏览器窗口宽度 */
            height: 100vh; /* 视口高度，占满整个浏览器窗口高度 */
            border-radius: 0; /* 移除圆角 */
            padding: 0; /* 移除内边距 */
            background: transparent; /* 边框背景变透明 */
            box-shadow: none; /* 移除阴影 */
            margin: 0; /* 移除外边距，确保完全贴合 */
        }

        body.fullscreen-enabled .screen {
            border-radius: 0; /* 屏幕也移除圆角，以匹配父容器 */
        }

        /* 移除刘海屏的黑色遮挡 */

        body.fullscreen-enabled .phone::before {
            display: none;
        }

        /* 同时让 body 在全屏时没有内边距 */

        body.fullscreen-enabled {
            padding: 0;
        }

        .screen {
            width: 100%;
            height: 100%;
            background: linear-gradient(180deg, #fef5f9 0%, #f0e6f5 100%);
            border-radius: 30px;
            overflow: hidden;
            position: relative;
            background-size: cover;
            background-position: center;
            background-repeat: no-repeat;
            transition: background-image 0.5s ease-in-out;
        }

        .pages-wrapper {
            display: flex;
            width: 200%;
            height: 100%;
            transition: transform 0.35s cubic-bezier(0.25, 0.46, 0.45, 0.94);
        }

        .pages-wrapper.no-transition {
            transition: none;
        }

        .page {
            width: 50%;
            height: 100%;
            display: flex;
            flex-direction: column;
            flex-shrink: 0;
        }

        .status-bar {
            display: flex;
            justify-content: space-between;
            padding: 40px 20px 12px;
            font-size: 18px;
            font-weight: 600;
            color: #1a1a1a;
            flex-shrink: 0;
            position: relative;
            z-index: 100;
        }

        .status-icons {
            display: flex;
            align-items: baseline;
            gap: 10px;
        }

        .status-icon-svg {
            width: 25px;
            height: 25px;
            fill: currentColor;
            display: block;
        }

        .battery-container {
            display: flex;
            align-items: center;
            gap: 1px;
            position: relative;
            top: -5px;
        }

        .battery-icon {
            position: relative;
            width: 34px;
            height: 17px;
        }

        .battery-icon svg {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
        }

        .battery-level {
            position: absolute;
            top: 50%;
            transform: translateY(-50%);
            left: 2px;
            right: 6px;
            height: 8px;
            background-color: #1a1a1a;
            border-radius: 2px;
            width: 0%;
            transition: width 0.5s ease;
        }

        .battery-level.low {
            background-color: #ff4757;
        }

        .charging-bolt {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            width: 9px;
            height: 9px;
            fill: #1a1a1a;
            display: none;
        }

        .battery-container.charging .charging-bolt {
            display: block;
        }

        .battery-container.charging .battery-level {
            display: none;
        }

        .battery-text {
            font-size: 12px;
            font-weight: 600;
            line-height: 12px;
        }

        .time-weather-section {
            flex-shrink: 0;
            padding: 0 20px 12px;
            position: relative;
            z-index: 50;
        }

        .top-row {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding-bottom: 12px;
            border-bottom: 1px solid rgba(168, 201, 245, 0.15);
        }

        .location-display {
            display: flex;
            align-items: center;
            gap: 6px;
        }

        .location-icon {
            font-size: 16px;
        }

        .location-text {
            font-size: 14px;
            color: #666;
            font-weight: 600;
        }

        .weather-display {
            cursor: pointer;
            padding: 6px 12px;
            border-radius: 12px;
            background: rgba(168, 201, 245, 0.1);
            transition: all 0.2s;
        }

        .weather-display:hover {
            background: rgba(168, 201, 245, 0.2);
            transform: scale(1.05);
        }

        .current-weather-icon {
            font-size: 28px;
            display: block;
        }

        .mood-section {
            display: flex;
            flex-direction: column;
            gap: 6px;
            cursor: pointer;
            padding: 12px;
            border-radius: 12px;
            background: linear-gradient(135deg, rgba(255, 240, 245, 0.5), rgba(255, 230, 240, 0.3));
            transition: all 0.2s;
        }

        .mood-section:hover {
            background: linear-gradient(135deg, rgba(255, 240, 245, 0.7), rgba(255, 230, 240, 0.5));
            transform: scale(1.02);
        }

        .mood-label {
            font-size: 11px;
            color: #888;
            font-weight: 600;
        }

        .mood-text {
            font-size: 15px;
            color: #333;
            font-weight: 500;
            min-height: 20px;
        }

        .mood-text.empty {
            color: #aaa;
            font-style: italic;
        }

        .weather-popup {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: white;
            border-radius: 16px;
            padding: 16px;
            box-shadow: 0 8px 32px rgba(0, 0, 0, 0.2);
            z-index: 100;
            min-width: 200px;
        }

        .weather-popup-title {
            font-size: 13px;
            color: #666;
            font-weight: 600;
            margin-bottom: 12px;
            text-align: center;
        }

        .weather-options {
            display: flex;
            gap: 16px;
            justify-content: center;
        }

        .weather-option {
            font-size: 36px;
            cursor: pointer;
            padding: 8px;
            border-radius: 12px;
            transition: all 0.2s;
            opacity: 0.4;
        }

        .weather-option:hover {
            transform: scale(1.15);
            opacity: 0.7;
        }

        .weather-option.active {
            opacity: 1;
            background: rgba(168, 201, 245, 0.15);
            transform: scale(1.1);
        }


        .grid-container {
            flex: 1;
            padding: 12px 20px 120px;
            display: grid;
            grid-template-columns: repeat(4, 1fr);
            grid-template-rows: repeat(6, 1fr);
            gap: 14px;
            position: relative;
            overflow-y: visible;
            align-content: start;
        }


        .grid-container::-webkit-scrollbar {
            display: none;
        }

        .app-icon {
            position: absolute;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: flex-start;
            gap: 8px;
            cursor: pointer;
            transition: transform 0.15s ease;
            z-index: 10;
            user-select: none;
            padding: 4px;
        }

        .app-icon:active:not(.dragging) {
            transform: scale(0.95);
        }

        .app-icon.dragging {
            z-index: 150;
            opacity: 0.85;
            transform: scale(1.08) rotate(1deg);
            transition: none;
        }

        .icon-wrapper {
            width: 62px;
            height: 62px;
            flex-shrink: 0;
            background: linear-gradient(135deg, rgba(255, 255, 255, 0.98), rgba(255, 255, 255, 0.92));
            border-radius: 15px;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 30px;
            box-shadow: 0 3px 12px rgba(0, 0, 0, 0.08),
            0 1px 4px rgba(168, 201, 245, 0.15);
            pointer-events: none;
            overflow: hidden;
        }

        .icon-wrapper img {
            width: 100%;
            height: 100%;
            object-fit: cover;
        }

        .badge {
            position: absolute;
            top: -2px;
            right: 4px;
            background: #ff4757;
            color: white;
            border-radius: 10px;
            padding: 2px 5px;
            min-width: 18px;
            font-size: 10px;
            font-weight: 600;
            text-align: center;
            z-index: 15;
            box-shadow: 0 2px 4px rgba(255, 71, 87, 0.3);
            pointer-events: none;
        }

        .app-label {
            font-size: 12px;
            color: #FFF;
            /* 只需修改 text-shadow 这一行 */
            text-shadow: -1px -1px 0 rgba(165, 42, 42, 0.5),
            1px -1px 0 rgba(165, 42, 42, 0.5),
            -1px 1px 0 rgba(165, 42, 42, 0.5),
            1px 1px 0 rgba(165, 42, 42, 0.5);
            text-align: center;
            max-width: 70px;
            overflow: visible;
            white-space: nowrap;
            font-weight: 500;
            pointer-events: none;
            line-height: 1.2;
            /* 额外优化：提升字体渲染质量 */
            -webkit-font-smoothing: antialiased;
            -moz-osx-font-smoothing: grayscale;
            text-rendering: optimizeLegibility;
        }

        .folder .icon-wrapper {
            background: linear-gradient(135deg, rgba(255, 220, 240, 0.9), rgba(255, 200, 220, 0.8));
            display: grid;
            grid-template-columns: repeat(3, 1fr);
            gap: 3px;
            padding: 8px;
        }

        .folder-mini-icon {
            font-size: 14px;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .page-dots {
            position: absolute;
            bottom: 95px;
            left: 50%;
            transform: translateX(-50%);
            display: flex;
            gap: 7px;
            z-index: 200;
        }

        .dot {
            width: 7px;
            height: 7px;
            border-radius: 50%;
            background: rgba(255, 255, 255, 0.4);
            backdrop-filter: blur(2px);
            cursor: pointer;
            transition: all 0.3s cubic-bezier(0.25, 0.46, 0.45, 0.94);
        }

        .dot.active {
            background: rgba(255, 255, 255, 0.9);
            width: 18px;
            border-radius: 3.5px;
        }

        .dock {
            position: absolute;
            bottom: 18px;
            left: 50%;
            transform: translateX(-50%);
            display: flex;
            gap: 16px;
            background: rgba(255, 255, 255, 0.5);
            padding: 8px 20px;
            border-radius: 24px;
            backdrop-filter: blur(20px);
            box-shadow: 0 8px 24px rgba(0, 0, 0, 0.1);
            z-index: 200;
            backdrop-filter: blur(10px);
        }

        .dock-icon {
            width: 56px;
            height: 56px;
            flex-shrink: 0;
            background: linear-gradient(135deg, rgba(255, 255, 255, 0.98), rgba(255, 255, 255, 0.92));
            border-radius: 14px;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 26px;
            cursor: pointer;
            transition: transform 0.2s ease;
            box-shadow: 0 2px 8px rgba(0, 0, 0, 0.08);
        }

        .dock-icon:active {
            transform: scale(0.92);
        }

        .edit-hint {
            position: absolute;
            top: 65px;
            left: 50%;
            transform: translateX(-50%);
            background: rgba(0, 0, 0, 0.7);
            color: white;
            padding: 10px 20px;
            border-radius: 22px;
            font-size: 12px;
            width: 200px;
            text-align: center;
            font-weight: 500;
            opacity: 0;
            pointer-events: none;
            transition: opacity 0.3s ease;
            z-index: 300;
            backdrop-filter: blur(10px);
        }

        .edit-hint.show {
            opacity: 1;
        }

        #editHint2 {
            display: none;
        }

        .settings-page, .config-page, .beautify-page {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: linear-gradient(180deg, #f8f9fa 0%, #e9ecef 100%);
            transform: translateX(100%);
            transition: transform 0.35s cubic-bezier(0.25, 0.46, 0.45, 0.94);
            z-index: 1000;
            display: flex;
            flex-direction: column;
        }

        .settings-page.show, .config-page.show, .beautify-page.show {
            transform: translateX(0);
        }

        .config-page {
            z-index: 1001;
        }

        .settings-header {
            display: flex;
            align-items: center;
            padding: 45px 20px 20px;
            background: linear-gradient(135deg, rgba(255, 255, 255, 0.95), rgba(255, 255, 255, 0.85));
            box-shadow: 0 2px 12px rgba(0, 0, 0, 0.08);
        }

        .back-btn {
            width: 36px;
            height: 36px;
            border-radius: 12px;
            background: rgba(168, 201, 245, 0.15);
            display: flex;
            align-items: center;
            justify-content: center;
            cursor: pointer;
            font-size: 20px;
            transition: all 0.2s;
            color: #333;
            font-weight: bold;
        }

        .back-btn:active {
            transform: scale(0.9);
            background: rgba(168, 201, 245, 0.25);
        }

        .settings-title {
            flex: 1;
            text-align: center;
            font-size: 18px;
            font-weight: 600;
            color: #333;
            margin-right: 36px;
        }

        .settings-content {
            flex: 1;
            overflow-y: auto;
            padding: 12px 0;
        }

        .settings-content::-webkit-scrollbar {
            display: none;
        }

        .settings-section {
            margin-bottom: 20px;
        }

        .section-title {
            padding: 12px 20px 8px;
            font-size: 12px;
            color: #666;
            font-weight: 600;
            letter-spacing: 0.5px;
            text-transform: uppercase;
        }

        .settings-item {
            background: white;
            padding: 16px 20px;
            display: flex;
            align-items: center;
            cursor: pointer;
            transition: background 0.2s;
            border-bottom: 1px solid rgba(0, 0, 0, 0.05);
        }

        .settings-item:first-of-type {
            border-top-left-radius: 12px;
            border-top-right-radius: 12px;
        }

        .settings-item:last-of-type {
            border-bottom-left-radius: 12px;
            border-bottom-right-radius: 12px;
            border-bottom: none;
        }

        .settings-item:active {
            background: #f8f9fa;
        }

        .settings-icon {
            width: 32px;
            height: 32px;
            border-radius: 8px;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 18px;
            margin-right: 14px;
        }

        .settings-info {
            flex: 1;
        }

        .settings-label {
            font-size: 15px;
            color: #333;
            font-weight: 600;
            margin-bottom: 2px;
        }

        .settings-desc {
            font-size: 12px;
            color: #888;
        }

        .settings-arrow {
            font-size: 16px;
            color: #bbb;
            font-weight: bold;
        }

        .form-group {
            background: white;
            padding: 20px;
            margin-bottom: 2px;
        }

        .form-group:first-of-type {
            border-top-left-radius: 12px;
            border-top-right-radius: 12px;
        }

        .form-group:last-of-type {
            border-bottom-left-radius: 12px;
            border-bottom-right-radius: 12px;
        }

        .form-label {
            display: block;
            font-size: 13px;
            color: #666;
            margin-bottom: 8px;
            font-weight: 600;
        }

        .form-input, .form-select {
            width: 100%;
            padding: 10px 12px;
            border: 2px solid #e0e0e0;
            border-radius: 8px;
            font-size: 14px;
            transition: border-color 0.2s;
        }

        .form-input:focus, .form-select:focus {
            outline: none;
            border-color: #a8c9f5;
        }

        .btn-group {
            display: flex;
            gap: 8px;
            margin: 20px;
        }

        .save-btn, .test-btn, .fetch-btn {
            flex: 1;
            padding: 14px;
            border: none;
            border-radius: 12px;
            font-size: 15px;
            font-weight: 600;
            cursor: pointer;
            transition: transform 0.2s;
        }

        .save-btn {
            background: linear-gradient(135deg, #667eea, #764ba2);
            color: white;
        }

        .test-btn {
            background: linear-gradient(135deg, #4facfe, #00f2fe);
            color: white;
        }

        .fetch-btn {
            background: linear-gradient(135deg, #43e97b, #38f9d7);
            color: white;
        }

        .save-btn:active, .test-btn:active, .fetch-btn:active {
            transform: scale(0.98);
        }

        .api-config-list {
            margin: 0 20px 20px;
        }

        .api-config-item {
            background: white;
            padding: 16px;
            margin-bottom: 12px;
            border-radius: 12px;
            box-shadow: 0 2px 8px rgba(0, 0, 0, 0.05);
            cursor: pointer;
            transition: all 0.2s;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }

        .config-details {
            flex: 1;
            min-width: 0;
        }

        .delete-config-btn {
            width: 32px;
            height: 32px;
            border-radius: 50%;
            background: #f1f2f6;
            border: none;
            color: #a4b0be;
            font-size: 16px;
            font-weight: bold;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            flex-shrink: 0;
            margin-left: 12px;
            transition: all 0.2s ease;
        }

        .delete-config-btn:hover {
            background: #ff4757;
            color: white;
            transform: scale(1.1) rotate(90deg);
        }

        .api-config-item:active {
            transform: scale(0.98);
        }

        .api-config-item.active {
            border: 2px solid #667eea;
            background: #f0f4ff;
        }

        .config-name {
            font-size: 15px;
            font-weight: 600;
            color: #333;
            margin-bottom: 4px;
        }

        .config-url {
            font-size: 12px;
            color: #888;
            overflow: hidden;
            text-overflow: ellipsis;
            white-space: nowrap;
        }

        .add-new-btn {
            width: 100%;
            padding: 14px;
            background: white;
            border: 2px dashed #ddd;
            border-radius: 12px;
            font-size: 15px;
            font-weight: 600;
            color: #888;
            cursor: pointer;
            transition: all 0.2s;
        }

        .add-new-btn:hover {
            border-color: #667eea;
            color: #667eea;
        }

        .app-preview-list {
            flex: 1;
            overflow-y: auto;
            padding: 12px;
        }

        .app-preview-item {
            background: white;
            padding: 16px;
            margin-bottom: 12px;
            border-radius: 12px;
            box-shadow: 0 2px 8px rgba(0, 0, 0, 0.05);
        }

        .preview-header {
            display: flex;
            align-items: center;
            margin-bottom: 12px;
        }

        .preview-icon {
            width: 48px;
            height: 48px;
            border-radius: 12px;
            background: linear-gradient(135deg, rgba(255, 255, 255, 0.98), rgba(255, 255, 255, 0.92));
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 24px;
            margin-right: 12px;
            box-shadow: 0 2px 8px rgba(0, 0, 0, 0.1);
            overflow: hidden;
        }

        .preview-icon img {
            width: 100%;
            height: 100%;
            object-fit: cover;
        }

        .preview-name {
            font-size: 15px;
            font-weight: 600;
            color: #333;
        }

        .upload-section {
            display: flex;
            gap: 8px;
            margin-top: 8px;
        }

        .upload-btn, .url-input-btn {
            flex: 1;
            padding: 8px 12px;
            border: 2px solid #e0e0e0;
            border-radius: 8px;
            font-size: 12px;
            cursor: pointer;
            text-align: center;
            transition: all 0.2s;
            background: white;
            font-weight: 600;
            color: #666;
        }

        .upload-btn:hover, .url-input-btn:hover {
            border-color: #a8c9f5;
            color: #667eea;
        }

        .file-input {
            display: none;
        }

        .url-input-box {
            margin-top: 8px;
            display: none;
        }

        .url-input-box.show {
            display: block;
        }

        .url-input-field {
            width: 100%;
            padding: 8px 12px;
            border: 2px solid #e0e0e0;
            border-radius: 8px;
            font-size: 12px;
            margin-bottom: 6px;
        }

        .url-input-field:focus {
            outline: none;
            border-color: #a8c9f5;
        }

        .confirm-btn {
            width: 100%;
            padding: 8px;
            background: linear-gradient(135deg, #667eea, #764ba2);
            color: white;
            border: none;
            border-radius: 8px;
            font-size: 12px;
            font-weight: 600;
            cursor: pointer;
        }

        .status-message {
            margin-top: 8px;
            font-size: 11px;
            color: #28a745;
            font-weight: 600;
        }

        .status-message.error {
            color: #dc3545;
        }

        .delete-time-btn, .delete-weather-btn, .delete-widget-btn {
            position: absolute;
            top: 8px;
            right: 8px;
            width: 24px;
            height: 24px;
            background: rgba(255, 71, 87, 0.9);
            border-radius: 50%;
            display: none;
            align-items: center;
            justify-content: center;
            color: white;
            font-size: 16px;
            font-weight: bold;
            cursor: pointer;
            z-index: 250;
        }

        .time-card {
            position: relative;
        }

        .time-card.show-delete .delete-time-btn {
            display: flex;
        }

        .weather-card.show-delete .delete-weather-btn {
            display: flex;
        }

        .saved-widget-item {
            background: white;
            padding: 16px;
            margin-bottom: 12px;
            border-radius: 12px;
            box-shadow: 0 2px 8px rgba(0, 0, 0, 0.05);
        }

        .saved-widget-name {
            font-size: 13px;
            font-weight: 600;
            color: #333;
            margin-bottom: 8px;
        }

        .restore-btn {
            flex: 1;
            padding: 8px;
            background: linear-gradient(135deg, #43e97b, #38f9d7);
            color: white;
            border: none;
            border-radius: 8px;
            font-size: 12px;
            cursor: pointer;
        }

        .delete-saved-btn {
            flex: 1;
            padding: 8px;
            background: #f5f5f5;
            color: #666;
            border: none;
            border-radius: 8px;
            font-size: 12px;
            cursor: pointer;
        }

        /* ========== 新增：文件夹浮层样式 ========== */
        .folder-overlay {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.3);
            backdrop-filter: blur(15px) saturate(180%);
            -webkit-backdrop-filter: blur(15px) saturate(180%);
            z-index: 500;
            display: flex;
            justify-content: center;
            align-items: center;
            opacity: 0;
            visibility: hidden;
            transition: opacity 0.3s ease, visibility 0.3s ease;
        }

        .folder-overlay.show {
            opacity: 1;
            visibility: visible;
        }

        .folder-modal {
            background: rgba(255, 255, 255, 0.8);
            border-radius: 24px;
            width: calc(100% - 40px);
            padding: 16px;
            box-shadow: 0 10px 30px rgba(0, 0, 0, 0.1);
            transform: scale(0.95);
            transition: transform 0.3s cubic-bezier(0.25, 0.46, 0.45, 0.94);
        }

        .folder-overlay.show .folder-modal {
            transform: scale(1);
        }

        .folder-header {
            text-align: center;
            padding-bottom: 16px;
        }

        /* ========== 新增：文件夹名称编辑样式 (修正版) ========== */
        #folderNameInput {
            /* 继承父元素的字体样式 */
            font-size: inherit;
            font-weight: inherit;
            color: inherit;
            font-family: inherit;

            /* 移除输入框默认外观 */
            border: none;
            background: transparent;

            /* 文本居中 */
            text-align: center;

            /* 移除点击时的轮廓线 */
            outline: none;

            /* 宽度撑满，与标题一致 */
            width: 100%;
            padding: 0;
            margin: 0;

            /* 添加一个细微的下划线，提示用户正在编辑 */
            border-bottom: 2px solid #a0a0a0;
        }

        /* 当文件夹头部处于编辑状态时 */
        .folder-header.is-editing #folderName {
            display: none; /* 隐藏原始标题 */
        }

        .folder-header.is-editing #folderNameInput {
            /* ▼▼▼ 核心修正点在这里 ▼▼▼ */
            display: block !important; /* 显示输入框，并强制覆盖内联样式 */
        }


        #folderName {
            font-size: 20px;
            font-weight: 600;
            color: #1d1d1f;
            margin: 0;
        }

        .folder-grid-container {
            display: grid;
            grid-template-columns: repeat(4, 1fr);
            gap: 14px;
            align-content: start;
        }

        /* 文件夹浮层中图标的样式, 它复用了.app-icon的结构 */
        .folder-grid-container .app-icon {
            position: relative; /* 从absolute改为relative，适应grid布局 */
            top: auto;
            left: auto;
            width: auto;
            height: auto;
        }

        /* ========== 开始：粘贴这段全新的CSS代码 ========== */

        .folder-mini-icon img {
            width: 100%;
            height: 100%;
            object-fit: cover; /* 确保图片不变形地填满容器 */
            border-radius: 4px; /* 给小图标也加上一点圆角，更美观 */
        }

        /* ========== 结束：粘贴全新的CSS代码 ========== */


        .contacts-page {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: linear-gradient(180deg, #f8f9fa 0%, #e9ecef 100%);
            transform: translateY(100%);
            transition: transform 0.35s cubic-bezier(0.25, 0.46, 0.45, 0.94);
            z-index: 1002;
            display: flex;
            flex-direction: column;
        }

        .contacts-page.show {
            transform: translateY(0);
        }

        /* ========== 开始：粘贴这段【修正版】CSS 代码 ========== */

        .contacts-header {
            display: flex;
            align-items: center;
            padding: 45px 20px 20px;
            background: linear-gradient(135deg, rgba(255, 255, 255, 0.95), rgba(255, 255, 255, 0.85));
            box-shadow: 0 2px 12px rgba(0, 0, 0, 0.08);
            position: relative;
            z-index: 10; /* <<< --- 新增：提升头部的堆叠层级 --- <<< */
        }

        .contacts-search {
            flex: 1;
            padding: 10px 16px;
            background: rgba(168, 201, 245, 0.1);
            border: none;
            border-radius: 20px;
            font-size: 14px;
            margin: 0 12px;
        }

        .contacts-search:focus {
            outline: none;
            background: rgba(168, 201, 245, 0.2);
        }

        .add-contact-btn {
            width: 36px;
            height: 36px;
            border-radius: 12px;
            background: rgba(168, 201, 245, 0.15);
            display: flex;
            align-items: center;
            justify-content: center;
            cursor: pointer;
            font-size: 20px;
            transition: all 0.2s;
            color: #333;
            font-weight: bold;
        }

        .add-contact-btn:active {
            transform: scale(0.9);
            background: rgba(168, 201, 245, 0.25);
        }

        .contact-menu {
            position: absolute;
            top: 100%;
            right: 20px;
            margin-top: 8px;
            background: white;
            border-radius: 12px;
            box-shadow: 0 8px 24px rgba(0, 0, 0, 0.15);
            overflow: hidden;
            display: none;
            z-index: 1003;
            min-width: 160px;
        }

        .contact-menu.show {
            display: block;
        }

        .contact-menu-item {
            padding: 14px 20px;
            cursor: pointer;
            transition: background 0.2s;
            font-size: 14px;
            color: #333;
            border-bottom: 1px solid rgba(0, 0, 0, 0.05);
        }

        .contact-menu-item:last-child {
            border-bottom: none;
        }

        .contact-menu-item:active {
            background: #f8f9fa;
        }

        .contacts-list {
            flex: 1;
            overflow-y: auto;
            padding: 12px 0;
        }

        .contacts-list::-webkit-scrollbar {
            display: none;
        }

        .contact-item {
            display: flex;
            align-items: center;
            padding: 12px 20px;
            background: white;
            border-bottom: 1px solid rgba(0, 0, 0, 0.05);
            cursor: pointer;
            transition: background 0.2s;
        }

        .contact-item:active {
            background: #f8f9fa;
        }

        .contact-avatar {
            width: 48px;
            height: 48px;
            border-radius: 50%;
            background: linear-gradient(135deg, #667eea, #764ba2);
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 20px;
            color: white;
            margin-right: 12px;
            flex-shrink: 0;
        }

        .contact-info {
            flex: 1;
            min-width: 0;
        }

        .contact-name {
            font-size: 15px;
            font-weight: 600;
            color: #333;
            margin-bottom: 2px;
        }

        .contact-status {
            font-size: 12px;
            color: #888;
            overflow: hidden;
            text-overflow: ellipsis;
            white-space: nowrap;
        }

        .contact-badge {
            background: #ff4757;
            color: white;
            border-radius: 10px;
            padding: 2px 8px;
            min-width: 18px;
            font-size: 11px;
            font-weight: 600;
            text-align: center;
        }

        .wallpaper-grid {
            display: grid;
            grid-template-columns: repeat(auto-fill, minmax(80px, 1fr));
            gap: 12px;
            padding: 0 20px;
        }

        .wallpaper-thumbnail {
            width: 100%;
            padding-top: 150%;
            border-radius: 12px;
            background-size: cover;
            background-position: center;
            cursor: pointer;
            border: 3px solid transparent;
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.1);
            transition: all 0.2s ease;
            position: relative;
        }

        .wallpaper-thumbnail:hover {
            transform: scale(1.05);
            box-shadow: 0 6px 16px rgba(0, 0, 0, 0.15);
        }

        .wallpaper-thumbnail.active {
            border-color: #667eea;
            transform: scale(1.02);
        }

        .modal-overlay {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.6);
            z-index: 1010;
            display: flex;
            justify-content: center;
            align-items: center;
            padding: 20px;
            opacity: 0;
            visibility: hidden;
            transition: opacity 0.3s ease, visibility 0.3s ease;
            backdrop-filter: blur(5px);
        }

        .modal-overlay.show {
            opacity: 1;
            visibility: visible;
        }

        .character-card-modal {
            background: #fff;
            border: 6px solid #000;
            border-radius: 24px;
            width: 100%;
            max-width: 330px;
            box-shadow: 0 15px 40px rgba(0, 0, 0, 0.4);
            display: flex;
            flex-direction: column;
            font-family: 'Helvetica Neue', Helvetica, Arial, sans-serif;
            transform: scale(0.95);
            transition: transform 0.3s cubic-bezier(0.25, 0.46, 0.45, 0.94);
        }

        .modal-overlay.show .character-card-modal {
            transform: scale(1);
        }

        .character-card-content {
            padding: 24px;
            display: flex;
            flex-direction: column;
            gap: 20px;
        }

        /* 顶部信息区：简单的两列 Flex 布局 */
        .top-info-section {
            display: flex;
            gap: 16px; /* 左右两列的间距 */
            align-items: flex-start;
        }

        /* 1. 左侧头像：固定宽度，不收缩 */
        .character-avatar {
            flex-shrink: 0;
            width: 90px;
            height: 90px;
            border: 2px solid #eee;
            border-radius: 12px;
            background: #f8f8f8;
            cursor: pointer;
            overflow: hidden;
        }

        .character-avatar img {
            width: 100%;
            height: 100%;
            object-fit: cover;
        }

        /* 2. 右侧核心信息：占据所有剩余空间 */
        .core-details {
            flex: 1; /* 关键：占据所有剩余空间 */
            min-width: 0; /* 安全措施，防止内容溢出 */
            display: flex;
            flex-direction: column;
            gap: 12px; /* 姓名和性别选项之间的垂直间距 */
            padding-top: 4px; /* 微调，让姓名输入框与头像顶部更协调 */
        }

        .core-details input[type="text"] {
            width: 100%;
            border: none;
            border-bottom: 2px solid #ccc;
            padding: 6px 0;
            font-size: 20px;
            font-weight: bold;
            background: transparent;
            color: #000;
        }

        .core-details input[type="text"]:focus {
            outline: none;
            border-bottom-color: #000;
        }

        /* 性别选项：横向排列 */
        .character-gender-selection {
            display: flex;
            flex-direction: row;
            flex-wrap: wrap;
            gap: 18px; /* 加大选项间距，更美观 */
            align-items: center;
        }

        .character-gender-selection label {
            display: flex;
            align-items: center;
            cursor: pointer;
            font-size: 14px;
            font-weight: 500;
            color: #555;
        }

        .character-gender-selection input {
            margin-right: 6px;
        }


        .persona-section {
            width: 100%;
        }

        .persona-section textarea {
            width: 100%;
            height: 100px;
            padding: 12px;
            border: 2px solid #eee;
            border-radius: 12px;
            background: #f8f8f8;
            font-size: 14px;
            color: #333;
            resize: vertical;
            transition: border-color 0.2s, background-color 0.2s;
        }

        .persona-section textarea:focus {
            outline: none;
            border-color: #aaa;
            background: #fff;
        }

        .character-card-footer {
            display: flex;
            background: #f8f8f8;
            border-top: 2px solid #eee;
            border-bottom-left-radius: 20px;
            border-bottom-right-radius: 20px;
            overflow: hidden;
        }

        .character-card-btn {
            flex: 1;
            padding: 14px;
            border: none;
            background: transparent;
            font-size: 15px;
            font-weight: bold;
            cursor: pointer;
            transition: background 0.2s;
            color: #888;
        }

        .character-card-btn:hover {
            background: #eee;
        }

        .character-card-btn.save {
            background: #000;
            color: #fff;
        }

        .character-card-btn.save:hover {
            background: #333;
        }

        .contact-avatar img {
            width: 100%;
            height: 100%;
            object-fit: cover;
        }

        /* ▼▼▼ 第2步：在这里粘贴新增的CSS代码 ▼▼▼ */
        /* ========== 角色卡中的世界书区域样式 ========== */
        .character-card-content {
            max-height: 70vh; /* 限制最大高度，为滚动条做准备 */
            overflow-y: auto; /* 超出部分可滚动 */
        }

        .character-card-content::-webkit-scrollbar {
            width: 6px;
        }

        .character-card-content::-webkit-scrollbar-thumb {
            background: #ccc;
            border-radius: 3px;
        }

        .character-card-content::-webkit-scrollbar-track {
            background: #f1f1f1;
        }

        .character-worldbook-section {
            margin-top: 10px;
        }

        .char-wb-toggle {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 10px;
            background-color: #f8f8f8;
            border: 2px solid #eee;
            border-radius: 8px;
            cursor: pointer;
            user-select: none;
            transition: background-color 0.2s;
        }

        .char-wb-toggle:hover {
            background-color: #f0f0f0;
        }

        .char-wb-toggle-label {
            font-size: 14px;
            font-weight: 600;
            color: #333;
        }

        .char-wb-toggle-arrow {
            font-size: 12px;
            color: #888;
            transition: transform 0.3s ease;
        }

        .char-wb-toggle-arrow.open {
            transform: rotate(180deg);
        }

        .char-wb-list {
            margin-top: 8px;
            padding: 8px;
            background: #fdfdfd;
            border: 2px solid #eee;
            border-radius: 10px;
            max-height: 150px;
            overflow-y: auto;
        }

        .char-wb-item {
            display: flex;
            align-items: center;
            padding: 8px;
            border-bottom: 1px solid #f0f0f0;
            cursor: pointer;
        }

        .char-wb-item:last-child {
            border-bottom: none;
        }

        .char-wb-item input[type="checkbox"] {
            margin-right: 10px;
            cursor: pointer;
            accent-color: #555; /* 让复选框颜色更搭 */
        }

        .char-wb-item label {
            flex: 1;
            cursor: pointer;
            font-size: 14px;
            color: #555;
        }

        /* ▲▲▲ CSS代码粘贴结束 ▲▲▲ */


        .contact-avatar img {
            width: 100%;
            height: 100%;
            object-fit: cover;
        }

        .avatar-action-sheet.show {
            opacity: 1;
            visibility: visible;
        }

        .action-sheet-backdrop {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.4);
        }

        .action-sheet-options {
            position: relative;
            z-index: 1;
            background: #f0f2f5;
            padding: 8px;
            margin: 8px;
            border-radius: 14px;
            transform: translateY(100%);
            transition: transform 0.3s cubic-bezier(0.25, 0.46, 0.45, 0.94);
        }

        .avatar-action-sheet.show .action-sheet-options {
            transform: translateY(0);
        }

        .action-option {
            background: #fff;
            padding: 16px;
            text-align: center;
            font-size: 16px;
            font-weight: 500;
            color: #007aff;
            cursor: pointer;
            border-bottom: 1px solid #e5e5e5;
        }

        .action-option:first-child {
            border-top-left-radius: 12px;
            border-top-right-radius: 12px;
        }

        .action-option:last-child {
            border-bottom: none;
            border-bottom-left-radius: 12px;
            border-bottom-right-radius: 12px;
        }

        .action-option.cancel {
            background: #fff;
            margin-top: 8px;
            border-radius: 12px;
            font-weight: 600;
        }


        .success-modal {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.5);
            z-index: 2500;
            display: none;
            justify-content: center;
            align-items: center;
            opacity: 0;
            transition: opacity 0.3s ease;
            backdrop-filter: blur(4px);
        }

        .success-modal.show {
            opacity: 1;
        }

        .modal-content {
            background: white;
            padding: 24px 32px;
            border-radius: 16px;
            text-align: center;
            box-shadow: 0 10px 30px rgba(0, 0, 0, 0.2);
            transform: scale(0.9);
            transition: transform 0.3s cubic-bezier(0.25, 0.46, 0.45, 0.94);
        }

        .success-modal.show .modal-content {
            transform: scale(1);
        }

        .modal-content h3 {
            margin: 0 0 8px;
            font-size: 18px;
            color: #333;
        }

        .modal-content p {
            margin: 0;
            font-size: 14px;
            color: #666;
        }

        /* --- 复制并粘贴这段代码 --- */

        .settings-item {
            justify-content: space-between;
        }

        .settings-action {
            flex-shrink: 0;
        }

        .toggle-switch {
            position: relative;
            display: inline-block;
            width: 44px;
            height: 24px;
        }

        .toggle-switch input {
            opacity: 0;
            width: 0;
            height: 0;
        }

        .slider {
            position: absolute;
            cursor: pointer;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background-color: #ccc;
            transition: .4s;
            border-radius: 24px;
        }

        .slider:before {
            position: absolute;
            content: "";
            height: 20px;
            width: 20px;
            left: 2px;
            bottom: 2px;
            background-color: white;
            transition: .4s;
            border-radius: 50%;
        }

        input:checked + .slider {
            background-color: #667eea;
        }

        input:checked + .slider:before {
            transform: translateX(20px);
        }

        /* ========== 开始：粘贴这段新的 CSS 代码 ========== */

        .message-action-sheet {
            /* 样式与 avatar-action-sheet 类似，但有独立类名以防冲突 */
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            z-index: 1008; /* 层级高于聊天页面 */
            display: flex;
            flex-direction: column;
            justify-content: flex-end;
            opacity: 0;
            visibility: hidden;
            transition: opacity 0.3s ease, visibility 0.3s ease;
        }

        .message-action-sheet.show {
            opacity: 1;
            visibility: visible;
        }

        .message-action-sheet .action-sheet-backdrop {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.4);
        }

        .message-action-sheet .action-sheet-options {
            position: relative;
            z-index: 1;
            background: #f0f2f5;
            padding: 8px;
            margin: 8px;
            border-radius: 14px;
            transform: translateY(100%);
            transition: transform 0.3s cubic-bezier(0.25, 0.46, 0.45, 0.94);
        }

        .message-action-sheet.show .action-sheet-options {
            transform: translateY(0);
        }

        /* 为删除选项添加特殊的危险颜色 */

        .action-option.destructive {
            color: #ff3b30; /* iOS 风格的红色 */
        }

        /* 移除旧的、不再需要的删除按钮样式 */

        .delete-msg-btn {
            display: none; /* 直接隐藏，不再使用 */
        }

        /* ========== 开始：为代码块复制功能添加新样式 ========== */

        /* ========== 找到并修改这个规则 ========== */

        .code-block-wrapper {
            position: relative;
            display: flex;
            margin: 8px 0;
            min-width: 0;

            /* ========== 核心修改：限制代码块最大宽度 ========== */
            max-width: 280px; /* 与气泡的最大宽度保持一致或略小 */
            /* ========== 修改结束 ========== */
        }


        /* 2. 微调一下 pre 标签的样式 */
        /* 将 margin 移除，因为它已经在父容器上了 */

        .code-block-wrapper pre {
            margin: 0;
            /* 增加上方的内边距，给按钮留出空间 */
            padding-top: 36px;
        }


        /* 3. 复制按钮的样式 */

        .copy-code-btn {
            position: absolute;
            top: 8px;
            right: 8px;
            background: rgba(255, 255, 255, 0.1);
            border: 1px solid rgba(255, 255, 255, 0.2);
            color: #a0a0a0;
            padding: 5px 8px;
            border-radius: 6px;
            font-size: 12px;
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', sans-serif;
            cursor: pointer;
            opacity: 0; /* 默认隐藏 */
            transition: opacity 0.2s ease-in-out, background-color 0.2s ease-in-out;
            display: flex;
            align-items: center;
            gap: 4px; /* 图标和文字的间距 */
        }

        /* 4. 当鼠标悬停在整个代码块上时，显示按钮 */

        .code-block-wrapper:hover .copy-code-btn {
            opacity: 1;
        }

        /* 5. 按钮悬停时的效果 */

        .copy-code-btn:hover {
            background: rgba(255, 255, 255, 0.2);
            color: #d4d4d4;
        }

        /* 6. 按钮点击后的“已复制”状态 */

        .copy-code-btn.copied {
            background-color: #28a745; /* 绿色背景表示成功 */
            color: white;
        }

        /* 7. SVG 图标样式 */

        .copy-code-btn svg {
            width: 14px;
            height: 14px;
            fill: currentColor;
        }


        /* ========== 开始：分段选择器UI样式 ========== */

        .segmented-control {
            display: flex;
            background-color: #e9e9eb;
            border-radius: 8px;
            padding: 2px;
        }

        .segmented-option {
            flex: 1;
            padding: 6px 0;
            text-align: center;
            font-size: 13px;
            font-weight: 600;
            color: #555;
            cursor: pointer;
            border-radius: 6px;
            transition: all 0.2s ease-in-out;
        }

        .segmented-option.active {
            background-color: white;
            color: #000;
            box-shadow: 0 1px 3px rgba(0, 0, 0, 0.1);
        }

        /* ========== 开始：粘贴这段全新的 CSS 代码块 ========== */

        /* 1. 调整输入区域，为新按钮腾出空间 */

        .chat-input-area {
            position: relative; /* 这是让菜单定位的关键！ */
        }

        /* 2. 附件菜单容器的样式 */

        .attachment-menu {
            position: absolute; /* 相对于 .chat-input-area 定位 */
            bottom: 60px; /* 定位在输入框上方 */
            left: 12px;
            background: white;
            border-radius: 12px;
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.1);
            display: flex;
            gap: 16px;
            padding: 12px;

            /* 默认隐藏的动画属性 */
            opacity: 0;
            transform: translateY(10px);
            visibility: hidden;
            transition: all 0.25s cubic-bezier(0.25, 0.46, 0.45, 0.94);
            z-index: 10;
        }

        /* 3. 当菜单拥有 .show 类时，将它显示出来 */

        .attachment-menu.show {
            opacity: 1;
            transform: translateY(0);
            visibility: visible;
        }

        /* 4. 菜单中每个选项的样式 */

        .attachment-item {
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 8px;
            cursor: pointer;
        }

        /* 5. 选项中的图标样式 */

        .attachment-icon {
            width: 56px;
            height: 56px;
            background-color: #f0f2f5;
            border-radius: 14px;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 28px;
            transition: transform 0.2s;
        }

        .attachment-item:hover .attachment-icon {
            transform: scale(1.05);
        }

        /* 6. 选项中的文字标签样式 */

        .attachment-label {
            font-size: 12px;
            color: #6c757d;
            font-weight: 500;
        }

        /* 7. 调整旧的 #addMsgBtn，现在它变成了“+”按钮，所以样式也需要改一下 */

        #addMsgBtn {
            display: none; /* 隐藏旧的添加按钮，现在被发送按钮替代 */
        }

        /* === 猫咪胡须时间卡片CSS - 开始 === */

        /* 1. 外层 .time-card 容器保持相对定位，作为胡须的定位锚点 */
        .time-card {
            position: relative;
            padding: 0;
            overflow: visible;
            background: none;
            border: none;
            box-shadow: none;
            backdrop-filter: none;
            margin-bottom: 24px;
        }

        /* 隐藏不再需要的旧元素 */
        .time-card .card-background-wrapper {
            display: none;
        }

        .time-card .final-time-container::before,
        .time-card .final-time-container::after {
            display: none;
        }

        /* 2. 新增的 .whiskers-bg 层，这是实现效果的核心 */
        .whiskers-bg {
            position: relative; /* 作为胡须伪元素的定位参考 */
            width: 75%; /* 控制卡片宽度，比之前窄一点更可爱 */
            margin: 0 auto; /* 水平居中 */
            padding: 12px 20px;
            /* 核心：棕色背景 */
            background: #A1887F; /* 一个柔和的棕色 */
            border-radius: 20px; /* 可爱的圆角 */
            box-shadow: 0 6px 20px rgba(0, 0, 0, 0.12); /* 柔和的阴影 */
            border: 2px solid #ffffff; /* 添加白色边框增加质感 */

            /* 为胡须留出空间 */
            margin-left: auto;
            margin-right: auto;
        }

        /* 3. 使用伪元素创建左边的两条胡须 */
        .whiskers-bg::before {
            content: '';
            position: absolute;
            z-index: -1; /* 将胡须置于背景层之下 */
            top: 50%;

            /* 定位到左边并伸出去一点 */
            left: -20px;

            /* 胡须的尺寸 */
            width: 40px;
            height: 10px; /* 两条胡须之间的间距 */

            /* 用边框画出两条线 */
            border-top: 2.5px solid #FFC0D9; /* 粉色 */
            border-bottom: 2.5px solid #FFC0D9; /* 粉色 */

            /* 旋转和垂直居中 */
            transform: translateY(-50%) rotate(-20deg);
        }

        /* 4. 使用伪元素创建右边的两条胡须 */
        .whiskers-bg::after {
            content: '';
            position: absolute;
            z-index: -1;
            top: 50%;

            /* 定位到右边并伸出去一点 */
            right: -20px;

            width: 40px;
            height: 10px;
            border-top: 2.5px solid #FFC0D9;
            border-bottom: 2.5px solid #FFC0D9;

            /* 向相反方向旋转 */
            transform: translateY(-50%) rotate(20deg);
        }


        /* 5. 内部的时间容器 .final-time-container，现在只负责布局，不再有背景色 */
        .time-card .final-time-container {
            display: flex;
            flex-direction: row;
            align-items: baseline;
            justify-content: center;
            gap: 10px;
            /* 移除所有背景、边框和阴影样式 */
            width: 100%;
            margin: 0;
            padding: 0;
            background: none;
            backdrop-filter: none;
            border-radius: 0;
            border: none;
            box-shadow: none;
            position: relative;
            z-index: 2;
        }

        /* 6. 调整时间字体颜色，确保在棕色背景上清晰可见 */
        #finalMainTime {
            font-size: 38px;
            font-weight: 700;
            color: #FFF; /* 改为白色 */
            line-height: 1;
            margin: 0;
            text-shadow: 0 1px 2px rgba(0, 0, 0, 0.2); /* 轻微的阴影增加可读性 */
            letter-spacing: -1px;
        }

        /* 7. 调整日期字体颜色 */
        #finalMainDate {
            font-size: 13px;
            font-weight: 600;
            color: #F5EFE6; /* 一个非常浅的米白色，与主时间有区分 */
            margin: 0;
            padding-bottom: 4px;
            text-transform: uppercase;
            letter-spacing: 0.5px;
        }

        /* === 猫咪胡须时间卡片CSS - 结束 === */


        .card-divider {
            border-bottom: 2px dashed #eee;
            text-align: center;
            margin: 16px 0;
            position: relative;
        }

        .divider-text {
            position: relative;
            top: 10px;
            background: #fff;
            padding: 0 12px;
            font-size: 12px;
            font-weight: 600;
            color: #aaa;
        }

        #user-name {
            /* 让用户昵称输入框和角色名输入框样式一致 */
            width: 100%;
            border: none;
            border-bottom: 2px solid #ccc;
            padding: 6px 0;
            font-size: 20px;
            font-weight: bold;
            background: transparent;
            color: #000;
            transition: border-color 0.2s;
        }

        #user-name:focus {
            outline: none;
            border-bottom-color: #000;
        }

        /* 在"可爱卡片背景CSS"之前添加这段 */
        .weather-card {
            border-radius: 22px;
            display: flex;
            flex-direction: column;
            gap: 12px;
            box-shadow: 0 4px 20px rgba(168, 201, 245, 0.15);
            border: 1px solid rgba(168, 201, 245, 0.2);
            position: relative;
            backdrop-filter: blur(10px);
        }

        .weather-card {
            position: relative; /* 确保卡片成为内部绝对定位元素的锚点 */
            overflow: hidden; /* 隐藏超出卡片圆角的背景 */
            background: none; /* 移除卡片自身的背景色/渐变 */
            border: none; /* 移除卡片自身的边框 */
            padding: 0; /* 移除内边距，因为内容需要重新定位 */
        }

        .weather-card > * {
            position: relative;
            z-index: 2; /* 确保内容层级高于背景 */
        }

        /* 2. 确保所有内容都在背景之上 */
        .weather-card > .mood-section {
            padding: 20px;
        }

        .weather-card > .top-row {
            padding-top: 20px;
        }

        .weather-card > .mood-section {
            padding-bottom: 20px;
        }

        .weather-card > .weather-popup {
            /* 修正弹窗位置问题 */
            left: calc(50% - 12px);
        }

        /* 3. 背景的包裹容器样式 */
        .card-background-wrapper {
            position: absolute; /* 绝对定位，脱离文档流 */
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            z-index: 1; /* 在内容之下 */
        }

        .card-background-wrapper .top-gingham-bg {
            height: 50%;
            background-color: white;
            background-image: linear-gradient(to right, rgba(255, 192, 203, 0.6) 50%, transparent 50%),
            linear-gradient(to bottom, rgba(255, 192, 203, 0.6) 50%, transparent 50%);
            background-size: 30px 30px; /* 格子尺寸调小一些以适应卡片 */
        }

        .card-background-wrapper .bottom-stripes-bg {
            height: 50%;
            background-color: #fffafc;
            background-image: repeating-linear-gradient(
                    90deg,
                    #ffeaf0, #ffeaf0 15px,
                    #fffafc 15px, #fffafc 30px
            );
        }

        .card-background-wrapper .drip-divider {
            position: absolute;
            top: 50%;
            left: 0;
            width: 100%;
            height: 40px; /* 滴落效果高度 */
            transform: translateY(-50%);
        }

        .card-background-wrapper .drip-divider::before {
            content: '';
            position: absolute;
            bottom: 0;
            left: 0;
            right: 0;
            height: 100%;
            mask-size: 100% 100%;
            -webkit-mask-size: 100% 100%;
            background: linear-gradient(to top, rgba(255, 255, 255, 0.6), rgba(255, 255, 255, 0.15) 50%, transparent);
            border: 1px solid rgba(255, 255, 255, 0.5);
            border-bottom: none;
            filter: drop-shadow(0 2px 4px rgba(220, 150, 160, 0.15));
        }

        /* 6. 中间的波浪奶油分割线 */
        .drip-divider {
            position: absolute;
            top: 52%; /* 精确调整分割线的位置 */
            left: 0;
            width: 100%;
            height: 30px; /* 控制波浪的高度 */
            /* 使用内联SVG作为背景图片来创建形状 */
            background-image: url("data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 100 10'%3E%3Cpath d='M0 2 Q 10 7, 20 3 Q 30 0, 40 4 Q 50 8, 60 5 Q 70 2, 80 6 Q 90 10, 100 5 L100 0 L0 0 Z' fill='rgba(255,255,255,0.7)'/%3E%3C/svg%3E");
            background-repeat: no-repeat;
            background-size: 100% 100%;
            /* 使用 backdrop-filter 制作磨砂玻璃质感 */
            backdrop-filter: blur(5px);
            -webkit-backdrop-filter: blur(5px); /* 兼容 Safari */
        }

        /* ---可爱卡片背景CSS - 结束--- */
        /* BUG 修复：强制天气卡片内的删除按钮使用绝对定位，防止其影响卡片高度 */
        .weather-card > .delete-weather-btn {
            position: absolute;
            z-index: 250;
        }


        /* ========== 开始：粘贴这段全新的CSS代码 ========== */

        .avatar-action-sheet {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            z-index: 1011; /* 比卡片高，比模态框覆盖层低 */
            display: flex;
            flex-direction: column;
            justify-content: flex-end;
            /* 默认隐藏 */
            opacity: 0;
            visibility: hidden;
            transition: opacity 0.3s ease, visibility 0.3s ease;
        }

        .avatar-action-sheet.show {
            opacity: 1;
            visibility: visible;
        }

        .action-sheet-backdrop {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.4);
        }

        .action-sheet-options {
            position: relative;
            z-index: 1;
            padding: 0;
            margin: 8px;
            /* 动画效果：从下方滑入 */
            transform: translateY(100%);
            transition: transform 0.3s cubic-bezier(0.25, 0.46, 0.45, 0.94);
        }

        .avatar-action-sheet.show .action-sheet-options {
            transform: translateY(0);
        }

        .action-option {
            background: rgba(255, 255, 255, 0.9);
            backdrop-filter: blur(10px);
            padding: 16px;
            text-align: center;
            font-size: 16px;
            font-weight: 500;
            color: #007aff; /* iOS 风格的蓝色 */
            cursor: pointer;
            border-bottom: 1px solid rgba(0, 0, 0, 0.1);
        }

        .action-option:first-child {
            border-top-left-radius: 12px;
            border-top-right-radius: 12px;
        }

        .action-option:last-child {
            border-bottom: none;
            border-bottom-left-radius: 12px;
            border-bottom-right-radius: 12px;
        }

        .action-option.cancel {
            background: white;
            margin-top: 8px;
            border-radius: 12px;
            font-weight: 600;
        }

        .action-option:active {
            background: rgba(230, 230, 230, 0.9);
        }

        /* ========== 结束：粘贴全新的CSS代码 ========== */
        /* 确保ID区域不会挤压中间内容 */
        .character-id {
            font-size: 12px;
            color: #888;
            margin-top: auto;
            font-family: 'Menlo', 'Monaco', monospace;
            flex-shrink: 0; /* 防止收缩 */
            max-width: 80px; /* 限制最大宽度 */
            word-break: break-all; /* 允许ID换行 */
        }

        /* 改进性别选择的样式 */
        .character-gender-selection {
            color: #555;
            font-size: 14px;
            display: flex;
            gap: 12px;
            margin-top: 4px;
        }

        .character-gender-selection label {
            display: flex;
            align-items: center;
            cursor: pointer;
            font-weight: 500;
        }

        .character-gender-selection input {
            margin-right: 6px;
        }

        /* 确保核心详情区域有足够空间 */
        .core-details {
            flex: 1;
            display: flex;
            flex-direction: column;
            gap: 8px;
            min-width: 0; /* 允许内容收缩 */
        }

        /* 确保姓名输入框不会被挤压 */
        .core-details input[type="text"] {
            width: 100%;
            border: none;
            border-bottom: 2px solid #ccc;
            padding: 6px 0;
            font-size: 20px;
            font-weight: bold;
            background: transparent;
            color: #000;
            transition: border-color 0.2s;
            min-width: 0; /* 重要：允许输入框收缩 */
        }

        /* ========== 开始：粘贴悬浮球的全新CSS样式 ========== */

        #floatingBall {
            position: absolute;
            bottom: 120px; /* 初始位置，在Dock栏上方 */
            right: 20px;
            width: 50px;
            height: 50px;
            background: linear-gradient(135deg, #ff9a9e, #fecfef); /* 可爱粉色渐变 */
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 28px;
            color: white;
            text-shadow: 0 1px 2px rgba(0, 0, 0, 0.2);
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.2);
            cursor: grab; /* 提示用户可以抓取 */
            z-index: 2000; /* 确保在最顶层 */
            user-select: none; /* 防止拖动时选中文本 */
            transition: left 0.3s ease-out, top 0.3s ease-out, transform 0.2s ease; /* 用于吸附和点击效果 */
        }

        #floatingBall.dragging {
            cursor: grabbing;
            transform: scale(1.1); /* 拖动时放大一点点 */
            transition: none; /* 拖动时取消过渡动画，保证流畅 */
            box-shadow: 0 8px 20px rgba(0, 0, 0, 0.25);
        }

        /* ========== 结束：粘贴悬浮球的全新CSS样式 ========== */
        /* ========== 白色图标栏目样式 ========== */
        .icon-dock-panel {
            position: absolute;
            top: 0;
            right: 0;
            width: 80px;
            height: 100%;
            background: rgba(255, 255, 255, 0.95);
            backdrop-filter: blur(10px);
            box-shadow: -4px 0 12px rgba(0, 0, 0, 0.1);
            transform: translateX(100%);
            transition: transform 0.3s cubic-bezier(0.25, 0.46, 0.45, 0.94);
            z-index: 1500;
            display: flex;
            flex-direction: column;
        }

        .icon-dock-panel.show {
            transform: translateX(0);
        }

        .dock-panel-header {
            padding: 50px 8px 12px;
            border-bottom: 1px solid rgba(0, 0, 0, 0.05);
            flex-shrink: 0;
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 8px;
        }

        .dock-panel-title {
            font-size: 12px;
            font-weight: 600;
            color: #333;
            text-align: center;
        }

        .dock-panel-close {
            width: 24px;
            height: 24px;
            border-radius: 50%;
            background: #f0f0f0;
            border: none;
            color: #666;
            font-size: 18px;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            transition: all 0.2s;
        }

        .dock-panel-close:hover {
            background: #e0e0e0;
            transform: rotate(90deg);
        }

        .dock-panel-content {
            flex: 1;
            overflow-y: auto;
            padding: 12px 8px;
            display: flex;
            flex-direction: column;
            gap: 12px;
        }

        .dock-panel-content::-webkit-scrollbar {
            width: 4px;
        }

        .dock-panel-content::-webkit-scrollbar-track {
            background: transparent;
        }

        .dock-panel-content::-webkit-scrollbar-thumb {
            background: rgba(0, 0, 0, 0.2);
            border-radius: 2px;
        }

        .dock-panel-empty {
            padding: 20px 8px;
            text-align: center;
            font-size: 11px;
            color: #999;
            line-height: 1.4;
        }

        /* 栏目中的图标样式 */
        .dock-panel-icon {
            width: 100%;
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 4px;
            cursor: pointer;
            padding: 8px 4px;
            border-radius: 12px;
            transition: background 0.2s;
        }

        .dock-panel-icon:hover {
            background: rgba(0, 0, 0, 0.05);
        }

        .dock-panel-icon .icon-wrapper {
            width: 48px;
            height: 48px;
        }

        .dock-panel-icon .app-label {
            font-size: 10px;
            max-width: 100%;
            text-shadow: none;
            color: #333;
        }

        /* 悬浮球菜单样式 */
        .floating-ball-menu {
            position: absolute;
            bottom: 180px;
            right: 20px;
            background: white;
            border-radius: 16px;
            box-shadow: 0 8px 24px rgba(0, 0, 0, 0.15);
            overflow: hidden;
            opacity: 0;
            visibility: hidden;
            transform: scale(0.8) translateY(10px);
            transition: all 0.25s cubic-bezier(0.34, 1.56, 0.64, 1);
            z-index: 2001;
            min-width: 140px;
        }

        .floating-ball-menu.show {
            opacity: 1;
            visibility: visible;
            transform: scale(1) translateY(0);
        }

        .fb-menu-item {
            display: flex;
            align-items: center;
            gap: 10px;
            padding: 14px 16px;
            cursor: pointer;
            transition: background 0.2s;
            border-bottom: 1px solid rgba(0, 0, 0, 0.05);
        }

        .fb-menu-item:last-child {
            border-bottom: none;
        }

        .fb-menu-item:active {
            background: #f5f5f5;
        }

        .fb-menu-icon {
            font-size: 20px;
            flex-shrink: 0;
        }

        .fb-menu-label {
            font-size: 14px;
            font-weight: 500;
            color: #333;
            white-space: nowrap;
        }

        /* 拖拽到栏目时的高亮效果 */
        .icon-dock-panel.drag-over {
            background: rgba(102, 126, 234, 0.1);
        }

        .icon-dock-panel.drag-over::before {
            content: '松开以添加';
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            font-size: 12px;
            font-weight: 600;
            color: #667eea;
            pointer-events: none;
        }

        /* ========== 开始：新增的密友列表页面样式 ========== */

        /* 1. 页面主容器样式 (粉色到褐色的可爱渐变) */
        .sweetheart-list-page {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: linear-gradient(180deg, #F8E8EE 0%, #EEDDD3 100%); /* 柔和的粉-褐渐变 */
            transform: translateY(100%); /* 默认从下方隐藏 */
            transition: transform 0.35s cubic-bezier(0.25, 0.46, 0.45, 0.94);
            z-index: 1003; /* 与其他页面层级类似 */
            display: flex;
            flex-direction: column;
        }

        /* 2. 当有 .show 类时，页面滑入 */
        .sweetheart-list-page.show {
            transform: translateY(0);
        }

        /* 3. 头部样式 */
        .sweetheart-list-header {
            display: flex;
            align-items: center;
            padding: 45px 20px 20px;
            background: rgba(255, 245, 240, 0.7); /* 半透明的柔粉色 */
            backdrop-filter: blur(10px);
            box-shadow: 0 2px 8px rgba(161, 136, 127, 0.1); /* 柔和的棕色阴影 */
            flex-shrink: 0;
        }

        /* 4. 标题样式 (使用深褐色文字) */
        .sweetheart-list-title {
            flex: 1;
            text-align: center;
            font-size: 18px;
            font-weight: 600;
            color: #A1887F; /* 温馨的深褐色 */
            margin-right: 36px; /* 为返回按钮留出空间 */
        }

        /* 5. 列表容器样式 */
        .sweetheart-list-content {
            flex: 1;
            overflow-y: auto;
            padding-top: 12px;
        }

        .sweetheart-list-content::-webkit-scrollbar {
            display: none;
        }

        /* 6. 每个联系人项目的样式 */
        .sweetheart-item {
            display: flex;
            align-items: center;
            gap: 12px;
            padding: 12px 20px;
            margin: 0 12px 10px;
            background: rgba(255, 255, 255, 0.8); /* 半透明白色，增加层次感 */
            border-radius: 16px;
            box-shadow: 0 4px 12px rgba(161, 136, 127, 0.1);
            cursor: pointer;
            transition: all 0.2s ease;
            border: 1px solid rgba(255, 255, 255, 0.9);
        }

        .sweetheart-item:active {
            transform: scale(0.97);
            background: rgba(255, 255, 255, 1);
        }

        /* 7. 头像样式 (带有可爱的粉色边框) */
        .sweetheart-avatar {
            width: 52px;
            height: 52px;
            border-radius: 50%;
            flex-shrink: 0;
            overflow: hidden;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 24px;
            background: #fff;
            border: 2px solid #FFC0D9; /* 可爱的粉色边框 */
        }

        .sweetheart-avatar img {
            width: 100%;
            height: 100%;
            object-fit: cover;
        }

        /* 8. 姓名和状态的容器 */
        .sweetheart-info {
            flex: 1;
            min-width: 0;
        }

        /* 9. 姓名样式 */
        .sweetheart-name {
            font-size: 16px;
            font-weight: 600;
            color: #8D6E63; /* 比标题略浅的棕色 */
            margin-bottom: 2px;
        }

        /* 10. 状态/最后消息样式 */
        .sweetheart-status {
            font-size: 13px;
            color: #BCAAA4; /* 柔和的浅棕灰色 */
            overflow: hidden;
            text-overflow: ellipsis;
            white-space: nowrap;
        }

        /* ========== 结束：新增的密友列表页面样式 ========== */
        /* ========== 密友角色卡 - 粉褐色可爱风格 ========== */

        /* 弹窗容器 */
        #sweetheartCardModal {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(161, 136, 127, 0.5);
            z-index: 1020;
            display: flex;
            justify-content: center;
            align-items: center;
            padding: 20px;
            opacity: 0;
            visibility: hidden;
            transition: all 0.3s ease;
            backdrop-filter: blur(5px);
        }

        #sweetheartCardModal.show {
            opacity: 1;
            visibility: visible;
        }

        /* 卡片主体 */
        .sweetheart-card-modal {
            background: linear-gradient(180deg, #FFF5F5 0%, #FFE8E8 100%);
            border: 4px solid #FFB6C1;
            border-radius: 24px;
            width: 100%;
            max-width: 340px;
            max-height: 85vh;
            overflow: hidden;
            box-shadow: 0 20px 60px rgba(255, 182, 193, 0.4);
            transform: scale(0.9);
            transition: transform 0.3s cubic-bezier(0.34, 1.56, 0.64, 1);
        }

        #sweetheartCardModal.show .sweetheart-card-modal {
            transform: scale(1);
        }

        /* 顶部装饰条 */
        .sweetheart-card-header {
            background: linear-gradient(135deg, #FFB6C1, #FFC0D9);
            padding: 16px;
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 12px;
            border-bottom: 3px solid #FF9AAD;
        }

        .header-deco {
            font-size: 20px;
            animation: float 2s ease-in-out infinite;
        }

        .header-deco:nth-child(3) {
            animation-delay: 0.5s;
        }

        @keyframes float {
            0%, 100% {
                transform: translateY(0);
            }
            50% {
                transform: translateY(-5px);
            }
        }

        .header-title {
            font-size: 18px;
            font-weight: 700;
            color: white;
            text-shadow: 0 2px 4px rgba(161, 136, 127, 0.3);
        }

        /* 内容区域 */
        .sweetheart-card-content {
            padding: 20px;
            max-height: 60vh;
            overflow-y: auto;
        }

        .sweetheart-card-content::-webkit-scrollbar {
            width: 6px;
        }

        .sweetheart-card-content::-webkit-scrollbar-track {
            background: #FFE8E8;
        }

        .sweetheart-card-content::-webkit-scrollbar-thumb {
            background: #FFB6C1;
            border-radius: 3px;
        }

        /* 头像区域 */
        .sweetheart-avatar-section {
            display: flex;
            justify-content: center;
            margin-bottom: 20px;
        }

        .sweetheart-avatar {
            width: 100px;
            height: 100px;
            border-radius: 50%;
            border: 4px solid #FFB6C1;
            overflow: hidden;
            position: relative;
            cursor: pointer;
            box-shadow: 0 4px 12px rgba(255, 182, 193, 0.4);
            transition: transform 0.2s ease;
        }

        .sweetheart-avatar:hover {
            transform: scale(1.05);
        }

        .sweetheart-avatar img {
            width: 100%;
            height: 100%;
            object-fit: cover;
        }

        .avatar-overlay {
            position: absolute;
            bottom: 0;
            left: 0;
            right: 0;
            background: rgba(255, 182, 193, 0.9);
            padding: 6px;
            text-align: center;
            font-size: 18px;
            opacity: 0;
            transition: opacity 0.2s;
        }

        .sweetheart-avatar:hover .avatar-overlay {
            opacity: 1;
        }

        /* 表单字段 */
        .sweetheart-field {
            margin-bottom: 16px;
        }

        .sweetheart-label {
            display: flex;
            align-items: center;
            gap: 6px;
            margin-bottom: 8px;
            font-size: 14px;
            font-weight: 600;
            color: #8D6E63;
        }

        .label-icon {
            font-size: 16px;
        }

        .required-star {
            color: #FF6B9D;
            font-weight: bold;
        }

        /* 输入框 */
        .sweetheart-input,
        .sweetheart-textarea {
            width: 100%;
            padding: 12px 14px;
            border: 2px solid #FFD1DC;
            border-radius: 12px;
            font-size: 14px;
            font-family: inherit;
            background: white;
            transition: all 0.2s ease;
        }

        .sweetheart-input:focus,
        .sweetheart-textarea:focus {
            outline: none;
            border-color: #FFB6C1;
            box-shadow: 0 0 0 3px rgba(255, 182, 193, 0.2);
        }

        .sweetheart-textarea {
            resize: vertical;
            min-height: 80px;
        }

        /* 必填字段样式 */
        .required-field .sweetheart-input,
        .required-field .sweetheart-textarea {
            border-color: #FFB6C1;
            background: #FFFAFA;
        }

        /* 世界书折叠区域 */
        .sweetheart-label-toggle {
            display: flex;
            justify-content: space-between;
            align-items: center;
            cursor: pointer;
            padding: 8px 12px;
            background: #FFF0F5;
            border-radius: 10px;
            transition: background 0.2s;
            user-select: none;
        }

        .sweetheart-label-toggle:hover {
            background: #FFE4E9;
        }

        .toggle-arrow {
            font-size: 12px;
            color: #FFB6C1;
            transition: transform 0.3s ease;
        }

        .toggle-arrow.open {
            transform: rotate(180deg);
        }

        .sweetheart-worldbooks-list {
            margin-top: 12px;
            padding: 12px;
            background: white;
            border: 2px solid #FFD1DC;
            border-radius: 10px;
            max-height: 180px;
            overflow-y: auto;
        }

        .sweetheart-wb-item {
            display: flex;
            align-items: center;
            padding: 8px;
            border-bottom: 1px solid #FFF0F5;
            cursor: pointer;
            transition: background 0.2s;
        }

        .sweetheart-wb-item:last-child {
            border-bottom: none;
        }

        .sweetheart-wb-item:hover {
            background: #FFF5F8;
        }

        .sweetheart-wb-item input[type="checkbox"] {
            margin-right: 10px;
            cursor: pointer;
            width: 18px;
            height: 18px;
            accent-color: #FFB6C1;
        }

        .sweetheart-wb-item label {
            flex: 1;
            cursor: pointer;
            font-size: 14px;
            color: #8D6E63;
        }

        /* 底部按钮 */
        .sweetheart-card-footer {
            display: flex;
            padding: 16px;
            gap: 12px;
            background: #FFF0F5;
            border-top: 2px solid #FFD1DC;
        }

        .sweetheart-btn {
            flex: 1;
            padding: 14px;
            border: none;
            border-radius: 12px;
            font-size: 15px;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.2s ease;
            box-shadow: 0 4px 8px rgba(0, 0, 0, 0.1);
        }

        .btn-cancel {
            background: white;
            color: #BCAAA4;
            border: 2px solid #E0D5D1;
        }

        .btn-cancel:hover {
            background: #F5F5F5;
            transform: translateY(-2px);
        }

        .btn-cancel:active {
            transform: translateY(0);
        }

        .btn-save {
            background: linear-gradient(135deg, #FFB6C1, #FF9AAD);
            color: white;
            box-shadow: 0 4px 12px rgba(255, 182, 193, 0.4);
        }

        .btn-save:hover {
            background: linear-gradient(135deg, #FF9AAD, #FF8BA0);
            transform: translateY(-2px);
            box-shadow: 0 6px 16px rgba(255, 182, 193, 0.5);
        }

        .btn-save:active {
            transform: translateY(0);
        }

        /* ========== 步骤1：在这里粘贴“密友专属”聊天主题CSS ========== */

        /* 当聊天页面 (.chat-page) 同时拥有 .sweetheart-mode 类时，以下所有样式生效 */

        .chat-page.sweetheart-mode .chat-header {
            background: linear-gradient(135deg, #FFF0F5, #FFE4E9); /* 柔和的粉色渐变 */
            box-shadow: 0 2px 8px rgba(212, 165, 165, 0.2);
            border-bottom: 1px solid rgba(255, 228, 233, 0.8);
        }

        .chat-page.sweetheart-mode .chat-title {
            color: #8D6E63; /* 深褐色文字，更显质感 */
            font-weight: 700;
        }

        .chat-page.sweetheart-mode .back-btn,
        .chat-page.sweetheart-mode .edit-contact-btn,
        .chat-page.sweetheart-mode .chat-settings-btn {
            color: #D4A5A5; /* 柔和的粉棕色 */
            background: rgba(255, 255, 255, 0.5);
            font-size: 20px;
        }

        .chat-page.sweetheart-mode .chat-header .back-btn:hover,
        .chat-page.sweetheart-mode .chat-header .edit-contact-btn:hover,
        .chat-page.sweetheart-mode .chat-header .chat-settings-btn:hover {
            background: rgba(255, 255, 255, 0.8);
        }

        /* 可爱的聊天背景，带有一点点心形图案 */
        .chat-page.sweetheart-mode .chat-messages {
            background-color: #FDF6F8;
            background-image: url("data:image/svg+xml,%3Csvg width='60' height='60' viewBox='0 0 60 60' xmlns='http://www.w3.org/2000/svg'%3E%3Cg fill='none' fill-rule='evenodd'%3E%3Cg fill='%23F8E8EE' fill-opacity='0.4'%3E%3Cpath d='M36 34v-4h-2v4h-4v2h4v4h2v-4h4v-2h-4zm0-30V0h-2v4h-4v2h4v4h2V6h4V4h-4zM6 34v-4H4v4H0v2h4v4h2v-4h4v-2H6zM6 4V0H4v4H0v2h4v4h2V6h4V4H6z'/%3E%3C/g%3E%3C/g%3E%3C/svg%3E");
        }

        /* 我方发送的气泡（粉色） */
        .chat-page.sweetheart-mode .message-row.sent .chat-bubble {
            background: linear-gradient(135deg, #FFB6C1, #FF9AAD);
            color: white;
            box-shadow: 0 3px 8px rgba(255, 182, 193, 0.3);
        }

        /* 对方发送的气泡（白色带粉边） */
        .chat-page.sweetheart-mode .message-row.received .chat-bubble {
            background: #FFFFFF;
            color: #8D6E63;
            border: 1px solid #FFE4E9;
            box-shadow: 0 2px 6px rgba(161, 136, 127, 0.08);
        }

        /* 输入区域 */
        .chat-page.sweetheart-mode .chat-input-area {
            background: #FFF5F8;
            border-top-color: #FFE8E8;
        }

        .chat-page.sweetheart-mode .chat-input-area input {
            background: white;
            border: 1px solid #FFD1DC;
        }

        .chat-page.sweetheart-mode .chat-input-area .chat-action-btn.primary {
            background: #FFB6C1; /* 发送按钮也变成粉色 */
        }

        /* ========== 世界选择页面样式 ========== */
        .world-select-page {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: linear-gradient(180deg, #E8F4F8 0%, #D4E9F0 100%);
            transform: translateY(100%);
            transition: transform 0.35s cubic-bezier(0.25, 0.46, 0.45, 0.94);
            z-index: 1007;
            display: flex;
            flex-direction: column;
        }

        .world-select-page.show {
            transform: translateY(0);
        }

        .world-select-header {
            display: flex;
            align-items: center;
            padding: 45px 20px 30px;
            background: rgba(255, 255, 255, 0.9);
            backdrop-filter: blur(10px);
            box-shadow: 0 2px 8px rgba(76, 150, 175, 0.1);
        }

        .world-select-header .world-select-title {
            flex: 1;
            text-align: center;
            margin-right: 36px; /* 为返回按钮留出空间，保持标题居中 */
        }


        .world-select-title {
            font-size: 22px;
            font-weight: 600;
            color: #2C6B8F;
            text-align: center;
        }

        .world-select-content {
            flex: 1;
            overflow-y: auto;
            padding: 20px;
            display: flex;
            flex-direction: column;
            gap: 16px;
        }

        .world-select-content::-webkit-scrollbar {
            display: none;
        }

        /* 世界卡片 */
        .world-card {
            background: white;
            border-radius: 20px;
            padding: 24px;
            box-shadow: 0 4px 12px rgba(44, 107, 143, 0.15);
            cursor: pointer;
            transition: all 0.3s ease;
            border: 2px solid transparent;
        }

        .world-card:hover {
            transform: translateY(-4px);
            box-shadow: 0 8px 24px rgba(44, 107, 143, 0.25);
            border-color: #5FB3D6;
        }

        .world-card-icon {
            font-size: 48px;
            text-align: center;
            margin-bottom: 16px;
        }

        .world-card-name {
            font-size: 18px;
            font-weight: 600;
            color: #2C6B8F;
            text-align: center;
            margin-bottom: 8px;
        }

        .world-card-desc {
            font-size: 13px;
            color: #7FB5D1;
            text-align: center;
            line-height: 1.5;
        }

        .world-card-contacts {
            font-size: 12px;
            color: #999;
            text-align: center;
            margin-top: 12px;
            padding-top: 12px;
            border-top: 1px solid #E8F4F8;
        }

        /* 新建世界按钮 */
        .world-card.new-world {
            border: 2px dashed #5FB3D6;
            background: rgba(95, 179, 214, 0.05);
        }

        .world-card.new-world:hover {
            background: rgba(95, 179, 214, 0.1);
            border-color: #2C6B8F;
        }

        /* ========== 新建世界弹窗样式 ========== */
        .new-world-modal-card {
            background: linear-gradient(180deg, #F0F8FB 0%, #E1F0F5 100%);
            border: 4px solid #5FB3D6;
            border-radius: 24px;
            width: 100%;
            max-width: 340px;
            max-height: 85vh;
            overflow: hidden;
            box-shadow: 0 20px 60px rgba(95, 179, 214, 0.4);
            transform: scale(0.9);
            transition: transform 0.3s cubic-bezier(0.34, 1.56, 0.64, 1);
        }

        #newWorldModal.show .new-world-modal-card {
            transform: scale(1);
        }

        .new-world-header {
            background: linear-gradient(135deg, #5FB3D6, #4A9CBF);
            padding: 16px;
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 12px;
            border-bottom: 3px solid #3D8AAD;
        }

        .new-world-content {
            padding: 20px;
            max-height: 60vh;
            overflow-y: auto;
        }

        .world-field {
            margin-bottom: 16px;
        }

        .world-label {
            display: flex;
            align-items: center;
            gap: 6px;
            margin-bottom: 8px;
            font-size: 14px;
            font-weight: 600;
            color: #2C6B8F;
        }

        .world-input,
        .world-textarea {
            width: 100%;
            padding: 12px 14px;
            border: 2px solid #B8D9E8;
            border-radius: 12px;
            font-size: 14px;
            font-family: inherit;
            background: white;
            transition: all 0.2s ease;
        }

        .world-input:focus,
        .world-textarea:focus {
            outline: none;
            border-color: #5FB3D6;
            box-shadow: 0 0 0 3px rgba(95, 179, 214, 0.2);
        }

        .world-textarea {
            resize: vertical;
            min-height: 60px;
        }

        .required-field .world-input {
            border-color: #5FB3D6;
            background: #FAFCFD;
        }

        .world-label-toggle {
            display: flex;
            justify-content: space-between;
            align-items: center;
            cursor: pointer;
            padding: 8px 12px;
            background: #F0F8FB;
            border-radius: 10px;
            transition: background 0.2s;
            user-select: none;
        }

        .world-label-toggle:hover {
            background: #E1F0F5;
        }

        .world-worldbooks-list {
            margin-top: 12px;
            padding: 12px;
            background: white;
            border: 2px solid #B8D9E8;
            border-radius: 10px;
            max-height: 180px;
            overflow-y: auto;
        }

        .world-wb-item {
            display: flex;
            align-items: center;
            padding: 8px;
            border-bottom: 1px solid #F0F8FB;
            cursor: pointer;
            transition: background 0.2s;
        }

        .world-wb-item:last-child {
            border-bottom: none;
        }

        .world-wb-item:hover {
            background: #F8FCFD;
        }

        .world-wb-item input[type="checkbox"] {
            margin-right: 10px;
            cursor: pointer;
            width: 18px;
            height: 18px;
            accent-color: #5FB3D6;
        }

        .world-wb-item label {
            flex: 1;
            cursor: pointer;
            font-size: 14px;
            color: #2C6B8F;
        }

        .new-world-footer {
            display: flex;
            padding: 16px;
            gap: 12px;
            background: #F0F8FB;
            border-top: 2px solid #B8D9E8;
        }

        .world-btn {
            flex: 1;
            padding: 14px;
            border: none;
            border-radius: 12px;
            font-size: 15px;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.2s ease;
            box-shadow: 0 4px 8px rgba(0, 0, 0, 0.1);
        }

        .world-btn.btn-cancel {
            background: white;
            color: #7FB5D1;
            border: 2px solid #B8D9E8;
        }

        .world-btn.btn-cancel:hover {
            background: #F5F5F5;
            transform: translateY(-2px);
        }

        .world-btn.btn-save {
            background: linear-gradient(135deg, #5FB3D6, #4A9CBF);
            color: white;
            box-shadow: 0 4px 12px rgba(95, 179, 214, 0.4);
        }

        .world-btn.btn-save:hover {
            background: linear-gradient(135deg, #4A9CBF, #3D8AAD);
            transform: translateY(-2px);
            box-shadow: 0 6px 16px rgba(95, 179, 214, 0.5);
        }


        /* ========== 世界书页面样式 - 开始 ========== */

        /* 1. 世界书主页面容器 */
        .worldbook-page {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: linear-gradient(180deg, #E8F5E9 0%, #F1F8E9 100%); /* 清新的绿色渐变 */
            transform: translateY(100%);
            transition: transform 0.35s cubic-bezier(0.25, 0.46, 0.45, 0.94);
            z-index: 1004;
            display: flex;
            flex-direction: column;
        }

        .worldbook-page.show {
            transform: translateY(0);
        }

        /* 2. 头部导航栏 */
        .worldbook-header {
            display: flex;
            align-items: center;
            padding: 45px 20px 20px;
            background: rgba(255, 255, 255, 0.9);
            backdrop-filter: blur(10px);
            box-shadow: 0 2px 8px rgba(76, 175, 80, 0.1);
            flex-shrink: 0;
        }

        .worldbook-title {
            flex: 1;
            text-align: center;
            font-size: 18px;
            font-weight: 600;
            color: #4CAF50;
            margin-right: 36px;
        }

        /* 3. 内容区域 */
        .worldbook-content {
            flex: 1;
            overflow-y: auto;
            padding: 20px;
            display: flex;
            flex-direction: column;
        }

        .worldbook-content::-webkit-scrollbar {
            display: none;
        }

        /* 4. 空状态提示 */
        .worldbook-empty {
            flex: 1;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            text-align: center;
            color: #81C784;
            padding: 40px 20px;
        }

        .worldbook-empty-icon {
            font-size: 64px;
            margin-bottom: 16px;
        }

        .worldbook-empty-text {
            font-size: 15px;
            line-height: 1.6;
            margin-bottom: 8px;
        }

        .worldbook-empty-hint {
            font-size: 13px;
            color: #A5D6A7;
        }

        /* 5. 世界书条目列表 */
        .worldbook-list {
            display: flex;
            flex-direction: column;
            gap: 12px;
        }

        .worldbook-item {
            background: white;
            padding: 16px;
            border-radius: 16px;
            box-shadow: 0 2px 8px rgba(76, 175, 80, 0.08);
            cursor: pointer;
            transition: all 0.2s ease;
            border-left: 4px solid #4CAF50;
        }

        .worldbook-item:active {
            transform: scale(0.98);
            box-shadow: 0 4px 12px rgba(76, 175, 80, 0.15);
        }

        .worldbook-item-title {
            font-size: 16px;
            font-weight: 600;
            color: #2E7D32;
            margin-bottom: 8px;
        }

        .worldbook-item-category {
            font-size: 12px;
            color: #81C784;
            background: #E8F5E9;
            padding: 4px 10px;
            border-radius: 12px;
            display: inline-block;
            margin-bottom: 8px;
        }

        .worldbook-item-preview {
            font-size: 13px;
            color: #66BB6A;
            line-height: 1.4;
            overflow: hidden;
            text-overflow: ellipsis;
            display: -webkit-box;
            -webkit-line-clamp: 2;
            -webkit-box-orient: vertical;
        }

        /* ========== 世界书弹窗样式 - 开始 ========== */

        .worldbook-modal {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.6);
            z-index: 1015;
            display: flex;
            justify-content: center;
            align-items: center;
            padding: 20px;
            opacity: 0;
            visibility: hidden;
            transition: opacity 0.3s ease, visibility 0.3s ease;
            backdrop-filter: blur(5px);
        }

        .worldbook-modal.show {
            opacity: 1;
            visibility: visible;
        }

        .worldbook-modal-card {
            background: #fff;
            border-radius: 20px;
            width: 100%;
            max-width: 340px;
            max-height: 80vh;
            overflow-y: auto;
            box-shadow: 0 15px 40px rgba(0, 0, 0, 0.3);
            transform: scale(0.9);
            transition: transform 0.3s cubic-bezier(0.25, 0.46, 0.45, 0.94);
        }

        .worldbook-modal.show .worldbook-modal-card {
            transform: scale(1);
        }

        .worldbook-modal-header {
            padding: 20px;
            border-bottom: 1px solid #E8F5E9;
            display: flex;
            align-items: center;
            justify-content: space-between;
        }

        .worldbook-modal-title {
            font-size: 18px;
            font-weight: 600;
            color: #2E7D32;
        }

        .worldbook-modal-close {
            width: 32px;
            height: 32px;
            border-radius: 50%;
            background: #F1F8E9;
            border: none;
            color: #4CAF50;
            font-size: 20px;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            transition: all 0.2s;
        }

        .worldbook-modal-close:hover {
            background: #E8F5E9;
            transform: rotate(90deg);
        }

        .worldbook-modal-body {
            padding: 20px;
        }

        .worldbook-form-group {
            margin-bottom: 20px;
        }

        .worldbook-form-label {
            display: block;
            font-size: 13px;
            font-weight: 600;
            color: #388E3C;
            margin-bottom: 8px;
        }

        .worldbook-form-input,
        .worldbook-form-textarea {
            width: 100%;
            padding: 12px;
            border: 2px solid #C8E6C9;
            border-radius: 12px;
            font-size: 14px;
            color: #2E7D32;
            transition: border-color 0.2s;
            font-family: inherit;
        }

        .worldbook-form-input:focus,
        .worldbook-form-textarea:focus {
            outline: none;
            border-color: #4CAF50;
        }

        .worldbook-form-textarea {
            min-height: 100px;
            resize: vertical;
        }

        .worldbook-modal-footer {
            padding: 16px 20px;
            border-top: 1px solid #E8F5E9;
            display: flex;
            gap: 12px;
        }

        .worldbook-btn {
            flex: 1;
            padding: 12px;
            border: none;
            border-radius: 12px;
            font-size: 15px;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.2s;
        }

        .worldbook-btn-cancel {
            background: #F1F8E9;
            color: #689F38;
        }

        .worldbook-btn-cancel:active {
            background: #E8F5E9;
        }

        .worldbook-btn-save {
            background: linear-gradient(135deg, #66BB6A, #43A047);
            color: white;
            box-shadow: 0 4px 12px rgba(76, 175, 80, 0.3);
        }

        .worldbook-btn-save:active {
            transform: scale(0.97);
        }

        .worldbook-btn-delete {
            background: #FFEBEE;
            color: #E53935;
        }

        .worldbook-btn-delete:active {
            background: #FFCDD2;
        }

        /* 分组选择器样式 */
        .worldbook-category-selector {
            position: relative;
            cursor: pointer;
        }

        .category-selected {
            padding: 12px;
            border: 2px solid #C8E6C9;
            border-radius: 12px;
            background: white;
            font-size: 14px;
            color: #2E7D32;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }

        .category-selected::after {
            content: '▼';
            font-size: 12px;
            color: #81C784;
            transition: transform 0.3s;
        }

        .worldbook-category-selector.active .category-selected::after {
            transform: rotate(180deg);
        }

        .category-options {
            position: absolute;
            top: 100%;
            left: 0;
            right: 0;
            background: white;
            border: 2px solid #C8E6C9;
            border-radius: 12px;
            margin-top: 4px;
            overflow: hidden;
            max-height: 0;
            opacity: 0;
            transition: all 0.3s ease;
            z-index: 10;
        }

        .worldbook-category-selector.active .category-options {
            max-height: 200px;
            opacity: 1;
        }

        .category-option {
            padding: 12px;
            font-size: 14px;
            color: #2E7D32;
            cursor: pointer;
            transition: background 0.2s;
        }

        .category-option:hover {
            background: #E8F5E9;
        }

        .category-option.selected {
            background: #C8E6C9;
            font-weight: 600;
        }

        /* 分组管理按钮 */
        .category-manage-btn {
            width: 36px;
            height: 36px;
            border-radius: 12px;
            background: rgba(168, 201, 245, 0.15);
            display: flex;
            align-items: center;
            justify-content: center;
            cursor: pointer;
            font-size: 18px;
            transition: all 0.2s;
            color: #4CAF50;
            font-weight: bold;
            margin-left: 8px;
        }

        .category-manage-btn:active {
            transform: scale(0.9);
            background: rgba(168, 201, 245, 0.25);
        }

        /* ========== 分组管理页面样式 - 开始 ========== */
        /* ========== 分类管理页面样式 ========== */
        .category-manage-page#classificationManagePage {
            z-index: 1006; /* 确保层级比世界书页面高 */
        }

        /* 1. 主页面容器 */
        .category-manage-page {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: linear-gradient(180deg, #FFE8E8 0%, #F5DDD3 100%); /* 粉褐色渐变 */
            transform: translateX(100%);
            transition: transform 0.35s cubic-bezier(0.25, 0.46, 0.45, 0.94);
            z-index: 1005;
            display: flex;
            flex-direction: column;
        }

        .category-manage-page.show {
            transform: translateX(0);
        }

        /* 2. 头部导航 */
        .category-manage-header {
            display: flex;
            align-items: center;
            padding: 45px 20px 20px;
            background: rgba(255, 255, 255, 0.9);
            backdrop-filter: blur(10px);
            box-shadow: 0 2px 8px rgba(161, 136, 127, 0.1);
            flex-shrink: 0;
        }

        .category-manage-title {
            flex: 1;
            text-align: center;
            font-size: 18px;
            font-weight: 600;
            color: #A1887F;
            margin-right: 36px;
        }

        .add-category-btn {
            width: 36px;
            height: 36px;
            border-radius: 12px;
            background: rgba(255, 192, 203, 0.2);
            display: flex;
            align-items: center;
            justify-content: center;
            cursor: pointer;
            font-size: 20px;
            transition: all 0.2s;
            color: #D4A5A5;
            font-weight: bold;
        }

        .add-category-btn:active {
            transform: scale(0.9);
            background: rgba(255, 192, 203, 0.3);
        }

        /* 3. 内容区域 */
        .category-manage-content {
            flex: 1;
            overflow-y: auto;
            padding-top: 12px;
        }

        .category-manage-content::-webkit-scrollbar {
            display: none;
        }

        /* 4. 空状态 */
        .category-empty {
            flex: 1;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            text-align: center;
            color: #D4A5A5;
            padding: 60px 20px;
        }

        .category-empty-icon {
            font-size: 64px;
            margin-bottom: 16px;
        }

        .category-empty-text {
            font-size: 15px;
            line-height: 1.6;
            margin-bottom: 8px;
        }

        .category-empty-hint {
            font-size: 13px;
            color: #E6C4B8;
        }

        /* 5. 分组列表 */
        .category-list {
            display: flex;
            flex-direction: column;
            gap: 12px;
            padding: 0 20px 20px;
        }

        /* 6. 分组项 */
        .category-item {
            background: white;
            border-radius: 16px;
            box-shadow: 0 2px 8px rgba(161, 136, 127, 0.08);
            overflow: hidden;
        }

        .category-item-header {
            display: flex;
            align-items: center;
            padding: 16px;
            cursor: pointer;
            transition: background 0.2s;
        }

        .category-item-header:active {
            background: #FFF5F5;
        }

        .category-item-icon {
            width: 40px;
            height: 40px;
            border-radius: 12px;
            background: linear-gradient(135deg, #FFD1DC, #F5C9C9);
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 20px;
            margin-right: 12px;
            flex-shrink: 0;
        }

        .category-item-info {
            flex: 1;
            min-width: 0;
        }

        .category-item-name {
            font-size: 16px;
            font-weight: 600;
            color: #8D6E63;
            margin-bottom: 4px;
        }

        .category-item-count {
            font-size: 12px;
            color: #BCAAA4;
        }

        .category-item-arrow {
            font-size: 18px;
            color: #D4A5A5;
            transition: transform 0.3s;
        }

        .category-item.expanded .category-item-arrow {
            transform: rotate(90deg);
        }

        /* 7. 世界书条目列表 */
        .category-worldbooks {
            max-height: 0;
            overflow: hidden;
            transition: max-height 0.3s ease;
            background: #FFF8F5;
        }

        .category-item.expanded .category-worldbooks {
            max-height: 500px;
        }

        .worldbook-mini-item {
            padding: 12px 16px;
            border-top: 1px solid #FFE8E8;
            cursor: pointer;
            transition: background 0.2s;
        }

        .worldbook-mini-item:active {
            background: #FFEAEA;
        }

        .worldbook-mini-title {
            font-size: 14px;
            color: #8D6E63;
            margin-bottom: 4px;
        }

        .worldbook-mini-preview {
            font-size: 12px;
            color: #BCAAA4;
            overflow: hidden;
            text-overflow: ellipsis;
            white-space: nowrap;
        }

        /* ========== 新建分组弹窗样式 ========== */

        .category-modal {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.6);
            z-index: 1016;
            display: flex;
            justify-content: center;
            align-items: center;
            padding: 20px;
            opacity: 0;
            visibility: hidden;
            transition: opacity 0.3s ease, visibility 0.3s ease;
            backdrop-filter: blur(5px);
        }

        .category-modal.show {
            opacity: 1;
            visibility: visible;
        }

        .category-modal-card {
            background: #fff;
            border-radius: 20px;
            width: 100%;
            max-width: 340px;
            box-shadow: 0 15px 40px rgba(0, 0, 0, 0.3);
            transform: scale(0.9);
            transition: transform 0.3s cubic-bezier(0.25, 0.46, 0.45, 0.94);
        }

        .category-modal.show .category-modal-card {
            transform: scale(1);
        }

        .category-modal-header {
            padding: 20px;
            border-bottom: 1px solid #FFE8E8;
            display: flex;
            align-items: center;
            justify-content: space-between;
        }

        .category-modal-title {
            font-size: 18px;
            font-weight: 600;
            color: #8D6E63;
        }

        .category-modal-close {
            width: 32px;
            height: 32px;
            border-radius: 50%;
            background: #FFF5F5;
            border: none;
            color: #D4A5A5;
            font-size: 20px;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            transition: all 0.2s;
        }

        .category-modal-close:hover {
            background: #FFE8E8;
            transform: rotate(90deg);
        }

        .category-modal-body {
            padding: 20px;
        }

        .category-form-group {
            margin-bottom: 20px;
        }

        .category-form-label {
            display: block;
            font-size: 13px;
            font-weight: 600;
            color: #A1887F;
            margin-bottom: 8px;
        }

        .category-form-input,
        .category-form-textarea {
            width: 100%;
            padding: 12px;
            border: 2px solid #FFD1DC;
            border-radius: 12px;
            font-size: 14px;
            color: #8D6E63;
            transition: border-color 0.2s;
            font-family: inherit;
        }

        .category-form-input:focus,
        .category-form-textarea:focus {
            outline: none;
            border-color: #FFC0CB;
        }

        .category-form-textarea {
            min-height: 80px;
            resize: vertical;
        }

        .category-modal-footer {
            padding: 16px 20px;
            border-top: 1px solid #FFE8E8;
            display: flex;
            gap: 12px;
        }

        .category-btn {
            flex: 1;
            padding: 12px;
            border: none;
            border-radius: 12px;
            font-size: 15px;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.2s;
        }

        .category-btn-cancel {
            background: #FFF5F5;
            color: #D4A5A5;
        }

        .category-btn-cancel:active {
            background: #FFE8E8;
        }

        .category-btn-save {
            background: linear-gradient(135deg, #FFB6C1, #FFA5B8);
            color: white;
            box-shadow: 0 4px 12px rgba(255, 182, 193, 0.3);
        }

        .category-btn-save:active {
            transform: scale(0.97);
        }

        .category-btn-delete {
            background: #FFEBEE;
            color: #E53935;
        }

        .category-btn-delete:active {
            background: #FFCDD2;
        }

        /* ========== 分组管理样式 - 结束 ========== */
        /* ========== 新增：世界地图功能样式 ========== */
        .world-map-preview-container {
            width: 100%;
            height: 120px;
            border: 2px dashed #B8D9E8;
            border-radius: 12px;
            background-color: rgba(255, 255, 255, 0.7);
            display: flex;
            align-items: center;
            justify-content: center;
            cursor: pointer;
            transition: all 0.2s ease;
            position: relative;
            overflow: hidden;
        }

        .world-map-preview-container:hover {
            border-color: #5FB3D6;
            background-color: rgba(255, 255, 255, 0.9);
        }

        #worldMapPreview {
            width: 100%;
            height: 100%;
            object-fit: cover; /* 图片不变形地填充容器 */
        }

        #worldMapPlaceholder {
            font-size: 14px;
            font-weight: 500;
            color: #7FB5D1;
        }

        .world-map-options {
            display: none; /* 默认隐藏 */
            gap: 10px;
            margin-top: 10px;
            animation: fadeIn 0.3s ease;
        }

        @keyframes fadeIn {
            from {
                opacity: 0;
                transform: translateY(-5px);
            }
            to {
                opacity: 1;
                transform: translateY(0);
            }
        }

        .world-map-btn {
            flex: 1;
            padding: 10px;
            border: 2px solid #B8D9E8;
            border-radius: 10px;
            background: white;
            color: #2C6B8F;
            font-size: 13px;
            font-weight: 600;
            cursor: pointer;
            text-align: center;
            transition: all 0.2s ease;
        }

        .world-map-btn:hover {
            border-color: #5FB3D6;
            background-color: #F0F8FB;
        }


        /* ========== 世界书样式 - 结束 ========== */
        /* ========== 数码像素猫组件样式 - 开始 ========== */

        .cat-widget {
            position: absolute;
            width: 100%;
            height: 100%;
            /* 背景可以根据喜好调整，这里保留了原有的可爱风格 */
            background: linear-gradient(135deg, #FFE5F0 0%, #FFF0F8 100%);
            border-radius: 22px;
            padding: 16px;
            overflow: visible;
            box-shadow: 0 6px 20px rgba(161, 136, 127, 0.15);
            border: 3px solid #FFB6C1;
        }

        /* 像素猫主体容器 */
        /* 用这段全新的代码替换旧的 .pixel-cat-body */
        .pixel-cat-body {
            position: absolute;
            width: 68px;
            height: 72px; /* 稍微增加高度，为动画留出空间 */
            bottom: 40px; /* 重新微调位置 */
            left: 50%;
            transform: translateX(-50%);
            /* 新增：应用动画 */
            animation: catBreathe 2.5s ease-in-out infinite;
        }


        /* 用这段全新的代码替换旧的 .pixel-cat-body::before */
        /* 粘贴这段全新的代码，它包含了新的绘制逻辑和动画定义 */

        /* 使用 ::before 绘制猫咪的轮廓和身体主体 */
        .pixel-cat-body::before {
            content: '';
            position: absolute;
            width: 4px;
            height: 4px;
            /* 这次我们用纯黑色 #222 作为基准颜色来画轮廓 */
            background: #222;

            /* 全新重绘的像素图 */
            box-shadow: /* 耳朵 */ 4px -12px 0 #222, 8px -12px 0 #222, 12px -12px 0 #222,
            32px -12px 0 #222, 36px -12px 0 #222, 40px -12px 0 #222,
            0 -8px 0 #222, 4px -8px 0 #f2c1b1, 8px -8px 0 #f2c1b1, 12px -8px 0 #c6b9b3, 16px -8px 0 #222,
            28px -8px 0 #222, 32px -8px 0 #c6b9b3, 36px -8px 0 #f2c1b1, 40px -8px 0 #f2c1b1, 44px -8px 0 #222,
            -4px -4px 0 #222, 0 -4px 0 #c6b9b3, 4px -4px 0 #c6b9b3, 12px -4px 0 #a1928b, 16px -4px 0 #a1928b, 20px -4px 0 #222,
            24px -4px 0 #222, 28px -4px 0 #a1928b, 32px -4px 0 #a1928b, 40px -4px 0 #c6b9b3, 44px -4px 0 #c6b9b3, 48px -4px 0 #222,
            -4px 0 0 #222, 0 0 #c6b9b3, 4px 0 0 #c6b9b3, 8px 0 0 #f5efed, 12px 0 0 #f5efed, 16px 0 0 #f5efed, 20px 0 0 #f5efed, 24px 0 0 #f5efed, 28px 0 0 #f5efed, 32px 0 0 #f5efed, 36px 0 0 #f5efed, 40px 0 0 #c6b9b3, 44px 0 0 #c6b9b3, 48px 0 0 #222,
                /* 眼睛和脸颊 */ -8px 4px 0 #222, -4px 4px 0 #c6b9b3, 0 4px 0 #f2c1b1, 4px 4px 0 #f5efed, 8px 4px 0 #222, 12px 4px 0 #222, 16px 4px 0 #f5efed, 20px 4px 0 #f5efed, 24px 4px 0 #222, 28px 4px 0 #222, 32px 4px 0 #f5efed, 36px 4px 0 #f2c1b1, 40px 4px 0 #c6b9b3, 44px 4px 0 #222, 48px 4px 0 #222,
            -8px 8px 0 #222, -4px 8px 0 #c6b9b3, 0 8px 0 #c6b9b3, 4px 8px 0 #f5efed, 8px 8px 0 #f5efed, 12px 8px 0 #222, 16px 8px 0 #f5efed, 20px 8px 0 #f5efed, 24px 8px 0 #222, 28px 8px 0 #f5efed, 32px 8px 0 #f5efed, 36px 8px 0 #c6b9b3, 40px 8px 0 #c6b9b3, 44px 8px 0 #222,
            -4px 12px 0 #222, 0 12px 0 #f5efed, 4px 12px 0 #f5efed, 8px 12px 0 #4b3f3a, 12px 12px 0 #4b3f3a, 16px 12px 0 #f5efed, 20px 12px 0 #f5efed, 24px 12px 0 #4b3f3a, 28px 12px 0 #4b3f3a, 32px 12px 0 #f5efed, 36px 12px 0 #f5efed, 40px 12px 0 #222,
            0 16px 0 #222, 4px 16px 0 #f5efed, 8px 16px 0 #f5efed, 12px 16px 0 #f5efed, 16px 16px 0 #f5efed, 20px 16px 0 #f5efed, 24px 16px 0 #f5efed, 28px 16px 0 #f5efed, 32px 16px 0 #f5efed, 36px 16px 0 #222,
            4px 20px 0 #222, 8px 20px 0 #222, 12px 20px 0 #4b3f3a, 16px 20px 0 #e8ded8, 20px 20px 0 #4b3f3a, 24px 20px 0 #e8ded8, 28px 20px 0 #4b3f3a, 32px 20px 0 #222,
                /* 身体 */ 8px 24px 0 #222, 12px 24px 0 #f5efed, 16px 24px 0 #f5efed, 20px 24px 0 #f5efed, 24px 24px 0 #f5efed, 28px 24px 0 #c6b9b3, 32px 24px 0 #222,
            8px 28px 0 #f5efed, 12px 28px 0 #222, 16px 28px 0 #c6b9b3, 20px 28px 0 #f5efed, 24px 28px 0 #f5efed, 28px 28px 0 #222, 32px 28px 0 #a1928b, 36px 28px 0 #222, 40px 28px 0 #c6b9b3, 44px 28px 0 #222,
            4px 32px 0 #a1928b, 8px 32px 0 #f5efed, 12px 32px 0 #f5efed, 16px 32px 0 #f5efed, 20px 32px 0 #f5efed, 24px 32px 0 #e8ded8, 28px 32px 0 #a1928b, 32px 32px 0 #c6b9b3, 36px 32px 0 #a1928b, 40px 32px 0 #222,
            0 36px 0 #222, 4px 36px 0 #4b3f3a, 8px 36px 0 #f5efed, 12px 36px 0 #f5efed, 16px 36px 0 #e8ded8, 20px 36px 0 #f5efed, 24px 36px 0 #222, 28px 36px 0 #4b3f3a, 32px 36px 0 #4b3f3a,
            -4px 40px 0 #222, 0 40px 0 #a1928b, 4px 40px 0 #f5efed, 8px 40px 0 #222, 12px 40px 0 #f5efed, 16px 40px 0 #f5efed, 20px 40px 0 #222, 28px 40px 0 #222,
            -4px 44px 0 #222, 0 44px 0 #a1928b, 4px 44px 0 #f5efed, 8px 44px 0 #222, 12px 44px 0 #f5efed, 16px 44px 0 #f5efed, 20px 44px 0 #222,
            -4px 48px 0 #222, 0 48px 0 #222, 4px 48px 0 #222, 8px 48px 0 #222, 12px 48px 0 #222, 16px 48px 0 #222, 20px 48px 0 #222;

        }

        /* 使用 ::after 绘制尾巴和眼睛高光 */
        .pixel-cat-body::after {
            content: '';
            position: absolute;
            width: 4px;
            height: 4px;
            background: white; /* 基准点是眼睛高光 */
            top: 8px; /* 调整高光的垂直位置 */
            left: 12px;

            box-shadow: /* 另一只眼睛的高光 */ 16px 0 0 white,
                /* 尾巴 */ -20px 24px 0 #222, -16px 24px 0 #a1928b, -12px 24px 0 #a1928b, -8px 24px 0 #222,
            -24px 28px 0 #222, -20px 28px 0 #a1928b, -16px 28px 0 #8d7e78, -12px 28px 0 #a1928b, -8px 28px 0 #222,
            -24px 32px 0 #222, -20px 32px 0 #8d7e78, -16px 32px 0 #a1928b, -12px 32px 0 #222,
            -24px 36px 0 #222, -20px 36px 0 #222, -16px 36px 0 #222;
        }

        /* 定义呼吸动画 */
        @keyframes catBreathe {
            0%, 100% {
                transform: translateX(-50%) translateY(0);
            }
            50% {
                transform: translateX(-50%) translateY(-2px); /* 向上轻微移动2像素 */
            }
        }


        /* 状态数据条容器 */
        .cat-stats-container {
            position: absolute;
            top: 12px;
            left: 12px;
            right: 12px;
            background: rgba(255, 255, 255, 0.9);
            padding: 10px 12px;
            border-radius: 12px;
            box-shadow: 0 2px 8px rgba(0, 0, 0, 0.08);
        }

        /* 单个状态条 */
        .cat-stat-item {
            margin-bottom: 8px;
            cursor: pointer;
            transition: transform 0.2s;
        }

        .cat-stat-item:hover {
            transform: scale(1.02);
        }

        .cat-stat-item:last-child {
            margin-bottom: 0;
        }

        /* 状态标签 */
        .cat-stat-label {
            display: flex;
            justify-content: space-between;
            align-items: center;
            font-size: 11px;
            font-weight: 600;
            color: #8D6E63;
            margin-bottom: 4px;
        }

        .cat-stat-value {
            font-size: 10px;
            color: #A1887F;
        }

        /* 状态条背景 */
        .cat-stat-bar-bg {
            height: 8px;
            background: #F5F5F5;
            border-radius: 10px;
            overflow: hidden;
            box-shadow: inset 0 1px 3px rgba(0, 0, 0, 0.1);
        }

        /* 状态条填充 */
        .cat-stat-bar-fill {
            height: 100%;
            background: linear-gradient(90deg, #FFB6C1, #FF9AAD);
            border-radius: 10px;
            transition: width 0.3s ease;
            position: relative;
        }

        /* 不同状态的颜色 */
        .cat-stat-item[data-stat="happiness"] .cat-stat-bar-fill {
            background: linear-gradient(90deg, #FFD700, #FFA500);
        }

        .cat-stat-item[data-stat="hunger"] .cat-stat-bar-fill {
            background: linear-gradient(90deg, #90EE90, #32CD32);
        }

        .cat-stat-item[data-stat="energy"] .cat-stat-bar-fill {
            background: linear-gradient(90deg, #87CEEB, #4682B4);
        }

        .cat-stat-item[data-stat="cleanliness"] .cat-stat-bar-fill {
            background: linear-gradient(90deg, #DDA0DD, #BA55D3);
        }

        /* 状态条上的闪光效果 */
        .cat-stat-bar-fill::after {
            content: '';
            position: absolute;
            top: 0;
            left: -100%;
            width: 50%;
            height: 100%;
            background: linear-gradient(90deg, transparent, rgba(255, 255, 255, 0.6), transparent);
            animation: shimmer 2s infinite;
        }

        @keyframes shimmer {
            0% {
                left: -100%;
            }
            100% {
                left: 200%;
            }
        }

        /* 猫咪对话气泡 */
        .cat-speech-bubble {
            position: absolute;
            bottom: 10px;
            left: 50%;
            transform: translateX(-50%);
            max-width: 75%;
            background: white;
            padding: 10px 14px;
            border-radius: 16px;
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.1);
            font-size: 13px;
            color: #8D6E63;
            line-height: 1.4;
            cursor: pointer;
            transition: all 0.2s;
            text-align: center;
            border: 2px solid #FFB6C1;
        }

        .cat-speech-bubble:hover {
            background: #FFF5F5;
            transform: translateX(-50%) scale(1.03);
        }

        /* 气泡小尾巴 */
        .cat-speech-bubble::before {
            content: '';
            position: absolute;
            top: -8px;
            left: 50%;
            transform: translateX(-50%);
            width: 0;
            height: 0;
            border-left: 8px solid transparent;
            border-right: 8px solid transparent;
            border-bottom: 8px solid #FFB6C1;
        }

        .cat-speech-bubble::after {
            content: '';
            position: absolute;
            top: -5px;
            left: 50%;
            transform: translateX(-50%);
            width: 0;
            height: 0;
            border-left: 6px solid transparent;
            border-right: 6px solid transparent;
            border-bottom: 6px solid white;
        }

        /* 删除按钮 */
        .cat-widget .delete-widget-btn {
            display: none;
            position: absolute;
            top: 8px;
            right: 8px;
            width: 24px;
            height: 24px;
            background: rgba(255, 71, 87, 0.9);
            border-radius: 50%;
            color: white;
            font-size: 16px;
            font-weight: bold;
            cursor: pointer;
            z-index: 250;
            align-items: center;
            justify-content: center;
        }

        .cat-widget.show-delete .delete-widget-btn {
            display: flex;
        }

        /* ========== 数码像素猫组件样式 - 结束 ========== */

    </style>
</head>
<body>
<div class="phone">
    <div class="success-modal" id="successModal">
        <div class="modal-content">
            <h3 id="successModalTitle">操作成功</h3>
            <p id="successModalMessage">你的设置已保存。</p>
        </div>
    </div>
    <div class="screen" id="screen">
        <div class="avatar-action-sheet" id="locationActionSheet">
            <div class="action-sheet-backdrop" onclick="closeLocationChooser()"></div>
            <div class="action-sheet-options">
                <div class="action-option" onclick="selectRealLocation()">📍 获取真实地址</div>
                <div class="action-option" onclick="selectVirtualLocation()">✏️ 填写虚拟地址</div>
            </div>
            <div class="action-sheet-options" style="margin-top: 0;">
                <div class="action-option cancel" onclick="closeLocationChooser()">取消</div>
            </div>
        </div>
        <div class="pages-wrapper" id="pagesWrapper">
            <div class="page" id="page1">
                <div class="status-bar">
                    <span>19:05</span>
                    <div class="status-icons">
                        <svg class="status-icon-svg" viewBox="0 0 24 24">
                            <path fill-rule="evenodd"
                                  d="M12 4.5C7.31 4.5 3.19 6.84 1.33 10.33l1.83.92C4.69 8.23 8.01 6.5 12 6.5s7.31 1.73 8.84 4.75l1.83-.92C20.81 6.84 16.69 4.5 12 4.5zM12 9.5c-3.31 0-6.13 1.5-7.58 3.82l1.83.91C7.43 12.19 9.53 11.5 12 11.5s4.57.69 5.75 2.73l1.83-.91C18.13 11 15.31 9.5 12 9.5zM12 14.5a2.5 2.5 0 100 5 2.5 2.5 0 000-5z"></path>
                        </svg>
                        <div class="battery-container">
                            <div class="battery-icon">
                                <svg viewBox="0 0 26 14" fill="none">
                                    <path d="M24 4.33333V9.66667C25.1046 9.66667 26 8.77123 26 7.66667C26 6.5621 25.1046 5.66667 24 5.66667V4.33333Z"
                                          fill="currentColor"></path>
                                    <path d="M1 4.66667C1 3.19391 2.19391 2 3.66667 2H20.3333C21.8061 2 23 3.19391 23 4.66667V9.33333C23 10.8061 21.8061 12 20.3333 12H3.66667C2.19391 12 1 10.8061 1 9.33333V4.66667Z"
                                          stroke="currentColor" stroke-width="2"></path>
                                </svg>
                                <div class="battery-level"></div>
                                <svg class="charging-bolt" viewBox="0 0 24 24">
                                    <path d="M11 21v-8H7l5-10v8h4l-5 10z"></path>
                                </svg>
                            </div>
                            <span class="battery-text">100%</span>
                        </div>
                    </div>
                </div>

                <div class="time-weather-section">
                    <div class="time-card" id="timeCard">
                        <!-- 背景层保持不变 -->
                        <div class="card-background-wrapper">
                            <div class="top-gingham-bg"></div>
                            <div class="bottom-stripes-bg"></div>
                            <div class="drip-divider"></div>
                        </div>
                        <div class="delete-time-btn" onclick="deleteTimeCard()">×</div>

                        <!-- === 最终版时间内容容器 开始 === -->
                        <!-- 新增一个.whiskers-bg层，用于放置胡须和新的棕色背景 -->
                        <div class="whiskers-bg">
                            <div class="final-time-container">
                                <h2 id="finalMainTime">19:05</h2>
                                <div id="finalMainDate" class="day">TUESDAY, MAR 21</div>
                            </div>
                        </div>
                        <!-- === 最终版时间内容容器 结束 === -->
                    </div>

                    <div class="weather-card" id="weatherCard">
                        <!-- 新增：背景包裹层 -->
                        <div class="card-background-wrapper">
                            <div class="top-gingham-bg"></div>      <!-- 用于上半部分的格子背景 -->
                            <div class="bottom-stripes-bg"></div> <!-- 用于下半部分的条纹背景 -->
                            <div class="drip-divider"></div>      <!-- 用于中间的波浪分割线 -->
                        </div>

                        <div class="delete-weather-btn" onclick="deleteWeatherCard()">×</div>

                        <!-- 原有内容保持不变，它们会显示在新背景之上 -->
                        <div class="top-row">
                            <div class="location-display" onclick="openLocationChooser()">
                                <span class="location-icon">📍</span>
                                <span class="location-text" id="locationText">越秀区</span>
                            </div>
                            <div class="weather-display" onclick="toggleWeatherSelector(event)">
                                <span class="current-weather-icon" id="currentWeatherIcon">☀️</span>
                            </div>
                        </div>

                        <div class="mood-section" onclick="editMood(event)">
                            <div class="mood-label">今日心情</div>
                            <div class="mood-text" id="moodText">心情怎样呢？</div> <!-- 我把心情改成了“坏”以匹配你的截图 -->
                        </div>

                        <div class="weather-popup" id="weatherPopup" style="display: none;">
                            <div class="weather-popup-title">选择天气</div>
                            <div class="weather-options">
                                    <span class="weather-option active" data-weather="sunny"
                                          onclick="selectWeather('sunny', event)">☀️</span>
                                <span class="weather-option" data-weather="cloudy"
                                      onclick="selectWeather('cloudy', event)">☁️</span>
                                <span class="weather-option" data-weather="rainy"
                                      onclick="selectWeather('rainy', event)">🌧️</span>
                                <span class="weather-option" data-weather="snowy"
                                      onclick="selectWeather('snowy', event)">❄️</span>
                            </div>
                        </div>
                    </div>
                </div>
                <div class="avatar-action-sheet" id="avatarActionSheet">
                    <div class="action-sheet-backdrop" onclick="closeAvatarActions()"></div>
                    <div class="action-sheet-options">
                        <div class="action-option" onclick="promptForUrl()">从 URL 填写</div>
                        <div class="action-option" onclick="triggerFileUpload()">从文件选择</div>
                    </div>
                    <div class="action-sheet-options" style="margin-top: 0;">
                        <div class="action-option cancel" onclick="closeAvatarActions()">取消</div>
                    </div>
                </div>

                <div class="grid-container" id="grid1"></div>
            </div>

            <div class="page" id="page2">
                <div class="status-bar">
                    <span>19:05</span>
                    <div class="status-icons">
                        <svg class="status-icon-svg" viewBox="0 0 24 24">
                            <path fill-rule="evenodd"
                                  d="M12 4.5C7.31 4.5 3.19 6.84 1.33 10.33l1.83.92C4.69 8.23 8.01 6.5 12 6.5s7.31 1.73 8.84 4.75l1.83-.92C20.81 6.84 16.69 4.5 12 4.5zM12 9.5c-3.31 0-6.13 1.5-7.58 3.82l1.83.91C7.43 12.19 9.53 11.5 12 11.5s4.57.69 5.75 2.73l1.83-.91C18.13 11 15.31 9.5 12 9.5zM12 14.5a2.5 2.5 0 100 5 2.5 2.5 0 000-5z"></path>
                        </svg>
                        <div class="battery-container">
                            <div class="battery-icon">
                                <svg viewBox="0 0 26 14" fill="none">
                                    <path d="M24 4.33333V9.66667C25.1046 9.66667 26 8.77123 26 7.66667C26 6.5621 25.1046 5.66667 24 5.66667V4.33333Z"
                                          fill="currentColor"></path>
                                    <path d="M1 4.66667C1 3.19391 2.19391 2 3.66667 2H20.3333C21.8061 2 23 3.19391 23 4.66667V9.33333C23 10.8061 21.8061 12 20.3333 12H3.66667C2.19391 12 1 10.8061 1 9.33333V4.66667Z"
                                          stroke="currentColor" stroke-width="2"></path>
                                </svg>
                                <div class="battery-level"></div>
                                <svg class="charging-bolt" viewBox="0 0 24 24">
                                    <path d="M11 21v-8H7l5-10v8h4l-5 10z"></path>
                                </svg>
                            </div>
                            <span class="battery-text">100%</span>
                        </div>
                    </div>
                </div>

                <div class="grid-container" id="grid2"></div>
            </div>
        </div>

        <div class="edit-hint" id="editHint1">长按图标可以拖动调整位置</div>
        <div class="edit-hint" id="editHint2">长按图标可以拖动调整位置</div>

        <div class="page-dots">
            <div class="dot active" onclick="showPage(1)"></div>
            <div class="dot" onclick="showPage(2)"></div>
        </div>

        <div class="dock">
            <!-- 图标将由JavaScript动态生成到这里 -->
        </div>

        <div class="settings-page" id="settingsPage">
            <div class="settings-header">
                <div class="back-btn" onclick="closeSettings()">←</div>
                <div class="settings-title">设置</div>
            </div>

            <div class="settings-content">
                <div class="settings-section">
                    <div class="section-title">配置</div>
                    <div class="settings-item" onclick="openApiConfig()">
                        <div class="settings-icon" style="background: linear-gradient(135deg, #f093fb, #f5576c);">🔌
                        </div>
                        <div class="settings-info">
                            <div class="settings-label">API设置</div>
                            <div class="settings-desc">管理API配置和模型</div>
                        </div>
                        <div class="settings-arrow">›</div>
                    </div>
                    <div class="settings-item" onclick="openConfig('database')">
                        <div class="settings-icon" style="background: linear-gradient(135deg, #667eea, #764ba2);">🗄️
                        </div>
                        <div class="settings-info">
                            <div class="settings-label">数据库设置</div>
                            <div class="settings-desc">配置Supabase数据库</div>
                        </div>
                        <div class="settings-arrow">›</div>
                    </div>
                    <div class="settings-item">
                        <div class="settings-icon" style="background: linear-gradient(135deg, #89f7fe, #66a6ff);">📱
                        </div>
                        <div class="settings-info">
                            <div class="settings-label">全屏模式</div>
                            <div class="settings-desc">移除手机边框，享受沉浸式体验</div>
                        </div>
                        <div class="settings-action">
                            <label class="toggle-switch">
                                <input type="checkbox" id="fullscreenToggle">
                                <span class="slider"></span>
                            </label>
                        </div>
                    </div>
                    <div class="settings-item" onclick="openConfig('storage')">
                        <div class="settings-icon" style="background: linear-gradient(135deg, #4facfe, #00f2fe);">☁️
                        </div>
                        <div class="settings-info">
                            <div class="settings-label">云存储设置</div>
                            <div class="settings-desc">配置Supabase Storage</div>
                        </div>
                        <div class="settings-arrow">›</div>
                    </div>
                    <div class="settings-item" onclick="openBeautify()">
                        <div class="settings-icon" style="background: linear-gradient(135deg, #ff9a9e, #fecfef);">🎨
                        </div>
                        <div class="settings-info">
                            <div class="settings-label">美化</div>
                            <div class="settings-desc">自定义应用图标</div>
                        </div>
                        <div class="settings-arrow">›</div>
                    </div>
                    <div class="settings-item" onclick="openWidgetManager()">
                        <div class="settings-icon" style="background: linear-gradient(135deg, #43e97b, #38f9d7);">📦
                        </div>
                        <div class="settings-info">
                            <div class="settings-label">组件</div>
                            <div class="settings-desc">自定义桌面组件</div>
                        </div>
                        <div class="settings-arrow">›</div>
                    </div>
                    <div class="settings-item">
                        <div class="settings-icon" style="background: linear-gradient(135deg, #ff9a9e, #fecfef);">🐾
                        </div>
                        <div class="settings-info">
                            <div class="settings-label">悬浮球</div>
                            <div class="settings-desc">在主屏幕显示一个快捷操作悬浮球</div>
                        </div>
                        <div class="settings-action">
                            <label class="toggle-switch">
                                <input type="checkbox" id="floatingBallToggle">
                                <span class="slider"></span>
                            </label>
                        </div>
                    </div>
                    <div class="settings-section">
                        <div class="section-title">危险区域</div>
                        <div class="settings-item" onclick="clearAllData()">
                            <div class="settings-icon" style="background: linear-gradient(135deg, #ff6b6b, #ff8e8e);">
                                🗑️
                            </div>
                            <div class="settings-info">
                                <div class="settings-label" style="color: #ff3b30;">清空所有数据</div>
                                <div class="settings-desc">将删除所有设置、联系人、聊天记录和自定义内容</div>
                            </div>
                            <div class="settings-arrow">›</div>
                        </div>
                    </div>
                </div>
            </div>
        </div>

        <div class="config-page" id="apiConfig">
            <div class="settings-header">
                <div class="back-btn" onclick="closeApiConfig()">←</div>
                <div class="settings-title">API配置</div>
            </div>
            <div class="settings-content">
                <div class="section-title">已保存的配置</div>
                <div class="api-config-list" id="apiConfigList"></div>

                <div class="settings-section">
                    <div class="form-group">
                        <label class="form-label">配置名称</label>
                        <input type="text" class="form-input" id="configName" placeholder="例如: OpenAI GPT-4">
                    </div>
                    <div class="form-group">
                        <label class="form-label">API URL</label>
                        <input type="text" class="form-input" id="apiUrl" placeholder="https://api.openai.com/v1">
                    </div>
                    <div class="form-group">
                        <label class="form-label">API Key</label>
                        <input type="password" class="form-input" id="apiKey" placeholder="sk-...">
                    </div>
                    <div class="form-group">
                        <label class="form-label">选择模型</label>
                        <select class="form-select" id="modelSelect">
                            <option value="">请先拉取模型列表</option>
                        </select>
                    </div>
                </div>
                <div class="btn-group">
                    <button class="test-btn" onclick="testConnection()">测试连接</button>
                    <button class="fetch-btn" onclick="fetchModels()">拉取模型</button>
                </div>
                <div class="btn-group">
                    <button class="save-btn" onclick="saveApiConfig()">保存配置</button>
                </div>
                <div id="apiStatus" style="margin: 0 20px; font-size: 12px; color: #28a745; font-weight: 600;"></div>
            </div>
        </div>

        <div class="config-page" id="databaseConfig">
            <div class="settings-header">
                <div class="back-btn" onclick="closeConfig('database')">←</div>
                <div class="settings-title">数据库设置</div>
            </div>
            <div class="settings-content">
                <div class="settings-section">
                    <div class="form-group">
                        <label class="form-label">Supabase URL</label>
                        <input type="text" class="form-input" id="supabaseUrl" placeholder="https://xxxxx.supabase.co">
                    </div>
                    <div class="form-group">
                        <label class="form-label">Supabase Anon Key</label>
                        <input type="password" class="form-input" id="supabaseKey" placeholder="输入你的匿名密钥">
                    </div>
                    <div class="form-group">
                        <label class="form-label">表名称</label>
                        <input type="text" class="form-input" id="tableName" placeholder="例如: user_data"
                               value="user_data">
                    </div>
                </div>
                <button class="save-btn" onclick="saveConfig('database')" style="margin: 20px;">保存并初始化</button>
                <div id="dbStatus" style="margin: 0 20px; font-size: 12px; color: #28a745; font-weight: 600;"></div>
            </div>
        </div>

        <div class="config-page" id="storageConfig">
            <div class="settings-header">
                <div class="back-btn" onclick="closeConfig('storage')">←</div>
                <div class="settings-title">云存储设置</div>
            </div>
            <div class="settings-content">
                <div class="settings-section">
                    <div class="form-group">
                        <label class="form-label">Storage Bucket名称</label>
                        <input type="text" class="form-input" id="bucketName" placeholder="例如: icons" value="icons">
                    </div>
                    <div class="form-group">
                        <label class="form-label">文件上传路径</label>
                        <input type="text" class="form-input" id="uploadPath" placeholder="例如: app-icons/"
                               value="app-icons/">
                    </div>
                    <div class="form-group">
                        <label class="form-label">最大文件大小 (MB)</label>
                        <input type="number" class="form-input" id="maxFileSize" placeholder="5" value="5">
                    </div>
                </div>
                <button class="save-btn" onclick="saveConfig('storage')" style="margin: 20px;">保存配置</button>
                <div id="storageStatus"
                     style="margin: 0 20px; font-size: 12px; color: #28a745; font-weight: 600;"></div>
            </div>
        </div>

        <div class="beautify-page" id="beautifyPage">
            <div class="settings-header">
                <div class="back-btn" onclick="closeBeautify()">←</div>
                <div class="settings-title">美化</div>
            </div>
            <div class="settings-content">

                <div class="settings-section">
                    <div class="section-title">更换壁纸</div>
                    <div class="wallpaper-grid" id="wallpaperGrid">
                    </div>
                </div>
                <div class="settings-section" style="padding: 0 12px; margin-top: -8px;">
                    <div class="app-preview-item">
                        <div class="preview-header">
                            <div class="preview-icon">🖼️</div>
                            <div class="preview-name">自定义壁纸</div>
                        </div>
                        <div class="upload-section">
                            <label class="upload-btn">
                                📁 上传文件
                                <input type="file" class="file-input" accept="image/*"
                                       onchange="handleWallpaperUpload(event)">
                            </label>
                            <div class="url-input-btn" onclick="toggleWallpaperUrlInput()">🔗 URL填写</div>
                        </div>
                        <div class="url-input-box" id="wallpaper-url-box">
                            <input type="text" class="url-input-field" id="wallpaper-url-input"
                                   placeholder="输入图片URL">
                            <button class="confirm-btn" onclick="applyWallpaperFromUrl()">确认</button>
                        </div>
                        <div class="status-message" id="wallpaper-status"></div>
                    </div>
                </div>
                <div class="app-preview-list" id="appPreviewList">
                </div>
            </div>
        </div>
        <div class="config-page" id="widgetManager">
            <div class="settings-header">
                <div class="back-btn" onclick="closeWidgetManager()">←</div>
                <div class="settings-title">组件管理</div>
            </div>

            <div class="settings-content">
                <div class="section-title">自定义组件代码</div>

                <div style="padding: 0 20px;">
                    <div style="background: white; border-radius: 12px; padding: 16px; margin-bottom: 16px;">
                        <div style="font-size: 13px; color: #666; margin-bottom: 8px; font-weight: 600;">
                            组件HTML代码
                        </div>
                        <textarea id="widgetCodeInput"
                                  style="width: 100%; min-height: 200px; padding: 12px; border: 2px solid #e0e0e0; border-radius: 8px; font-family: 'Courier New', monospace; font-size: 12px; resize: vertical;"
                                  placeholder="示例代码：<div class='widget-scene'>
                            <div style='position: absolute; bottom: 20px; right: 30px; font-size: 60px;'>🌺</div>
                            </div>

                            可用CSS选择器：
                            .widget - 组件容器
                            .widget-time - 顶部文字
                            .widget-scene - 场景区域
                            支持常见CSS样式"></textarea>
                    </div>
                    <button class="save-btn" onclick="applyCustomWidget()"
                            style="width: 100%; margin-bottom: 16px;">应用组件
                    </button>
                </div>
            </div>
            <div class="section-title">已有组件</div>
            <div id="savedWidgetsList" style="padding: 0 20px;"></div>
        </div>

        <!-- ========== 新增：文件夹浮层 ========== -->
        <div class="folder-overlay" id="folderOverlay" onclick="closeFolder()">
            <div class="folder-modal" onclick="event.stopPropagation()">
                <div class="folder-header">
                    <h3 id="folderName">文件夹名称</h3>
                    <input type="text" id="folderNameInput" style="display: none;">
                </div>
                <div class="folder-grid-container" id="folderContentGrid">
                    <!-- 文件夹内的图标将由JS动态生成到这里 -->
                </div>
            </div>
        </div>
        <div class="contacts-page" id="contactsPage">
            <div class="contacts-header">
                <div class="back-btn" onclick="closeContacts()">←</div>
                <input type="text" class="contacts-search" id="contactsSearch" placeholder="搜索联系人..."
                       oninput="filterContacts()">
                <div class="add-contact-btn" onclick="toggleContactMenu(event)">+</div>

                <div class="contact-menu" id="contactMenu">
                    <div class="contact-menu-item" onclick="createNewContact()">新建联系人</div>
                    <div class="contact-menu-item" onclick="selectExistingContact()">选择已有联系人</div>
                </div>
            </div>
            <div class="contacts-list" id="contactsList"></div>
        </div>
        <div class="modal-overlay" id="characterCardModal">
            <div class="character-card-modal">
                <div class="character-card-content">
                    <!-- ========= 对方（联系人）信息区 ========= -->
                    <div class="top-info-section">
                        <!-- 左侧：头像 -->
                        <div class="character-avatar" onclick="openAvatarActions('contact')">
                            <img id="avatar-preview" src="" alt="角色头像">
                        </div>

                        <!-- 右侧：核心信息 -->
                        <div class="core-details">
                            <input type="text" id="char-name" placeholder="角色姓名">
                            <div class="character-gender-selection">
                                <label><input type="radio" name="char-gender" value="male" checked> 男</label>
                                <label><input type="radio" name="char-gender" value="female"> 女</label>
                                <label><input type="radio" name="char-gender" value="other"> 其他</label>
                            </div>
                        </div>
                    </div>
                    <div class="persona-section">
                        <textarea id="char-persona" placeholder="在此处填写角色的背景故事..."></textarea>
                    </div>
                    <div class="character-worldbook-section">
                        <div class="char-wb-toggle" onclick="toggleCharacterWorldbooks()">
                            <div class="char-wb-toggle-label">📚 绑定的世界书</div>
                            <span class="char-wb-toggle-arrow" id="char-wb-arrow">▼</span>
                        </div>
                        <div class="char-wb-list" id="charWorldbooksList" style="display: none;">
                            <!-- 世界书复选框将由JS动态生成到这里 -->
                        </div>
                    </div>
                    <div class="card-divider">
                        <span class="divider-text">我的信息</span>
                    </div>
                    <!-- ========= 我（用户）信息区 ========= -->
                    <div class="top-info-section">
                        <div class="character-avatar" onclick="openAvatarActions('user')">
                            <img id="user-avatar-preview" src="" alt="我的头像">
                        </div>
                        <div class="core-details">
                            <input type="text" id="user-name" placeholder="我的昵称">
                        </div>
                    </div>
                    <div class="persona-section">
                        <!-- 新增：用户的设定输入框 -->
                        <textarea id="user-persona"
                                  placeholder="在此处填写“我的设定”，将作为系统提示词..."></textarea>
                    </div>

                    <!-- 隐藏的文件上传输入框（保持不变） -->
                    <input type="file" id="avatar-input" accept="image/*" style="display: none;">
                </div>

                <div class="character-card-footer">
                    <button class="character-card-btn cancel" onclick="closeCharacterCardPage()">取消</button>
                    <button class="character-card-btn save" onclick="saveAllCharacterData()">保存</button>
                </div>
            </div>
        </div>
        <!-- ========== 新增：密友专用角色卡弹窗 ========== -->
        <div class="modal-overlay" id="sweetheartCardModal">
            <div class="sweetheart-card-modal">
                <!-- 顶部装饰条 -->
                <div class="sweetheart-card-header">
                    <span class="header-deco">🌸</span>
                    <span class="header-title">添加密友</span>
                    <span class="header-deco">🌸</span>
                </div>

                <div class="sweetheart-card-content">
                    <!-- 头像区域 -->
                    <div class="sweetheart-avatar-section">
                        <div class="sweetheart-avatar" onclick="openSweetheartAvatarPicker()">
                            <img id="sweetheart-avatar-preview" src="" alt="头像">
                            <div class="avatar-overlay">
                                <span>📷</span>
                            </div>
                        </div>
                    </div>
                    <!-- 姓名（必填） -->
                    <div class="sweetheart-field required-field">
                        <label class="sweetheart-label">
                            <span class="label-icon">💕</span>
                            <span class="label-text">姓名</span>
                            <span class="required-star">*</span>
                        </label>
                        <input type="text" id="sweetheart-name" class="sweetheart-input" placeholder="TA叫什么呢...">
                    </div>
                    <!-- 基础设定（必填） -->
                    <div class="sweetheart-field required-field">
                        <label class="sweetheart-label">
                            <span class="label-icon">📝</span>
                            <span class="label-text">基础设定</span>
                            <span class="required-star">*</span>
                        </label>
                        <textarea id="sweetheart-persona" class="sweetheart-textarea" placeholder="描述TA的基本特点..."
                                  rows="3"></textarea>
                    </div>
                    <!-- 性格（可选） -->
                    <div class="sweetheart-field">
                        <label class="sweetheart-label">
                            <span class="label-icon">✨</span>
                            <span class="label-text">性格</span>
                        </label>
                        <input type="text" id="sweetheart-personality" class="sweetheart-input"
                               placeholder="温柔、活泼、冷静...">
                    </div>
                    <!-- 职业（可选） -->
                    <div class="sweetheart-field">
                        <label class="sweetheart-label">
                            <span class="label-icon">💼</span>
                            <span class="label-text">职业</span>
                        </label>
                        <input type="text" id="sweetheart-occupation" class="sweetheart-input"
                               placeholder="学生、教师、医生...">
                    </div>
                    <!-- 口头禅（可选） -->
                    <div class="sweetheart-field">
                        <label class="sweetheart-label">
                            <span class="label-icon">💬</span>
                            <span class="label-text">口头禅</span>
                        </label>
                        <input type="text" id="sweetheart-catchphrase" class="sweetheart-input"
                               placeholder="TA常说的话...">
                    </div>
                    <!-- 过去的经历（可选） -->
                    <div class="sweetheart-field">
                        <label class="sweetheart-label">
                            <span class="label-icon">📖</span>
                            <span class="label-text">过去的经历</span>
                        </label>
                        <textarea id="sweetheart-history" class="sweetheart-textarea" placeholder="TA的过往故事..."
                                  rows="3"></textarea>
                    </div>
                    <!-- 与用户的关系（可选） -->
                    <div class="sweetheart-field">
                        <label class="sweetheart-label">
                            <span class="label-icon">💗</span>
                            <span class="label-text">与我的关系</span>
                        </label>
                        <input type="text" id="sweetheart-relationship" class="sweetheart-input"
                               placeholder="朋友、同事、恋人...">
                    </div>
                    <!-- 绑定世界书（可折叠） -->
                    <div class="sweetheart-field">
                        <div class="sweetheart-label-toggle" onclick="toggleSweetheartWorldbooks()">
                            <div class="sweetheart-label">
                                <span class="label-icon">📚</span>
                                <span class="label-text">绑定的世界书</span>
                            </div>
                            <span class="toggle-arrow" id="sweetheart-wb-arrow">▼</span>
                        </div>
                        <div class="sweetheart-worldbooks-list" id="sweetheartWorldbooksList" style="display: none;">
                            <!-- JS动态生成 -->
                        </div>
                    </div>
                </div>
                <!-- 底部按钮 -->
                <div class="sweetheart-card-footer">
                    <button class="sweetheart-btn btn-cancel" onclick="closeSweetheartCardModal()">
                        <span>取消</span>
                    </button>
                    <button class="sweetheart-btn btn-save" onclick="saveSweetheartCardData()">
                        <span>💖 保存</span>
                    </button>
                </div>
                <!-- 隐藏的文件上传 -->
                <input type="file" id="sweetheart-avatar-input" accept="image/*" style="display: none;">
            </div>
        </div>

        <div class="chat-page" id="chatPage">
            <div class="chat-header">
                <div class="back-btn" onclick="closeChat()">←</div>
                <h2 class="chat-title" id="chatContactName"></h2> <!-- 将 div 改为 h2 更符合语义 -->

                <!-- 新增一个容器来包裹右侧的所有按钮 -->
                <div class="header-actions">
                    <div class="edit-contact-btn" onclick="editCurrentContact()">编辑</div>
                    <!-- 这就是我们新增的设置按钮 -->
                    <div class="chat-settings-btn" id="chatSettingsBtn" onclick="openChatSettings()">⚙️</div>
                </div>
            </div>
            <div class="chat-messages" id="chatMessages">
            </div>
            <div class="chat-input-area">
                <!-- 引用预览框现在是唯一的顶部元素 -->
                <div class="quote-preview" id="quotePreview">
                    <div class="quote-content">
                        <strong class="quote-sender" id="quotePreviewSender"></strong>
                        <span class="quote-text" id="quotePreviewText"></span>
                    </div>
                    <button class="quote-close-btn" onclick="cancelQuote()">&times;</button>
                </div>
                <!-- 新增一个包裹容器，用于水平排列输入框和按钮 -->
                <div class="chat-input-main-row">
                    <button class="chat-action-btn" id="showAttachmentMenuBtn">
                        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="currentColor">
                            <path d="M11 11V5h2v6h6v2h-6v6h-2v-6H5v-2h6Z"></path>
                        </svg>
                    </button>
                    <!-- 附件菜单和隐藏的input保持不变 -->
                    <div class="attachment-menu" id="attachmentMenu">
                        <div class="attachment-item" id="uploadFileBtn">
                            <div class="attachment-icon">📁</div>
                            <div class="attachment-label">文件</div>
                        </div>
                        <div class="attachment-item" id="uploadImageBtn">
                            <div class="attachment-icon">🖼️</div>
                            <div class="attachment-label">图片</div>
                        </div>
                    </div>
                    <input type="file" id="fileInput" style="display: none;">
                    <input type="file" id="imageInput" accept="image/*" style="display: none;">
                    <!-- 输入框 -->
                    <input type="text" id="chatInput" placeholder="输入消息...">

                    <!-- 发送键 -->
                    <button class="chat-action-btn primary" id="sendMsgBtn" onclick="addMessageToList()">
                        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="currentColor">
                            <path d="M1.946 9.315c-.522-.174-.527-.455.01-.634l19.087-6.362c.529-.176.832.12.684.638l-5.454 19.086c-.15.529-.455.547-.679.045L12 14l6-8-8 6-8.054-2.685Z"></path>
                        </svg>
                    </button>
                    <!-- 回复键 -->
                    <button class="chat-action-btn" id="getReplyBtn" onclick="getAiReply()">
                        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="currentColor">
                            <path d="M22 6c0-1.1-.9-2-2-2H4c-1.1 0-2 .9-2 2v12c0 1.1.9 2 2 2h16c1.1 0 2-.9 2-2V6zm-2 0l-8 5-8-5h16zm0 12H4V8l8 5 8-5v10z"></path>
                        </svg>
                    </button>

                    <!-- 旧的添加按钮（已隐藏） -->
                    <button class="chat-action-btn" id="addMsgBtn" onclick="addMessageToList()" style="display: none;">
                        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="currentColor">
                            <path d="M11 11V5h2v6h6v2h-6v6h-2v-6H5v-2h6Z"></path>
                        </svg>
                    </button>
                </div>
            </div>
        </div>

        <div class="chat-settings-page" id="chatSettingsPage">
            <!-- 1. 顶部导航栏 -->
            <div class="settings-header">
                <div class="back-btn" onclick="closeChatSettings()">←</div>
                <div class="settings-title">聊天设置</div>
            </div>
            <!-- 2. 页面主要内容 -->
            <div class="settings-content">
                <div class="settings-section">
                    <div class="section-title">当前对话</div>
                    <!-- 3. 功能选项：清空记录 -->
                    <div class="settings-item" onclick="clearCurrentChatHistory()">
                        <div class="settings-icon"
                             style="background: linear-gradient(135deg, #ff758c, #ff7eb3);">
                            🗑️
                        </div>
                        <div class="settings-info">
                            <div class="settings-label">清空聊天记录</div>
                            <div class="settings-desc">删除与当前联系人的所有消息</div>
                        </div>
                        <div class="settings-arrow">›</div>
                    </div>
                    <div class="settings-item">
                        <div class="settings-info">
                            <div class="settings-label">代码框滚动条</div>
                            <div class="settings-desc">开启后，过长的代码将出现水平滚动条</div>
                        </div>
                        <div class="settings-action">
                            <label class="toggle-switch">
                                <input type="checkbox" id="codeScrollToggle">
                                <span class="slider"></span>
                            </label>
                        </div>
                    </div>
                    <div class="settings-section">
                        <div class="section-title">外观</div>
                        <div class="settings-section" style="padding: 0 20px; margin-bottom: 20px;">
                            <div class="form-group" style="padding: 10px;">
                                <label class="form-label" style="margin-bottom: 10px;">消息样式</label>
                                <div class="segmented-control" id="messageStyleSelector">
                                    <div class="segmented-option active" data-style="bubble">气泡</div>
                                    <div class="segmented-option" data-style="simple">简洁</div>
                                </div>
                            </div>
                        </div>
                        <!-- 更换聊天背景的设置项 -->
                        <div style="padding: 0 12px;">
                            <div class="app-preview-item">
                                <div class="preview-header">
                                    <div class="preview-icon">🖼️</div>
                                    <div class="preview-name">自定义聊天背景</div>
                                </div>
                                <div class="upload-section">
                                    <!-- 上传文件按钮 -->
                                    <label class="upload-btn">
                                        📁 上传文件
                                        <input type="file" class="file-input" accept="image/*"
                                               onchange="handleChatBgUpload(event)">
                                    </label>
                                    <!-- URL输入按钮 -->
                                    <div class="url-input-btn" onclick="toggleChatBgUrlInput()">🔗 URL填写</div>
                                </div>
                                <!-- URL输入框 (默认隐藏) -->
                                <div class="url-input-box" id="chat-bg-url-box">
                                    <input type="text" class="url-input-field" id="chat-bg-url-input"
                                           placeholder="输入图片URL">
                                    <button class="confirm-btn" onclick="applyChatBgFromUrl()">确认</button>
                                </div>
                                <!-- 状态消息提示 -->
                                <div class="status-message" id="chat-bg-status"></div>
                            </div>
                        </div>
                        <!-- 恢复默认背景的设置项 -->
                        <div class="settings-item" onclick="applyChatBackground('')">
                            <div class="settings-icon" style="background: #e9ecef;">
                                ✨
                            </div>
                            <div class="settings-info">
                                <div class="settings-label">恢复默认背景</div>
                                <div class="settings-desc">移除自定义聊天背景图</div>
                            </div>
                            <div class="settings-arrow">›</div>
                        </div>
                    </div>
                    <!-- 未来可以在这里添加更多设置项 -->
                </div>
            </div>
        </div>
        <div class="message-action-sheet" id="messageActionSheet">
            <div class="action-sheet-backdrop" onclick="hideMessageActionSheet()"></div>
            <div class="action-sheet-options">
                <!-- 新增的选项 -->
                <div class="action-option" id="copyMessageBtn">复制</div>
                <div class="action-option" id="regenerateMessageBtn">重新生成</div>
                <div class="action-option" id="quoteMessageBtn">引用</div>
                <!-- 保留并调整了原有的选项 -->
                <div class="action-option destructive" id="deleteMessageBtn">删除</div>
            </div>
            <!-- 为了美观，将取消按钮独立出来 -->
            <div class="action-sheet-options">
                <div class="action-option cancel" onclick="hideMessageActionSheet()">取消</div>
            </div>
        </div>
        <div id="floatingBall">🐾</div>
        <!-- 白色图标栏目 -->
        <div class="icon-dock-panel" id="iconDockPanel">
            <div class="dock-panel-header">
                <div class="dock-panel-title">我的收藏</div>
                <button class="dock-panel-close" onclick="closeIconDockPanel()">×</button>
            </div>
            <div class="dock-panel-content" id="dockPanelContent">
                <div class="dock-panel-empty">拖动图标到这里收藏</div>
            </div>
        </div>
        <!-- 悬浮球菜单 -->
        <div class="floating-ball-menu" id="floatingBallMenu">
            <div class="fb-menu-item" onclick="toggleIconDockPanel()">
                <span class="fb-menu-icon">⭐</span>
                <span class="fb-menu-label">图标收藏栏</span>
            </div>
            <div class="fb-menu-item" onclick="openSettings(); closeFloatingBallMenu()">
                <span class="fb-menu-icon">⚙️</span>
                <span class="fb-menu-label">设置</span>
            </div>
        </div>
        <div class="sweetheart-list-page" id="sweetheartListPage">
            <div class="sweetheart-list-header">
                <div class="back-btn" onclick="closeSweetheartList(true)">←</div>
                <div class="sweetheart-list-title">密友列表</div>
                <!-- V V V 新增的“添加”按钮 V V V -->
                <div class="add-contact-btn" onclick="addNewSweetheartContact()">+</div>
            </div>
            <div class="sweetheart-list-content" id="sweetheartListContainer">
                <!-- 联系人列表将由JS动态生成到这里 -->
            </div>
        </div>
        <!-- ========== 世界选择页面 ========== -->
        <div class="world-select-page" id="worldSelectPage">
            <div class="world-select-header">
                <div class="back-btn" onclick="closeWorldSelect()">←</div>
                <div class="world-select-title">请选择一个世界</div>
            </div>
            <div class="world-select-content" id="worldSelectContent">
                <!-- 世界列表将由JS动态生成 -->
            </div>
        </div>
        <!-- ========== 新建世界弹窗 ========== -->
        <div class="modal-overlay" id="newWorldModal">
            <div class="new-world-modal-card">
                <div class="new-world-header">
                    <span class="header-deco">🌍</span>
                    <span class="header-title">新建世界</span>
                    <span class="header-deco">🌍</span>
                </div>

                <div class="new-world-content">
                    <!-- 世界名称 -->
                    <div class="world-field required-field">
                        <label class="world-label">
                            <span class="label-icon">✨</span>
                            <span class="label-text">世界名称</span>
                            <span class="required-star">*</span>
                        </label>
                        <input type="text" id="worldNameInput" class="world-input" placeholder="给你的世界起个名字...">
                    </div>
                    <!-- 世界描述 -->
                    <div class="world-field">
                        <label class="world-label">
                            <span class="label-icon">📝</span>
                            <span class="label-text">世界描述</span>
                        </label>
                        <textarea id="worldDescInput" class="world-textarea" placeholder="描述一下这个世界的特点..."
                                  rows="3"></textarea>
                    </div>
                    <div class="world-field" id="worldMapField">
                        <label class="world-label">
                            <span class="label-icon">🗺️</span>
                            <span class="label-text">地图</span>
                        </label>
                        <!-- 地图预览区域 -->
                        <div class="world-map-preview-container" id="worldMapPreviewContainer"
                             onclick="toggleWorldMapOptions()">
                            <img id="worldMapPreview" src="" alt="World Map" style="display: none;">
                            <span id="worldMapPlaceholder">点击选择地图</span>
                        </div>
                        <!-- 地图选项 (默认隐藏) -->
                        <div class="world-map-options" id="worldMapOptions">
                            <button class="world-map-btn" onclick="selectDefaultMap()">默认地图</button>
                            <label class="world-map-btn">
                                导入图片
                                <input type="file" id="worldMapInput" accept="image/*" style="display: none;"
                                       onchange="handleWorldMapUpload(event)">
                            </label>
                        </div>
                    </div>
                    <!-- 绑定世界书 (可折叠) -->
                    <div class="world-field">
                        <div class="world-label-toggle" onclick="toggleWorldWorldbooks()">
                            <div class="world-label">
                                <span class="label-icon">📚</span>
                                <span class="label-text">绑定的世界书</span>
                            </div>
                            <span class="toggle-arrow" id="world-wb-arrow">▼</span>
                        </div>
                        <div class="world-worldbooks-list" id="worldWorldbooksList" style="display: none;">
                            <!-- JS动态生成 -->
                        </div>
                    </div>
                </div>

                <div class="new-world-footer">
                    <button class="world-btn btn-cancel" onclick="closeNewWorldModal()">取消</button>
                    <button class="world-btn btn-save" onclick="saveNewWorld()">创建</button>
                </div>
            </div>
        </div>
        <!-- ========== 世界书页面 - 开始 ========== -->
        <div class="worldbook-page" id="worldbookPage">
            <div class="worldbook-header">
                <div class="back-btn" onclick="closeWorldbook()">←</div>
                <div class="worldbook-title">世界书</div>
                <div style="display: flex; gap: 8px;">
                    <div class="category-manage-btn" onclick="openClassificationManage(event)" title="分类管理">🗂️</div>
                    <div class="category-manage-btn" onclick="openCategoryManage(event)" title="分组管理">📋</div>
                    <div class="add-contact-btn" onclick="openWorldbookModal()">+</div>
                </div>
            </div>

            <div class="worldbook-content" id="worldbookContent">
                <!-- 空状态（默认显示） -->
                <div class="worldbook-empty" id="worldbookEmpty">
                    <div class="worldbook-empty-icon">📖</div>
                    <div class="worldbook-empty-text">现在还没有世界书哦</div>
                    <div class="worldbook-empty-hint">点击右上角添加一个吧 ✨</div>
                </div>

                <!-- 条目列表（有数据时显示） -->
                <div class="worldbook-list" id="worldbookList" style="display: none;"></div>
            </div>
        </div>
        <!-- ========== 世界书弹窗 - 开始 ========== -->
        <div class="worldbook-modal" id="worldbookModal">
            <div class="worldbook-modal-card">
                <div class="worldbook-modal-header">
                    <div class="worldbook-modal-title" id="worldbookModalTitle">新建世界书</div>
                    <button class="worldbook-modal-close" onclick="closeWorldbookModal()">×</button>
                </div>

                <div class="worldbook-modal-body">
                    <!-- 1. 世界书名称 -->
                    <div class="worldbook-form-group">
                        <label class="worldbook-form-label">世界书名称</label>
                        <input type="text" class="worldbook-form-input" id="wbTitleInput"
                               placeholder="例如：魔法世界设定">
                    </div>

                    <!-- 2. 分类选择器 -->
                    <div class="worldbook-form-group">
                        <label class="worldbook-form-label">分类</label>
                        <div class="worldbook-category-selector" id="groupSelector">
                            <div class="category-selected" id="groupSelected">请选择分类</div>
                            <div class="category-options" id="groupOptions">
                                <div class="category-option" data-group="worldview">世界观</div>
                                <div class="category-option" data-group="rules">行为规范</div>
                                <div class="category-option" data-group="knowledge">知识库</div>
                            </div>
                        </div>
                    </div>

                    <!-- 3. 分类选择器（动态生成） -->
                    <div class="worldbook-form-group">
                        <label class="worldbook-form-label">分类</label>
                        <div class="worldbook-category-selector" id="categorySelector">
                            <div class="category-selected" id="categorySelected">请选择分类</div>
                            <div class="category-options" id="categoryOptions">
                                <!-- JS动态填充 -->
                            </div>
                        </div>
                    </div>

                    <!-- 4. 内容输入框 -->
                    <div class="worldbook-form-group">
                        <label class="worldbook-form-label" id="wbContentLabel">内容</label>
                        <textarea class="worldbook-form-textarea" id="wbContentInput"
                                  placeholder="请先选择分类..."></textarea>
                    </div>
                </div>


                <div class="worldbook-modal-footer">
                    <button class="worldbook-btn worldbook-btn-cancel" onclick="closeWorldbookModal()">取消</button>
                    <button class="worldbook-btn worldbook-btn-delete" id="worldbookDeleteBtn"
                            style="display: none;" onclick="deleteWorldbookEntry()">删除
                    </button>
                    <button class="worldbook-btn worldbook-btn-save" onclick="saveWorldbookEntry()">保存</button>
                </div>
            </div>
        </div>
        <!-- ========== 世界书弹窗 - 结束 ========== -->
        <!-- ========== 分类管理页面 - 开始 ========== -->
        <div class="category-manage-page" id="classificationManagePage">
            <div class="category-manage-header">
                <div class="back-btn" onclick="closeClassificationManage()">←</div>
                <div class="category-manage-title">分类管理</div>
            </div>
            <div class="category-manage-content" id="classificationManageContent">
                <!-- 空状态（默认显示）-->
                <div class="category-empty" id="classificationEmpty">
                    <div class="category-empty-icon">🗂️</div>
                    <div class="category-empty-text">所有分类都空空如也</div>
                    <div class="category-empty-hint">先去添加一些世界书条目吧 ✨</div>
                </div>
                <!-- 分类列表（有数据时显示）-->
                <div class="category-list" id="classificationList" style="display: none;"></div>
            </div>
        </div>
        <!-- ========== 分类管理页面 - 结束 ========== -->
        <!-- ========== 分组管理页面 - 开始 ========== -->
        <div class="category-manage-page" id="categoryManagePage">
            <div class="category-manage-header">
                <div class="back-btn" onclick="closeCategoryManage()">←</div>
                <div class="category-manage-title">分组管理</div>
                <div class="add-category-btn" onclick="openNewCategoryModal()">+</div>
            </div>
            <div class="category-manage-content" id="categoryManageContent">
                <!-- 空状态（默认显示）-->
                <div class="category-empty" id="categoryEmpty">
                    <div class="category-empty-icon">📂</div>
                    <div class="category-empty-text">现在还没有分组哦</div>
                    <div class="category-empty-hint">点击右上角添加一个吧 ✨</div>
                </div>
                <!-- 分组列表（有数据时显示）-->
                <div class="category-list" id="categoryList" style="display: none;"></div>
            </div>
        </div>
        <!-- ========== 新建分组弹窗 ========== -->
        <div class="category-modal" id="categoryModal">
            <div class="category-modal-card">
                <div class="category-modal-header">
                    <div class="category-modal-title" id="categoryModalTitle">新建分组</div>
                    <button class="category-modal-close" onclick="closeCategoryModal()">×</button>
                </div>
                <div class="category-modal-body">
                    <div class="category-form-group">
                        <label class="category-form-label">分组名称</label>
                        <input type="text" class="category-form-input" id="categoryNameInput"
                               placeholder="例如：魔法系统">
                    </div>
                    <div class="category-form-group">
                        <label class="category-form-label">分组描述</label>
                        <textarea class="category-form-textarea" id="categoryDescInput"
                                  placeholder="简单描述这个分组的用途..."></textarea>
                    </div>
                </div>
                <div class="category-modal-footer">
                    <button class="category-btn category-btn-cancel" onclick="closeCategoryModal()">取消</button>
                    <button class="category-btn category-btn-delete" id="categoryDeleteBtn"
                            style="display: none;" onclick="deleteCategory()">删除
                    </button>
                    <button class="category-btn category-btn-save" onclick="saveCategory()">保存</button>
                </div>
            </div>
        </div>
        <!-- ========== 分组管理 - 结束 ========== -->


        <script>

            // ▼▼▼ 步骤3：将下面所有JS代码粘贴到 <script> 标签的最顶部 ▼▼▼

            // ================== 地址选择与持久化功能 ==================

            // 1. 定义全局变量来存储用户的选择
            let locationMode = 'real'; // 'real' 或 'virtual'
            let virtualLocation = '';

            /**
             * 打开地址选择菜单
             */
            function openLocationChooser() {
                document.getElementById('locationActionSheet').classList.add('show');
            }

            /**
             * 关闭地址选择菜单
             */
            function closeLocationChooser() {
                document.getElementById('locationActionSheet').classList.remove('show');
            }

            /**
             * 用户选择“获取真实地址”
             */
            function selectRealLocation() {
                locationMode = 'real';
                // 调用现有的定位函数
                updateLocation();
                // 保存设置并关闭菜单
                saveLocationSettings();
                closeLocationChooser();
            }

            /**
             * 用户选择“填写虚拟地址”
             */
            function selectVirtualLocation() {
                const currentVirtual = localStorage.getItem('virtualLocation') || '请输入虚拟地址';
                const newLocation = prompt('请输入你要显示的虚拟地址：', currentVirtual);

                // 如果用户输入了内容 (而不是取消或留空)
                if (newLocation !== null && newLocation.trim() !== '') {
                    const trimmedLocation = newLocation.trim();
                    locationMode = 'virtual';
                    virtualLocation = trimmedLocation;

                    // 立刻更新界面
                    document.getElementById('locationText').textContent = trimmedLocation;

                    // 保存设置
                    saveLocationSettings();
                }
                // 关闭菜单
                closeLocationChooser();
            }

            /**
             * 将用户的选择保存到 localStorage
             */
            function saveLocationSettings() {
                try {
                    localStorage.setItem('locationMode', locationMode);
                    localStorage.setItem('virtualLocation', virtualLocation);
                    console.log(`地址设置已保存: 模式=${locationMode}, 地址=${virtualLocation}`);
                } catch (e) {
                    console.error('保存地址设置失败:', e);
                }
            }

            /**
             * 从 localStorage 加载用户的地址设置
             * (这个函数会在页面启动时调用)
             */
            function loadLocationSettings() {
                const savedMode = localStorage.getItem('locationMode');
                const savedVirtual = localStorage.getItem('virtualLocation');

                if (savedMode) {
                    locationMode = savedMode;
                }
                if (savedVirtual) {
                    virtualLocation = savedVirtual;
                }

                console.log(`地址设置已加载: 模式=${locationMode}, 地址=${virtualLocation}`);

                // 加载后立即应用设置
                if (locationMode === 'virtual' && virtualLocation) {
                    document.getElementById('locationText').textContent = virtualLocation;
                } else {
                    // 如果是真实模式，则调用 updateLocation
                    updateLocation();
                }
            }


            // ▲▲▲ JS代码粘贴结束 ▲▲▲


            // ================== 新增：用户设置相关函数 ==================

            /**
             * 打开用于编辑用户信息的卡片
             * 这个函数由“我的信息”按钮的 onclick 调用
             */

            let userProfile = {
                name: '我',
                avatar: '👤',
                persona: '我是一名用户，请以简洁友好的方式与我对话。' // 新增用户设定字段
            };
            let currentAvatarTarget = null;

            /**
             * 从 localStorage 加载用户配置
             * 这个函数会在应用启动时调用
             */
            function loadUserProfile() {
                const savedProfile = localStorage.getItem('userProfile');
                if (savedProfile) {
                    try {
                        const loadedProfile = JSON.parse(savedProfile);
                        // 确保旧的用户数据也能兼容新的persona字段
                        userProfile = {...userProfile, ...loadedProfile};
                        console.log('成功从 localStorage 加载用户个人信息。');
                    } catch (e) {
                        console.error('解析用户个人信息失败:', e);
                    }
                }
            }

            /**
             * 修复版：统一保存联系人和用户信息的函数
             * - 解决了新建联系人时会创建重复数据的问题
             * - 结构清晰，易于维护
             */
            /**
             * [最终智能版] 统一保存联系人和用户信息的函数
             * - 能根据标记判断是保存到普通列表、密友列表或当前世界
             */
            function saveAllCharacterData() {
                const modal = document.getElementById('characterCardModal');
                const contactId = modal.dataset.editingId;
                const saveTarget = modal.dataset.saveTarget || 'default'; // 获取保存目标标记，默认为'default'
                const worldIdToSaveTo = modal.dataset.currentWorldId; // 获取当前世界ID

                if (!contactId) {
                    console.error("保存失败：无法获取当前操作的联系人ID。");
                    alert("保存失败，发生未知错误。");
                    return;
                }

                const contactName = document.getElementById('char-name').value.trim();
                if (!contactName) {
                    alert('角色姓名不能为空！');
                    return;
                }

                const contactPersona = document.getElementById('char-persona').value.trim();
                const contactAvatar = document.getElementById('avatar-preview').src;
                // ▼▼▼ 第4步：在这里粘贴新增的JS代码 ▼▼▼
                // [新增] 获取绑定的世界书ID
                const boundWorldbooks = [];
                document.querySelectorAll('#charWorldbooksList input[type="checkbox"]:checked').forEach(cb => {
                    boundWorldbooks.push(cb.value);
                });


                // 保存用户个人信息 (这部分不变)
                userProfile.name = document.getElementById('user-name').value.trim() || '我';
                userProfile.persona = document.getElementById('user-persona').value.trim();
                userProfile.avatar = document.getElementById('user-avatar-preview').src;
                localStorage.setItem('userProfile', JSON.stringify(userProfile));

                // --- 处理联系人数据的保存逻辑 ---
                let contactToEditOrCreate = contactsData.find(c => String(c.id) === String(contactId));

                if (contactToEditOrCreate) {
                    // 编辑现有联系人
                    contactToEditOrCreate.name = contactName;
                    contactToEditOrCreate.status = contactPersona || '这个角色很神秘，还没有设定...';
                    contactToEditOrCreate.avatar = contactAvatar;
                    contactToEditOrCreate.boundWorldbooks = boundWorldbooks;
                } else {
                    // 创建新联系人
                    contactToEditOrCreate = {
                        id: contactId,
                        name: contactName,
                        status: contactPersona || '这个角色很神秘，还没有设定...',
                        avatar: contactAvatar,
                        boundWorldbooks: boundWorldbooks,
                    };
                    contactsData.push(contactToEditOrCreate); // 添加到总联系人列表
                }

                // 针对不同列表的特殊处理
                if (saveTarget === 'sweetheart') {
                    const existingSweetheartIndex = sweetheartContactsData.findIndex(c => String(c.id) === String(contactId));
                    if (existingSweetheartIndex !== -1) {
                        sweetheartContactsData[existingSweetheartIndex] = contactToEditOrCreate;
                    } else {
                        sweetheartContactsData.push(contactToEditOrCreate);
                    }
                    saveSweetheartContacts();
                    renderSweetheartList();
                } else if (worldIdToSaveTo) { // 如果是从某个世界打开的通讯录
                    const world = worldsData.find(w => w.id === worldIdToSaveTo);
                    if (world && !world.contacts.includes(contactId)) {
                        world.contacts.push(contactId); // 将新联系人ID添加到该世界的联系人列表
                        saveWorldsData(); // 保存世界数据
                    }
                    // 重新渲染当前世界的通讯录
                    openWorldContacts(worldIdToSaveTo);
                } else { // 默认情况下，渲染所有联系人
                    localStorage.setItem('phoneContactsData', JSON.stringify(contactsData));
                    renderContacts(contactsData);
                }

                // 如果当前聊天对象被编辑了，同步更新聊天标题
                if (currentChatContact && String(currentChatContact.id) === String(contactId)) {
                    document.getElementById('chatContactName').textContent = contactName;
                }

                closeCharacterCardPage();
                showSuccessModal('保存成功', '所有信息已更新。');

                // 清理标记，避免下次打开时出错
                modal.removeAttribute('data-save-target');
                modal.removeAttribute('data-currentWorldId'); // 清理世界ID标记
            }


            // ========== 密友角色卡相关函数 ==========

            let currentEditingSweetheartId = null;

            /**
             * 打开密友角色卡弹窗（新建模式）
             */
            function openSweetheartCardModal() {
                currentEditingSweetheartId = null;

                // 重置所有字段
                document.getElementById('sweetheart-name').value = '';
                document.getElementById('sweetheart-persona').value = '';
                document.getElementById('sweetheart-personality').value = '';
                document.getElementById('sweetheart-occupation').value = '';
                document.getElementById('sweetheart-catchphrase').value = '';
                document.getElementById('sweetheart-history').value = '';
                document.getElementById('sweetheart-relationship').value = '';

                // 重置头像
                document.getElementById('sweetheart-avatar-preview').src = 'data:image/gif;base64,R0lGODlhAQABAAD/ACwAAAAAAQABAAACADs=';

                // 重置世界书区域
                document.getElementById('sweetheartWorldbooksList').style.display = 'none';
                document.getElementById('sweetheart-wb-arrow').classList.remove('open');

                // 显示弹窗
                document.getElementById('sweetheartCardModal').classList.add('show');
            }

            /**
             * 关闭密友角色卡弹窗
             */
            function closeSweetheartCardModal() {
                document.getElementById('sweetheartCardModal').classList.remove('show');
                currentEditingSweetheartId = null;
            }

            /**
             * 打开头像选择器
             */
            function openSweetheartAvatarPicker() {
                // 这里可以实现更复杂的选择逻辑，现在简单触发文件上传
                document.getElementById('sweetheart-avatar-input').click();
            }

            /**
             * 切换世界书列表的展开/收起
             */
            function toggleSweetheartWorldbooks() {
                const list = document.getElementById('sweetheartWorldbooksList');
                const arrow = document.getElementById('sweetheart-wb-arrow');

                if (list.style.display === 'none') {
                    renderSweetheartWorldbooksList();
                    list.style.display = 'block';
                    arrow.classList.add('open');
                } else {
                    list.style.display = 'none';
                    arrow.classList.remove('open');
                }
            }

            /**
             * 渲染世界书复选框列表
             */
            function renderSweetheartWorldbooksList() {
                const container = document.getElementById('sweetheartWorldbooksList');

                if (worldbookData.length === 0) {
                    container.innerHTML = '<div style="text-align: center; color: #BCAAA4; padding: 20px; font-size: 13px;">还没有世界书哦~</div>';
                    return;
                }

                container.innerHTML = '';

                worldbookData.forEach(wb => {
                    const item = document.createElement('div');
                    item.className = 'sweetheart-wb-item';

                    const checkbox = document.createElement('input');
                    checkbox.type = 'checkbox';
                    checkbox.id = `sh-wb-${wb.id}`;
                    checkbox.value = wb.id;

                    const label = document.createElement('label');
                    label.htmlFor = `sh-wb-${wb.id}`;
                    label.textContent = wb.title;

                    item.appendChild(checkbox);
                    item.appendChild(label);
                    container.appendChild(item);
                });
            }

            /**
             * 保存密友角色卡数据
             */
            function saveSweetheartCardData() {
                // 1. 获取必填字段
                const name = document.getElementById('sweetheart-name').value.trim();
                if (!name) {
                    alert('请填写姓名！💕');
                    return;
                }

                const persona = document.getElementById('sweetheart-persona').value.trim();
                if (!persona) {
                    alert('请填写基础设定！📝');
                    return;
                }

                // 2. 获取可选字段
                const personality = document.getElementById('sweetheart-personality').value.trim();
                const occupation = document.getElementById('sweetheart-occupation').value.trim();
                const catchphrase = document.getElementById('sweetheart-catchphrase').value.trim();
                const history = document.getElementById('sweetheart-history').value.trim();
                const relationship = document.getElementById('sweetheart-relationship').value.trim();

                // 3. 获取头像
                const avatar = document.getElementById('sweetheart-avatar-preview').src;
                const finalAvatar = (avatar && !avatar.includes('data:image/gif')) ? avatar : '💖';

                // 4. 获取绑定的世界书
                const boundWorldbooks = [];
                document.querySelectorAll('.sweetheart-wb-item input[type="checkbox"]:checked').forEach(cb => {
                    boundWorldbooks.push(cb.value);
                });

                // 5. 生成ID并保存
                const contactId = currentEditingSweetheartId || 'SH' + Date.now();

                const contactData = {
                    id: contactId,
                    name,
                    status: persona,
                    avatar: finalAvatar,
                    personality,
                    occupation,
                    catchphrase,
                    history,
                    relationship,
                    boundWorldbooks
                };

                // 6. 判断是新建还是编辑
                const existingIndex = sweetheartContactsData.findIndex(c => c.id === contactId);
                if (existingIndex !== -1) {
                    sweetheartContactsData[existingIndex] = contactData;
                } else {
                    sweetheartContactsData.push(contactData);
                }

                // 7. 保存到localStorage
                saveSweetheartContacts();

                // 8. 刷新列表并关闭弹窗
                renderSweetheartList();
                closeSweetheartCardModal();
                showSuccessModal('保存成功', `${name} 已加入密友列表！💖`);
            }

            // ▼▼▼ 第3步：在这里粘贴新增的JS代码 ▼▼▼

            /**
             * [新增] 切换角色卡中世界书列表的展开/收起
             */
            function toggleCharacterWorldbooks() {
                const list = document.getElementById('charWorldbooksList');
                const arrow = document.getElementById('char-wb-arrow');

                if (list.style.display === 'none') {
                    list.style.display = 'block';
                    arrow.classList.add('open');
                } else {
                    list.style.display = 'none';
                    arrow.classList.remove('open');
                }
            }

            /**
             * [新增] 在角色卡中渲染世界书复选框列表
             * @param {Array<string>} boundIds - 当前角色已绑定的世界书ID数组
             */
            function renderCharacterWorldbooksList(boundIds = []) {
                const container = document.getElementById('charWorldbooksList');
                if (!container) return;

                if (worldbookData.length === 0) {
                    container.innerHTML = '<div style="text-align: center; color: #999; padding: 20px; font-size: 13px;">还没有创建世界书哦~</div>';
                    return;
                }

                container.innerHTML = ''; // 清空旧内容

                worldbookData.forEach(wb => {
                    const item = document.createElement('div');
                    item.className = 'char-wb-item';

                    const checkbox = document.createElement('input');
                    checkbox.type = 'checkbox';
                    checkbox.id = `char-wb-${wb.id}`;
                    checkbox.value = wb.id;
                    // 如果当前世界书ID在已绑定列表中，则默认勾选
                    if (boundIds.includes(wb.id)) {
                        checkbox.checked = true;
                    }

                    const label = document.createElement('label');
                    label.htmlFor = `char-wb-${wb.id}`;
                    label.textContent = wb.title;

                    item.appendChild(checkbox);
                    item.appendChild(label);
                    container.appendChild(item);
                });
            }

            // ▲▲▲ JS代码粘贴结束 ▲▲▲


            // 监听头像上传
            document.addEventListener('DOMContentLoaded', function () {
                const avatarInput = document.getElementById('sweetheart-avatar-input');
                if (avatarInput) {
                    avatarInput.addEventListener('change', function (event) {
                        const file = event.target.files[0];
                        if (file) {
                            const reader = new FileReader();
                            reader.onload = function (e) {
                                document.getElementById('sweetheart-avatar-preview').src = e.target.result;
                            };
                            reader.readAsDataURL(file);
                        }
                    });
                }
            });


            const predefinedWallpapers = [
                'https://images.unsplash.com/photo-1570129477492-45c003edd2be?q=80&w=2070&auto=format&fit=crop',
                'https://images.unsplash.com/photo-1502672260266-1c1ef2d93688?q=80&w=1980&auto=format&fit=crop',
                'https://images.unsplash.com/photo-1554995207-c18c203602cb?q=80&w=2070&auto=format&fit=crop',
                'https://images.unsplash.com/photo-1580587771525-78b9dba3b914?q=80&w=1974&auto=format&fit=crop',
                'https://s3plus.meituan.net/opapisdk/op_ticket_885190757_1759876940844_qdqqd_7jj1ti.jpg',
                'https://s3plus.meituan.net/opapisdk/op_ticket_885190757_1760094166464_qdqqd_n7utqx.jpg',
                'https://s3plus.meituan.net/opapisdk/op_ticket_885190757_1760094369789_qdqqd_54ccoj.png',
                'https://s3plus.meituan.net/opapisdk/op_ticket_885190757_1760094483657_qdqqd_fpd674.png',
                'https://s3plus.meituan.net/opapisdk/op_ticket_885190757_1760094641422_qdqqd_nrkqzw.png',
                'https://s3plus.meituan.net/opapisdk/op_ticket_885190757_1760094705206_qdqqd_fmzh0j.png',
                'https://s3plus.meituan.net/opapisdk/op_ticket_885190757_1760094777621_qdqqd_wx4ars.png'
            ];

            function applyWallpaper(imageUrl) {
                const screenEl = document.getElementById('screen');
                if (!imageUrl) {
                    screenEl.style.backgroundImage = '';
                    localStorage.removeItem('phoneWallpaper');
                    console.log('壁纸已清除，恢复默认背景');
                } else {
                    screenEl.style.backgroundImage = `url('${imageUrl}')`;
                    localStorage.setItem('phoneWallpaper', imageUrl);
                    console.log('壁纸已应用并保存');
                }
                updateWallpaperActiveState(imageUrl);
            }

            function renderWallpaperThumbnails() {
                const grid = document.getElementById('wallpaperGrid');
                grid.innerHTML = '';

                predefinedWallpapers.forEach(url => {
                    const thumb = document.createElement('div');
                    thumb.className = 'wallpaper-thumbnail';
                    thumb.style.backgroundImage = `url('${url}')`;
                    thumb.dataset.url = url;
                    thumb.onclick = () => applyWallpaper(url);
                    grid.appendChild(thumb);
                });

                const noWallpaperThumb = document.createElement('div');
                noWallpaperThumb.className = 'wallpaper-thumbnail';
                noWallpaperThumb.style.background = 'linear-gradient(135deg, #ddd, #fff)';
                noWallpaperThumb.innerHTML = '<span style="position:absolute; top:50%; left:50%; transform:translate(-50%,-50%); font-weight:bold; color:#888; font-size:12px;">默认</span>';
                noWallpaperThumb.onclick = () => applyWallpaper('');
                grid.appendChild(noWallpaperThumb);
            }

            function updateWallpaperActiveState(currentUrl) {
                document.querySelectorAll('.wallpaper-thumbnail').forEach(thumb => {
                    if (!thumb.dataset.url && !currentUrl) {
                        thumb.classList.add('active');
                    } else {
                        thumb.classList.toggle('active', thumb.dataset.url === currentUrl);
                    }
                });
            }

            function handleWallpaperUpload(event) {
                const file = event.target.files[0];
                if (!file) return;

                const reader = new FileReader();
                reader.onload = (e) => {
                    applyWallpaper(e.target.result);
                    showWallpaperStatus('本地壁纸已应用');
                };
                reader.onerror = () => {
                    showWallpaperStatus('读取文件失败', 'error');
                };
                reader.readAsDataURL(file);
            }

            function toggleWallpaperUrlInput() {
                const urlBox = document.getElementById('wallpaper-url-box');
                urlBox.classList.toggle('show');
            }

            function applyWallpaperFromUrl() {
                const urlInput = document.getElementById('wallpaper-url-input');
                const url = urlInput.value.trim();
                if (url) {
                    applyWallpaper(url);
                    showWallpaperStatus('URL壁纸已应用');
                    urlInput.value = '';
                    toggleWallpaperUrlInput();
                } else {
                    showWallpaperStatus('请输入有效的URL', 'error');
                }
            }

            function showWallpaperStatus(message, type = 'success') {
                const statusEl = document.getElementById('wallpaper-status');
                statusEl.textContent = message;
                statusEl.className = 'status-message' + (type === 'error' ? ' error' : '');
                setTimeout(() => {
                    statusEl.textContent = '';
                }, 3000);
            }

            // === 使用这个最终版本的 updateTime 函数 ===
            function updateTime() {
                const now = new Date();
                const hours = String(now.getHours()).padStart(2, '0');
                const minutes = String(now.getMinutes()).padStart(2, '0');
                const timeStr = `${hours}:${minutes}`;

                const days = ['SUNDAY', 'MONDAY', 'TUESDAY', 'WEDNESDAY', 'THURSDAY', 'FRIDAY', 'SATURDAY'];
                const dayStr = days[now.getDay()];

                const months = ['JAN', 'FEB', 'MAR', 'APR', 'MAY', 'JUN', 'JUL', 'AUG', 'SEP', 'OCT', 'NOV', 'DEC'];
                const monthStr = months[now.getMonth()];
                const dateNum = now.getDate();

                const fullDateStr = `${dayStr}, ${monthStr} ${dateNum}`;

                // 更新状态栏的时间
                document.querySelectorAll('.status-bar span:first-child').forEach(el => {
                    el.textContent = timeStr;
                });

                // 更新我们最终版容器内的时间和日期
                const mainTimeEl = document.getElementById('finalMainTime');
                if (mainTimeEl) {
                    mainTimeEl.textContent = timeStr;
                }

                const mainDateEl = document.getElementById('finalMainDate');
                if (mainDateEl) {
                    mainDateEl.textContent = fullDateStr;
                }
            }


            updateTime();
            setInterval(updateTime, 60000);
            const globalConfig = {
                apiConfigs: [],
                activeApiConfig: null,
                database: {
                    supabaseUrl: '',
                    supabaseKey: '',
                    tableName: 'user_data',
                    client: null
                },
                storage: {
                    bucketName: 'icons',
                    uploadPath: 'app-icons/',
                    maxFileSize: 5
                },
                customIcons: {},
                savedWidgets: [],
                dockIcons: ['https://s3plus.meituan.net/opapisdk/op_ticket_885190757_1760103483956_qdqqd_ufc76a.png', 'https://s3plus.meituan.net/opapisdk/op_ticket_885190757_1760095214931_qdqqd_cud7dm.png', 'https://s3plus.meituan.net/opapisdk/op_ticket_885190757_1760094934930_qdqqd_5lvg07.png', 'https://s3plus.meituan.net/opapisdk/op_ticket_885190757_1760103414729_qdqqd_t8eu22.png']
            };

            // ========== 开始：请用这个【修正版】函数替换旧的 openCharacterCardPage 函数 ==========

            function openCharacterCardPage() {
                const page = document.getElementById('characterCardModal');
                if (!page) {
                    console.error('错误：无法找到 characterCardModal 元素！');
                    return;
                }
                // 1. 确保 modal 容器在 DOM 中是可见的
                page.style.display = 'flex';

                // 2. 为了让 CSS 过渡动画能够正确触发，我们延迟一个渲染帧再添加 'show' 类
                requestAnimationFrame(() => {
                    page.classList.add('show');
                });

                const modal = page.querySelector('.character-card-modal');

                // 现在的逻辑更加健壮，不再寻找不存在的元素。
                // 我们直接处理显示逻辑。

                // 检查是否正在创建一个全新的联系人。
                // this.dataset.editingId 已经被移除，现在的判断更通用
                const isNewContact = !document.getElementById('characterCardModal').textContent || document.getElementById('characterCardModal').textContent === '...';
                if (isNewContact) {
                    // 重置表单，为新建联系人做准备
                    document.getElementById('char-name').value = '';
                    document.getElementById('char-persona').value = '';
                    // 重置性别选择为男性
                    // 重置性别选择为男性
                    const maleRadio = document.querySelector('.character-gender-selection input[value="male"]');
                    if (maleRadio) maleRadio.checked = true;
                    // 使用1x1的透明像素作为占位符，避免出现破碎的图片图标
                    document.getElementById('avatar-preview').src = 'data:image/gif;base64,R0lGODlhAQABAAD/ACwAAAAAAQABAAACADs=';
                    document.getElementById('avatar-input').value = '';
                }
            }


            function closeCharacterCardPage() {
                const page = document.getElementById('characterCardModal');
                const modal = page.querySelector('.character-card-modal');
                page.classList.remove('show');

                // 在动画结束后执行清理工作
                setTimeout(() => {
                    page.style.display = 'none';
                    // 清理模式标记，以便下次默认是编辑联系人
                    modal.removeAttribute('data-mode');
                }, 300);
            }

            // ========== 开始：用这个【修正版】的change事件监听器替换旧的 ==========
            document.getElementById('avatar-input').addEventListener('change', function (event) {
                const file = event.target.files[0];
                // 检查文件和当前目标是否存在
                if (file && currentAvatarTarget) {
                    const reader = new FileReader();
                    reader.onload = function (e) {
                        // 根据记录的目标更新对应的头像预览
                        const previewId = currentAvatarTarget === 'user' ? 'user-avatar-preview' : 'avatar-preview';
                        document.getElementById(previewId).src = e.target.result;
                    }
                    reader.readAsDataURL(file);
                }
            }); // <--- 【核心修正】在这里补上缺失的 });

            // ========== 结束：替换完成 ==========


            // ========== 结束：替换完成 ==========


            function escapeHTML(str) {
                if (!str) return '';
                return str.replace(/[&<>"']/g, function (match) {
                    return {
                        '&': '&amp;',
                        '<': '&lt;',
                        '>': '&gt;',
                        '"': '&quot;',
                        "'": '&#39;'
                    }[match];
                });
            }

            let messageLongPressTimer = null; // 用于检测长按的计时器

            /**
             * 创建消息的DOM元素，并为其绑定长按/右键事件
             */
            function _createMessageDOM(contactId, message, index) {
                const row = document.createElement('div');
                row.className = 'message-row ' + (message.sender === 'user' ? 'sent' : 'received');
                row.dataset.messageIndex = index;

                const avatarDiv = document.createElement('div');
                avatarDiv.className = 'message-chat-avatar';

                let avatarSrc, senderName;
                if (message.sender === 'user') {
                    // ============ ↓↓↓ 核心改造点在这里 ↓↓↓ ============
                    // 不再使用硬编码的"你"和"👤", 而是从 userProfile 获取
                    senderName = userProfile.name;
                    avatarSrc = userProfile.avatar;
                    const isUrl = avatarSrc && (avatarSrc.startsWith('http') || avatarSrc.startsWith('data:'));
                    if (isUrl) {
                        avatarDiv.innerHTML = `<img src="${avatarSrc}" alt="${senderName}">`;
                    } else {
                        // 使用自定义的 emoji 或字符作为头像，并保持蓝色背景
                        avatarDiv.innerHTML = `<div class="initials" style="background: #0A84FF;">${escapeHTML(avatarSrc)}</div>`;
                    }
                    // ============ ↑↑↑ 改造结束 ↑↑↑ ============
                } else {
                    // 渲染对方消息的逻辑保持不变
                    senderName = currentChatContact.name;
                    avatarSrc = currentChatContact.avatar;
                    const isUrl = avatarSrc && (avatarSrc.startsWith('http') || avatarSrc.startsWith('data:'));
                    if (isUrl) {
                        avatarDiv.innerHTML = `<img src="${avatarSrc}" alt="${senderName}">`;
                    } else {
                        avatarDiv.innerHTML = `<div class="initials" style="background: #6c757d;">${escapeHTML(avatarSrc)}</div>`;
                    }
                }

                const contentDiv = document.createElement('div');
                contentDiv.className = 'message-content';

                const senderNameDiv = document.createElement('div');
                senderNameDiv.className = 'message-sender-name';
                senderNameDiv.textContent = senderName;

                const bubble = createMessageBubble(message);

                bubble.addEventListener('contextmenu', (e) => {
                    e.preventDefault();
                    showMessageActionSheet(contactId, index);
                });

                let messageLongPressTimer = null;
                bubble.addEventListener('touchstart', () => {
                    messageLongPressTimer = setTimeout(() => showMessageActionSheet(contactId, index), 500);
                }, {passive: true});
                bubble.addEventListener('touchend', () => clearTimeout(messageLongPressTimer));
                bubble.addEventListener('touchmove', () => clearTimeout(messageLongPressTimer));

                contentDiv.appendChild(senderNameDiv);
                contentDiv.appendChild(bubble);

                // 最终结论：无论发送还是接收，DOM结构都应该是 [头像, 内容]。
                // 这样CSS规则才能在一致的结构上工作，不会产生歧义。
                row.appendChild(avatarDiv);
                row.appendChild(contentDiv);

                return row;
            }


            /**
             * 显示消息操作菜单
             * @param {string|number} contactId - 联系人ID
             * @param {number} index - 消息的索引
             */
            function showMessageActionSheet(contactId, index) {
                const actionSheet = document.getElementById('messageActionSheet');
                actionSheet.dataset.contactId = contactId;
                actionSheet.dataset.index = index;
                actionSheet.classList.add('show');
            }

            /**
             * 隐藏消息操作菜单
             */
            function hideMessageActionSheet() {
                const actionSheet = document.getElementById('messageActionSheet');
                actionSheet.classList.remove('show');
                // 清理数据以防万一
                delete actionSheet.dataset.contactId;
                delete actionSheet.dataset.index;
            }


            /**
             * 删除指定的消息 (现在由操作菜单调用)
             * @param {string|number} contactId - 联系人ID
             * @param {number} messageIndex - 消息的索引
             */
            function deleteMessage(contactId, messageIndex) {
                if (confirm('确定要永久删除这条消息吗？')) {
                    const chatHistory = JSON.parse(localStorage.getItem('phoneChatHistory') || '{}');
                    if (chatHistory[contactId] && chatHistory[contactId][messageIndex] !== undefined) {
                        chatHistory[contactId].splice(messageIndex, 1);
                        try {
                            localStorage.setItem('phoneChatHistory', JSON.stringify(chatHistory));
                        } catch (e) {
                            console.error('保存失败:', e);
                            alert('存储空间不足，请清理数据');
                        }
                        console.log(`消息已删除 (Contact: ${contactId}, Index: ${messageIndex})`);
                        openChat(currentChatContact);
                        renderContacts(contactsData);
                    }
                }
            }

            /**
             * [新增] 复制消息文本到剪贴板
             */
            function copyMessage(contactId, messageIndex) {
                const chatHistory = JSON.parse(localStorage.getItem('phoneChatHistory') || '{}');
                const message = chatHistory[contactId]?.[messageIndex];

                if (message && message.text) {
                    // 如果消息是图片HTML，我们复制一个[图片]占位符
                    if (message.text.trim().startsWith('<img')) {
                        navigator.clipboard.writeText('[图片]').then(() => {
                            showSuccessModal('复制成功', '已将"[图片]"复制到剪贴板。');
                        }).catch(err => console.error('复制图片占位符失败', err));
                    } else {
                        // 否则，正常复制文本
                        navigator.clipboard.writeText(message.text).then(() => {
                            showSuccessModal('复制成功', '消息内容已复制到剪贴板。');
                        }).catch(err => console.error('复制失败', err));
                    }
                }
                hideMessageActionSheet();
            }

            /**
             * [全新版本] 引用消息：激活引用预览UI
             */
            function quoteMessage(contactId, messageIndex) {
                const chatHistory = JSON.parse(localStorage.getItem('phoneChatHistory') || '{}');
                const message = chatHistory[contactId]?.[messageIndex];

                if (!message) return;

                // 1. 存储被引用的消息数据
                currentQuoteData = {
                    sender: message.sender,
                    text: message.text,
                    senderName: message.sender === 'user' ? userProfile.name : currentChatContact.name
                };

                // 2. 更新并显示预览UI
                const previewEl = document.getElementById('quotePreview');
                document.getElementById('quotePreviewSender').textContent = currentQuoteData.senderName;

                let previewText = message.text;
                // 如果是图片，预览文本显示为[图片]
                if (previewText.trim().startsWith('<img')) {
                    previewText = '[图片]';
                }
                document.getElementById('quotePreviewText').textContent = previewText;

                previewEl.classList.add('show');

                // 3. 聚焦输入框并隐藏操作菜单
                document.getElementById('chatInput').focus();
                hideMessageActionSheet();
            }

            /**
             * [新增] 取消引用
             */
            function cancelQuote() {
                currentQuoteData = null;
                const previewEl = document.getElementById('quotePreview');
                previewEl.classList.remove('show');
            }


            /**
             * [新增] 重新生成AI回复
             */
            async function regenerateAiResponse(contactId, messageIndex) {
                const chatHistory = JSON.parse(localStorage.getItem('phoneChatHistory') || '{}');
                const messages = chatHistory[contactId];

                if (!messages || !messages[messageIndex]) return;

                const targetMessage = messages[messageIndex];

                // 只能重新生成AI的回复
                if (targetMessage.sender === 'user') {
                    showSuccessModal('操作无效', '只能对AI的回复进行重新生成哦。', 2000);
                    hideMessageActionSheet();
                    return;
                }

                // 1. 删除当前的AI回复
                messages.splice(messageIndex, 1);
                try {
                    localStorage.setItem('phoneChatHistory', JSON.stringify(chatHistory));
                } catch (e) {
                    console.error('保存失败:', e);
                    alert('存储空间不足，请清理数据');
                }
                openChat(currentChatContact); // 重新渲染界面以移除旧消息

                // 2. 隐藏操作菜单
                hideMessageActionSheet();

                // 3. 调用 getAiReply 函数，它会自动使用当前的（已删掉最后一条的）历史记录来生成新回复
                await getAiReply();
            }

            /**
             * [全新版本] 创建消息气泡的DOM元素
             * @param {object} message - 消息对象，可能包含 text, quote 等属性
             * @returns {HTMLElement} - 创建好的气泡DOM元素
             */
            function createMessageBubble(message) {
                const bubble = document.createElement('div');
                bubble.className = 'chat-bubble';

                const messageText = String(message.text || '');

                // 1. 检查并渲染引用部分
                if (message.quote) {
                    const quoteWrapper = document.createElement('div');
                    quoteWrapper.className = 'quoted-message-wrapper';

                    let quotedContent = message.quote.text;
                    if (quotedContent.trim().startsWith('<img')) {
                        quotedContent = '[图片]';
                    }

                    quoteWrapper.innerHTML = `
            <strong class="quoted-sender">${escapeHTML(message.quote.senderName)}</strong>
            <span class="quoted-text">${escapeHTML(quotedContent)}</span>
        `;
                    bubble.appendChild(quoteWrapper);
                }

                // 2. 区分处理主消息内容（图片、代码、纯文本）

                // 2a. 如果主消息是图片
                if (messageText.trim().startsWith('<img')) {
                    // 如果是图片，它自己就需要一个容器，而不是直接插入气泡
                    const imageContainer = document.createElement('div');
                    imageContainer.innerHTML = messageText;

                    // 为了保持样式统一，我们把图片也包装一下，并且去掉气泡的padding
                    bubble.classList.add('image-only');
                    bubble.appendChild(imageContainer.firstChild);

                    // 如果有引用，图片消息的padding需要特殊处理
                    if (message.quote) {
                        bubble.style.padding = '8px';
                        bubble.classList.remove('image-only');
                    }
                    return bubble;
                }

                // 2b. 如果主消息包含代码块
                const codeBlockRegex = /```([\s\S]*?)```/g;
                if (codeBlockRegex.test(messageText)) {
                    // 这部分逻辑和之前一样，用于解析代码块和普通文本混合的内容
                    let lastIndex = 0;
                    let match;
                    codeBlockRegex.lastIndex = 0; // 重置正则的 lastIndex

                    while ((match = codeBlockRegex.exec(messageText)) !== null) {
                        const precedingText = messageText.slice(lastIndex, match.index);
                        if (precedingText) {
                            const textNode = document.createElement('div');
                            textNode.className = 'main-message-text';
                            textNode.textContent = precedingText;
                            bubble.appendChild(textNode);
                        }

                        // 创建代码块... (这部分代码保持不变)
                        const codeContent = match[1].trim();
                        const wrapper = document.createElement('div');
                        wrapper.className = 'code-block-wrapper';
                        const pre = document.createElement('pre');
                        const code = document.createElement('code');
                        code.textContent = codeContent;
                        pre.appendChild(code);
                        const copyBtn = document.createElement('button');
                        copyBtn.className = 'copy-code-btn';
                        copyBtn.innerHTML = `<svg viewBox="0 0 24 24"><path d="M16 1H4c-1.1 0-2 .9-2 2v14h2V3h12V1zm3 4H8c-1.1 0-2 .9-2 2v14c0 1.1.9 2 2 2h11c1.1 0 2-.9 2-2V7c0-1.1-.9-2-5zm0 16H8V7h11v14z"></path></svg><span>复制</span>`;
                        copyBtn.onclick = () => {
                            navigator.clipboard.writeText(codeContent).then(() => {
                                copyBtn.classList.add('copied');
                                copyBtn.innerHTML = '<svg viewBox="0 0 24 24"><path d="M9 16.2L4.8 12l-1.4 1.4L9 19 21 7l-1.4-1.4L9 16.2z"></path></svg><span>已复制</span>';
                                setTimeout(() => {
                                    copyBtn.classList.remove('copied');
                                    copyBtn.innerHTML = '<svg viewBox="0 0 24 24"><path d="M16 1H4c-1.1 0-2 .9-2 2v14h2V3h12V1zm3 4H8c-1.1 0-2 .9-2 2v14c0 1.1.9 2 2 2h11c1.1 0 2-.9 2-2V7c0-1.1-.9-2-2-2zm0 16H8V7h11v14z"></path></svg><span>复制</span>';
                                }, 2000);
                            }).catch(err => {
                                console.error('复制失败:', err);
                                alert('复制失败，请手动复制');
                            });
                        };

                        wrapper.appendChild(pre);
                        wrapper.appendChild(copyBtn);
                        bubble.appendChild(wrapper);

                        lastIndex = codeBlockRegex.lastIndex;
                    }
                    const remainingText = messageText.slice(lastIndex);
                    if (remainingText) {
                        const textNode = document.createElement('div');
                        textNode.className = 'main-message-text';
                        textNode.textContent = remainingText;
                        bubble.appendChild(textNode);
                    }

                } else if (messageText) {
                    // 2c. 如果主消息是纯文本
                    const textNode = document.createElement('div');
                    textNode.className = 'main-message-text';
                    textNode.textContent = messageText;
                    bubble.appendChild(textNode);
                }

                return bubble;
            }


            // 步骤一：将 const 修改为 let，以便后续从 localStorage 加载数据
            let contactsData = [
                {id: '1', name: '代码助手', avatar: '🤖', status: '为您服务'},
            ];
            // ========== 新增：独立的密友数据数组 ==========
            let sweetheartContactsData = [
                {id: '1', name: '代码助手', avatar: '🤖', status: '为您服务'},
                {id: '2', name: '平平无奇的朋友', avatar: '😊', status: '你好呀'},
                {
                    id: 'SH_default_001',
                    name: '贴心小助手',
                    status: '随时准备好聆听你的心事~',
                    avatar: '💖',
                    personality: '温柔体贴',
                    relationship: '最好的朋友',
                    boundWorldbooks: []
                }
            ];


            // ========== 世界系统数据 ==========
            let worldsData = []; // 存储所有世界
            let currentWorldId = null; // 当前选中的世界ID

            // ========== 世界系统功能 ==========

            /**
             * 打开世界选择页面
             */
            function openWorldSelect() {
                document.getElementById('worldSelectPage').classList.add('show');
                renderWorldList();
            }

            /**
             * 关闭世界选择页面
             */
            function closeWorldSelect() {
                document.getElementById('worldSelectPage').classList.remove('show');

                // 【核心修复】关闭世界选择页面意味着返回主桌面，
                // 此时应清除当前的世界ID，避免影响其他页面的返回逻辑。
                currentWorldId = null;
                localStorage.removeItem('currentWorldId');
            }


            /**
             * 渲染世界列表
             */
            function renderWorldList() {
                const container = document.getElementById('worldSelectContent');
                container.innerHTML = '';
                saveWorldsData();


                // 渲染现有世界
                worldsData.forEach(world => {
                    const card = document.createElement('div');
                    card.className = 'world-card';
                    card.onclick = () => enterWorld(world.id);

                    // 获取该世界的联系人数量
                    const contactCount = world.contacts ? world.contacts.length : 0;

                    card.innerHTML = `
            <div class="world-card-icon">${world.icon || '🌍'}</div>
            <div class="world-card-name">${escapeHTML(world.name)}</div>
            <div class="world-card-desc">${escapeHTML(world.description || '暂无描述')}</div>
            <div class="world-card-contacts">${contactCount} 个联系人</div>
        `;

                    container.appendChild(card);
                });

                // 添加"新建世界"卡片
                const newCard = document.createElement('div');
                newCard.className = 'world-card new-world';
                newCard.onclick = openNewWorldModal;
                newCard.innerHTML = `
        <div class="world-card-icon">➕</div>
        <div class="world-card-name">新建世界</div>
        <div class="world-card-desc">创建一个全新的世界</div>
    `;
                container.appendChild(newCard);
            }

            /**
             * 进入指定世界（打开该世界的通讯录）
             */
            function enterWorld(worldId) {
                currentWorldId = worldId;
                localStorage.setItem('currentWorldId', worldId);

                closeWorldSelect();

                // 延迟打开密友列表，让关闭动画完成
                setTimeout(() => {
                    openSweetheartList();
                }, 300);
            }


            /**
             * 打开指定世界的通讯录
             */
            function openWorldContacts(worldId) {
                const world = worldsData.find(w => w.id === worldId);
                if (!world) return;

                // 你可以在这里更新contactsPage的标题，例如显示世界名称
                // 假设contactsPage的header有一个id为'contactsTitle'的元素
                // const contactsTitleEl = document.getElementById('contactsTitle');
                // if (contactsTitleEl) contactsTitleEl.textContent = world.name + '通讯录';

                document.getElementById('contactsPage').classList.add('show');

                // 根据世界的联系人ID列表，筛选出对应的联系人
                const worldContacts = contactsData.filter(contact =>
                    world.contacts && world.contacts.includes(String(contact.id))
                );

                renderContacts(worldContacts); // 渲染该世界的联系人
            }


            /**
             * 打开新建世界弹窗
             */
            function openNewWorldModal() {
                document.getElementById('worldNameInput').value = '';
                document.getElementById('worldDescInput').value = '';
                document.getElementById('worldWorldbooksList').style.display = 'none';
                document.getElementById('world-wb-arrow').classList.remove('open');

                // V V V 新增的重置代码 V V V
                document.getElementById('worldMapPreview').src = '';
                document.getElementById('worldMapPreview').style.display = 'none';
                document.getElementById('worldMapPlaceholder').style.display = 'block';
                document.getElementById('worldMapOptions').style.display = 'none';
                document.getElementById('worldMapInput').value = '';
                // ^ ^ ^ 新增的重置代码 ^ ^ ^

                document.getElementById('newWorldModal').classList.add('show');
                renderWorldWorldbooksList(); // 渲染可绑定的世界书列表
            }


            /**
             * 关闭新建世界弹窗
             */
            function closeNewWorldModal() {
                document.getElementById('newWorldModal').classList.remove('show');
            }

            /**
             * 切换世界书列表的展开/收起
             */
            function toggleWorldWorldbooks() {
                const list = document.getElementById('worldWorldbooksList');
                const arrow = document.getElementById('world-wb-arrow');

                if (list.style.display === 'none') {
                    renderWorldWorldbooksList();
                    list.style.display = 'block';
                    arrow.classList.add('open');
                } else {
                    list.style.display = 'none';
                    arrow.classList.remove('open');
                }
            }

            /**
             * 渲染世界书复选框列表
             */
            function renderWorldWorldbooksList() {
                const container = document.getElementById('worldWorldbooksList');

                if (worldbookData.length === 0) {
                    container.innerHTML = '<div style="text-align: center; color: #7FB5D1; padding: 20px; font-size: 13px;">还没有世界书哦~</div>';
                    return;
                }

                container.innerHTML = '';

                worldbookData.forEach(wb => {
                    const item = document.createElement('div');
                    item.className = 'world-wb-item';

                    const checkbox = document.createElement('input');
                    checkbox.type = 'checkbox';
                    checkbox.id = `world-wb-${wb.id}`;
                    checkbox.value = wb.id;

                    const label = document.createElement('label');
                    label.htmlFor = `world-wb-${wb.id}`;
                    label.textContent = wb.title;

                    item.appendChild(checkbox);
                    item.appendChild(label);
                    container.appendChild(item);
                });
            }

            /* ========== 新增：世界地图功能相关函数 ========== */

            /**
             * 切换地图选项的显示/隐藏
             */
            function toggleWorldMapOptions() {
                const optionsEl = document.getElementById('worldMapOptions');
                if (optionsEl.style.display === 'flex') {
                    optionsEl.style.display = 'none';
                } else {
                    optionsEl.style.display = 'flex';
                }
            }

            /**
             * 选择默认地图（当前为占位功能）
             */
            function selectDefaultMap() {
                // 这里可以扩展为显示一个包含多张默认地图的弹窗
                const defaultMapUrl = 'https://i.pinimg.com/originals/b6/29/79/b629796791c13a48e7787f0b5d92ac87.png'; // 示例默认地图
                const previewImg = document.getElementById('worldMapPreview');
                const placeholder = document.getElementById('worldMapPlaceholder');

                previewImg.src = defaultMapUrl;
                previewImg.style.display = 'block';
                placeholder.style.display = 'none';

                // 选择后隐藏选项
                document.getElementById('worldMapOptions').style.display = 'none';
                showSuccessModal('选择成功', '已应用默认地图。');
            }

            /**
             * 处理用户上传的地图图片
             * @param {Event} event - 文件输入框的 change 事件
             */
            function handleWorldMapUpload(event) {
                const file = event.target.files[0];
                if (!file) return;

                // 使用 FileReader 将图片文件转为 Base64 URL
                const reader = new FileReader();
                reader.onload = function (e) {
                    const previewImg = document.getElementById('worldMapPreview');
                    const placeholder = document.getElementById('worldMapPlaceholder');

                    previewImg.src = e.target.result;
                    previewImg.style.display = 'block';
                    placeholder.style.display = 'none';

                    // 上传后隐藏选项
                    document.getElementById('worldMapOptions').style.display = 'none';
                };
                reader.readAsDataURL(file);
            }

            /**
             * 保存新建的世界
             */
            function saveNewWorld() {
                const name = document.getElementById('worldNameInput').value.trim();

                if (!name) {
                    alert('请填写世界名称！');
                    return;
                }

                const description = document.getElementById('worldDescInput').value.trim();

                // V V V 新增的获取地图代码 V V V
                const mapUrl = document.getElementById('worldMapPreview').src;
                // ^ ^ ^ 新增的获取地图代码 ^ ^ ^

                // 获取选中的世界书
                const selectedWorldbooks = [];
                document.querySelectorAll('.world-wb-item input[type="checkbox"]:checked').forEach(cb => {
                    selectedWorldbooks.push(cb.value);
                });

                const newWorld = {
                    id: 'WORLD_' + Date.now(),
                    name,
                    description,
                    mapUrl: mapUrl.includes('base64') || mapUrl.includes('pinimg.com') ? mapUrl : '', // 仅当有有效图片时才保存
                    icon: '🌍',
                    contacts: [], // 新世界默认没有联系人
                    worldbooks: selectedWorldbooks,
                    timestamp: Date.now()
                };

                worldsData.push(newWorld);
                saveWorldsData();

                closeNewWorldModal();
                renderWorldList(); // 重新渲染世界列表

                // 根据需求，新建世界后跳转到该世界的通讯录（空状态）
                showSuccessModal('创建成功', `世界"${name}"已创建！`);
                setTimeout(() => {
                    enterWorld(newWorld.id); // 直接进入新创建的世界
                }, 1000); // 稍微延迟一下，让成功提示显示
            }

            /**
             * 保存世界数据到localStorage
             */
            function saveWorldsData() {
                try {
                    localStorage.setItem('phoneWorldsData', JSON.stringify(worldsData));
                } catch (e) {
                    console.error('保存世界数据失败:', e);
                }
            }

            /**
             * 从localStorage加载世界数据
             */
            function loadWorldsData() {
                try {
                    const saved = localStorage.getItem('phoneWorldsData');
                    if (saved) {
                        worldsData = JSON.parse(saved);
                        console.log('成功加载世界数据，共', worldsData.length, '个世界');
                    } else {
                        // 如果没有世界数据，则初始化一个默认世界
                        worldsData.push({
                            id: 'DEFAULT_WORLD',
                            name: '一个平平无奇的世界',
                            description: '这是一个普通的世界',
                            icon: '🌏',
                            contacts: ['1', '2'], // 默认包含代码助手和另一个朋友
                            worldbooks: [],
                            timestamp: Date.now()
                        });
                        saveWorldsData(); // 立即保存到 localStorage
                        console.log('已初始化默认世界数据。');
                    }
                } catch (e) {
                    console.error('加载世界数据失败:', e);
                }
            }


            let currentChatContact = null;
            let currentQuoteData = null;

            async function updateBattery() {
                try {
                    if ('getBattery' in navigator) {
                        const battery = await navigator.getBattery();

                        const updateBatteryDisplay = () => {
                            const level = Math.round(battery.level * 100);
                            const charging = battery.charging;
                            document.querySelectorAll('.status-icons').forEach(iconGroup => {
                                const container = iconGroup.querySelector('.battery-container');
                                const levelBar = iconGroup.querySelector('.battery-level');
                                const text = iconGroup.querySelector('.battery-text');
                                if (container && levelBar && text) {
                                    text.textContent = `${level}%`;

                                    container.classList.toggle('charging', charging);

                                    levelBar.style.width = `${level * 0.85}%`;

                                    levelBar.classList.toggle('low', level <= 20 && !charging);
                                }
                            });

                            console.log(`电量已更新: ${level}% ${charging ? '(充电中)' : ''}`);
                        };

                        updateBatteryDisplay();

                        battery.addEventListener('levelchange', updateBatteryDisplay);
                        battery.addEventListener('chargingchange', updateBatteryDisplay);

                    } else {
                        console.warn('浏览器不支持 Battery API');
                    }
                } catch (error) {
                    console.error('获取电量失败:', error);
                }
            }


            // ========== 开始：请用这个【修正版】函数替换旧的 updateLocation 函数 ==========
            async function updateLocation() {
                if (locationMode !== 'real') return;
                // [修正] 原来的选择器 '.weather-card .location' 是错误的，这里修正为 '.location-text'
                const locationElement = document.querySelector('.location-text');
                if (!locationElement) {
                    // [优化] 增加错误提示，方便调试
                    console.error("代码错误：未能找到用于显示位置的 .location-text 元素。");
                    return;
                }

                try {
                    if (!navigator.geolocation) {
                        console.warn('浏览器不支持地理定位');
                        locationElement.textContent = '无法定位';
                        return;
                    }

                    navigator.geolocation.getCurrentPosition(
                        async (position) => {
                            const lat = position.coords.latitude;
                            const lon = position.coords.longitude;

                            console.log('成功获取位置坐标:', lat, lon);

                            // 备注：这里使用了高德API，你需要替换 'YOUR_AMAP_KEY' 为你自己的有效Key
                            try {
                                const response = await fetch(
                                    `https://restapi.amap.com/v3/geocode/regeo?location=${lon},${lat}&key=66dfab01a25cfe9002858086538601e6&extensions=base`
                                );

                                if (response.ok) {
                                    const data = await response.json();
                                    if (data.status === '1' && data.regeocode) {
                                        const address = data.regeocode.addressComponent;
                                        const district = address.district || address.city || '未知位置';
                                        locationElement.textContent = district; // 更新UI
                                        console.log('高德地址解析成功:', district);
                                        return; // 成功后提前退出
                                    }
                                }
                            } catch (error) {
                                console.warn('高德API解析失败, 将尝试使用备用方案。错误:', error);
                            }

                            // 如果高德API失败，则使用备用方案 (OpenStreetMap)
                            try {
                                const response = await fetch(
                                    `https://nominatim.openstreetmap.org/reverse?format=json&lat=${lat}&lon=${lon}&accept-language=zh-CN`
                                );

                                if (response.ok) {
                                    const data = await response.json();
                                    const address = data.address;
                                    const location = address.city || address.town || address.village ||
                                        address.county || address.state || '未知位置';
                                    locationElement.textContent = location; // 更新UI
                                    console.log('备用方案地址解析成功:', location);
                                }
                            } catch (error) {
                                console.error('备用方案地址解析也失败了:', error);
                                locationElement.textContent = `坐标:${lat.toFixed(2)},${lon.toFixed(2)}`;
                            }
                        },
                        (error) => {
                            console.warn('获取地理位置失败:', error.message);
                            if (error.code === 1) { // PERMISSION_DENIED
                                locationElement.textContent = '未授权定位';
                            } else {
                                locationElement.textContent = '定位失败';
                            }
                        }, {
                            enableHighAccuracy: false,
                            timeout: 10000,
                            maximumAge: 600000
                        }
                    );
                } catch (error) {
                    console.error('地理定位功能出现未知错误:', error);
                }
            }

            // ========== 结束：替换完成 ==========


            function toggleWeatherSelector(event) {
                event.stopPropagation();
                const popup = document.getElementById('weatherPopup');
                if (popup.style.display === 'none') {
                    popup.style.display = 'block';
                } else {
                    popup.style.display = 'none';
                }
            }

            function selectWeather(weatherType, event) {
                event.stopPropagation();

                const weatherIcons = {
                    sunny: '☀️',
                    cloudy: '☁️',
                    rainy: '🌧️',
                    snowy: '❄️'
                };

                const currentIcon = document.getElementById('currentWeatherIcon');
                if (currentIcon) {
                    currentIcon.textContent = weatherIcons[weatherType];
                }

                document.querySelectorAll('.weather-option').forEach(option => {
                    option.classList.remove('active');
                });

                const selectedOption = document.querySelector(`[data-weather="${weatherType}"]`);
                if (selectedOption) {
                    selectedOption.classList.add('active');
                }

                localStorage.setItem('selectedWeather', weatherType);

                document.getElementById('weatherPopup').style.display = 'none';

                console.log(`已选择天气: ${weatherType}`);
            }

            function editMood(event) {
                event.stopPropagation();

                const moodTextEl = document.getElementById('moodText');
                const currentMood = moodTextEl.classList.contains('empty') ? '' : moodTextEl.textContent;

                const newMood = prompt('输入你的心情：', currentMood);

                if (newMood !== null) {
                    if (newMood.trim() === '') {
                        moodTextEl.textContent = '点击填写心情...';
                        moodTextEl.classList.add('empty');
                    } else {
                        moodTextEl.textContent = newMood.trim();
                        moodTextEl.classList.remove('empty');
                    }

                    localStorage.setItem('userMood', newMood.trim());
                }
            }

            function loadSavedMoodAndWeather() {
                const weatherIcons = {
                    sunny: '☀️',
                    cloudy: '☁️',
                    rainy: '🌧️',
                    snowy: '❄️'
                };

                const savedMood = localStorage.getItem('userMood');
                const moodTextEl = document.getElementById('moodText');
                if (savedMood && moodTextEl) {
                    moodTextEl.textContent = savedMood;
                    moodTextEl.classList.remove('empty');
                }

                const savedWeather = localStorage.getItem('selectedWeather') || 'sunny';
                const currentIcon = document.getElementById('currentWeatherIcon');
                if (currentIcon) {
                    currentIcon.textContent = weatherIcons[savedWeather];
                }

                document.querySelectorAll('.weather-option').forEach(option => {
                    option.classList.remove('active');
                });
                const selectedOption = document.querySelector(`[data-weather="${savedWeather}"]`);
                if (selectedOption) {
                    selectedOption.classList.add('active');
                }
            }

            document.addEventListener('click', function (e) {
                const popup = document.getElementById('weatherPopup');
                const weatherDisplay = document.querySelector('.weather-display');
                if (popup && !popup.contains(e.target) && !weatherDisplay.contains(e.target)) {
                    popup.style.display = 'none';
                }
            });

            function initSupabaseClient() {
                const {supabaseUrl, supabaseKey} = globalConfig.database;

                if (!supabaseUrl || !supabaseKey) {
                    return null;
                }

                globalConfig.database.client = {
                    from: (table) => ({
                        select: () => Promise.resolve({data: [], error: null}),
                        insert: (data) => Promise.resolve({data, error: null}),
                        update: (data) => Promise.resolve({data, error: null}),
                        delete: () => Promise.resolve({data: null, error: null})
                    }),
                    storage: {
                        from: (bucket) => ({
                            upload: (path, file) => {
                                console.log(`上传文件到: ${bucket}/${path}`);
                                return Promise.resolve({
                                    data: {path: `${bucket}/${path}`},
                                    error: null
                                });
                            },
                            getPublicUrl: (path) => ({
                                data: {publicUrl: `https://example.supabase.co/storage/v1/object/public/${path}`}
                            })
                        })
                    }
                };

                return globalConfig.database.client;
            }

            const dbAPI = {
                async saveData(data) {
                    if (!globalConfig.database.client) {
                        console.warn('数据库未初始化，请先配置Supabase');
                        return {success: false, message: '数据库未初始化'};
                    }

                    try {
                        const {data: result, error} = await globalConfig.database.client
                            .from(globalConfig.database.tableName)
                            .insert(data);

                        if (error) throw error;
                        return {success: true, data: result};
                    } catch (error) {
                        console.error('保存数据失败:', error);
                        return {success: false, message: error.message};
                    }
                },

                async getData(filters = {}) {
                    if (!globalConfig.database.client) {
                        console.warn('数据库未初始化');
                        return {success: false, data: []};
                    }

                    try {
                        const {data, error} = await globalConfig.database.client
                            .from(globalConfig.database.tableName)
                            .select();

                        if (error) throw error;
                        return {success: true, data};
                    } catch (error) {
                        console.error('获取数据失败:', error);
                        return {success: false, data: []};
                    }
                }
            };

            const storageAPI = {
                async uploadFile(file, customPath = '') {
                    if (!globalConfig.database.client) {
                        console.warn('云存储未初始化，请先配置Supabase');
                        return {success: false, url: null};
                    }

                    try {
                        const {bucketName, uploadPath} = globalConfig.storage;
                        const filePath = `${uploadPath}${customPath || file.name}`;

                        const {data, error} = await globalConfig.database.client.storage
                            .from(bucketName)
                            .upload(filePath, file);

                        if (error) throw error;

                        const {data: urlData} = globalConfig.database.client.storage
                            .from(bucketName)
                            .getPublicUrl(filePath);

                        console.log('文件上传成功:', urlData.publicUrl);
                        return {success: true, url: urlData.publicUrl};
                    } catch (error) {
                        console.error('文件上传失败:', error);
                        return {success: false, url: null, message: error.message};
                    }
                }
            };

            const appsPage1 = [
                {
                    id: 'worldbook',
                    icon: 'https://s3plus.meituan.net/opapisdk/op_ticket_885190757_1760105951573_qdqqd_4zhn48.png',
                    label: '世界书',
                    row: 0,
                    col: 0,
                    clickable: true
                },
                {
                    id: 'photo',
                    icon: 'https://s3plus.meituan.net/opapisdk/op_ticket_885190757_1760112395282_qdqqd_jxwwfg.png',
                    label: '相册',
                    row: 0,
                    col: 1
                },
                {
                    id: 'calc',
                    icon: 'https://s3plus.meituan.net/opapisdk/op_ticket_885190757_1760107619286_qdqqd_tzxf3r.png',
                    label: '账单',
                    row: 0,
                    col: 2
                },
                {
                    id: 'store',
                    icon: 'https://s3plus.meituan.net/opapisdk/op_ticket_885190757_1760103537174_qdqqd_18w1fw.png',
                    label: '切换手机',
                    row: 0,
                    col: 3
                },
                {
                    id: 'settings',
                    icon: 'https://s3plus.meituan.net/opapisdk/op_ticket_885190757_1760110940876_qdqqd_ev1xec.png',
                    label: '设置',
                    row: 1,
                    col: 0,
                    clickable: true
                },
                {
                    id: 'calendar',
                    icon: 'https://s3plus.meituan.net/opapisdk/op_ticket_885190757_1760110811117_qdqqd_gsrlfw.png',
                    label: '日历',
                    row: 1,
                    col: 1
                },
                {
                    id: 'note',
                    icon: 'https://s3plus.meituan.net/opapisdk/op_ticket_885190757_1760105743965_qdqqd_p5o31m.png',
                    label: '日记',
                    row: 1,
                    col: 2
                },
                {
                    id: 'clock',
                    icon: 'https://s3plus.meituan.net/opapisdk/op_ticket_885190757_1760107999099_qdqqd_h6se19.png',
                    label: '时钟',
                    row: 1,
                    col: 3
                }
            ];


            // ========== 开始：用这个新版本替换旧的 appsPage2 数组 ==========
            const appsPage2 = [
                {
                    id: 'media_reading',
                    label: '影音阅读',
                    isFolder: true,
                    icons: ['https://s3plus.meituan.net/opapisdk/op_ticket_885190757_1760115843325_qdqqd_69tlcj.png', 'https://s3plus.meituan.net/opapisdk/op_ticket_885190757_1760117195210_qdqqd_k1cy4r.png', 'https://s3plus.meituan.net/opapisdk/op_ticket_885190757_1760115791541_qdqqd_x3y0wt.png'], // 合并后的3个图标
                    row: 0,
                    col: 0
                },
                {
                    id: 'entertainment',
                    label: 'entertainment',
                    isFolder: true,
                    icons: ['https://s3plus.meituan.net/opapisdk/op_ticket_885190757_1760096293687_qdqqd_xti5y9.png', 'https://s3plus.meituan.net/opapisdk/op_ticket_885190757_1760117261962_qdqqd_55pbz9.png', 'https://s3plus.meituan.net/opapisdk/op_ticket_885190757_1760117296583_qdqqd_i0fpo6.png'], // 保留并确保3个图标
                    row: 0,
                    col: 1
                },
                {
                    id: 'home',
                    label: '居家生活',
                    isFolder: true,
                    icons: ['https://s3plus.meituan.net/opapisdk/op_ticket_885190757_1760095662621_qdqqd_b8q0r7.png', 'https://s3plus.meituan.net/opapisdk/op_ticket_885190757_1760107551403_qdqqd_1s7h4p.png'], // 精简为2个图标
                    row: 0,
                    col: 2
                },
                {
                    id: 'purchase',
                    label: 'purchase',
                    isFolder: true,
                    // 补充为2个图标
                    icons: ['https://s3plus.meituan.net/opapisdk/op_ticket_885190757_1760106251908_qdqqd_s71t7l.png', 'https://s3plus.meituan.net/opapisdk/op_ticket_885190757_1760106346391_qdqqd_ro4t40.png'],
                    row: 0,
                    col: 3
                },
                {
                    id: 'widget2',
                    label: 'Widget',
                    isWidget: true,
                    row: 1, // 调整了行号以适应新布局
                    col: 0,
                    colspan: 4,
                    rowspan: 2
                }
            ];
            // ========== 结束：替换完成 ==========

            const state = {
                currentPage: 1,
                draggedElement: null,
                isDragging: false,
                isEditMode: false,
                hasDragged: false,
                dragStart: {x: 0, y: 0},
                dragOffset: {x: 0, y: 0},
                longPressTimer: null,
                swipeStart: {x: 0, time: 0},
                isSwipingPage: false,
                initialTransform: 0,
                swipeMoveScheduled: false, // <--- 新增
                lastSwipeTranslateX: 0,
                appLayouts: {
                    page1: appsPage1,
                    page2: appsPage2
                },
                lastDragEndTime: 0, // ✅ 新增：记录最后一次拖动结束的时间
                isDraggingFromDock: false  // 🔧 新增这一行
            };


            const screen = document.getElementById('screen');
            const pagesWrapper = document.getElementById('pagesWrapper');

            const getTouch = (e) => e.touches?.[0] || e;
            const getChangedTouch = (e) => e.changedTouches?.[0] || e;

            function positionElement(el, row, col, colspan = 1, rowspan = 1) {
                const ROW_HEIGHT_PX = 94;
                const GAP_PX = 14;
                const leftPercent = col * 25;
                const widthPercent = colspan * 25;
                const topPx = row * (ROW_HEIGHT_PX + GAP_PX);
                const heightPx = (rowspan * ROW_HEIGHT_PX) + ((rowspan - 1) * GAP_PX);
                Object.assign(el.style, {
                    left: `${leftPercent}%`,
                    width: `${widthPercent}%`,
                    top: `${topPx}px`,
                    height: `${heightPx}px`
                });
            }


            function showEditHint(show) {
                const hint = document.getElementById(state.currentPage === 1 ? 'editHint1' : 'editHint2');
                hint.classList.toggle('show', show);
            }

            function showDeleteButtons(show) {
                const timeCard = document.getElementById('timeCard');
                if (timeCard) {
                    timeCard.classList.toggle('show-delete', show);
                }

                const weatherCard = document.getElementById('weatherCard');
                if (weatherCard) {
                    weatherCard.classList.toggle('show-delete', show);
                }

                // ✅ 修复：同时选择 .widget 和 .cat-widget
                document.querySelectorAll('.widget, .cat-widget').forEach(widget => {
                    widget.classList.toggle('show-delete', show);
                });
            }

            function exitEditMode() {
                if (state.isEditMode && !state.isDragging) {
                    state.isEditMode = false;
                    showEditHint(false);
                    showDeleteButtons(false);
                    state.hasDragged = false;
                }
            }

            function openSettings() {
                document.getElementById('settingsPage').classList.add('show');
            }

            function closeSettings() {
                document.getElementById('settingsPage').classList.remove('show');
            }

            function openApiConfig() {
                document.getElementById('apiConfig').classList.add('show');
                renderApiConfigs();
            }

            function closeApiConfig() {
                document.getElementById('apiConfig').classList.remove('show');
            }

            function renderApiConfigs() {
                const list = document.getElementById('apiConfigList');
                list.innerHTML = '';

                globalConfig.apiConfigs.forEach((config, index) => {
                    const item = document.createElement('div');
                    item.className = 'api-config-item';
                    if (globalConfig.activeApiConfig === index) {
                        item.classList.add('active');
                    }

                    item.innerHTML = `
            <div class="config-details">
                <div class="config-name">${config.name}</div>
                <div class="config-url">${config.url}</div>
            </div>
            <button class="delete-config-btn" title="删除这个配置">×</button>
        `;

                    item.querySelector('.config-details').onclick = () => applyApiConfig(index);

                    const deleteBtn = item.querySelector('.delete-config-btn');
                    deleteBtn.onclick = (event) => {
                        event.stopPropagation();
                        deleteApiConfig(index);
                    };

                    list.appendChild(item);
                });

                const addBtn = document.createElement('button');
                addBtn.className = 'add-new-btn';
                addBtn.textContent = '+ 新增配置';
                addBtn.onclick = () => {
                    if (globalConfig.activeApiConfig !== null) {
                        document.querySelector('.api-config-item.active')?.classList.remove('active');
                        globalConfig.activeApiConfig = null;
                        saveGlobalConfig();
                    }
                    clearApiForm();
                };
                list.appendChild(addBtn);
            }


            function clearApiForm() {
                document.getElementById('configName').value = '';
                document.getElementById('apiUrl').value = '';
                document.getElementById('apiKey').value = '';
                document.getElementById('modelSelect').innerHTML = '<option value="">请先拉取模型列表</option>';
                showApiStatus('', '');
            }

            async function testConnection() {
                const url = document.getElementById('apiUrl').value;
                const key = document.getElementById('apiKey').value;

                if (!url || !key) {
                    showApiStatus('请填写URL和Key', 'error');
                    return;
                }

                showApiStatus('正在测试连接...', '');

                setTimeout(() => {
                    showApiStatus('连接成功', 'success');
                }, 1000);
            }

            async function fetchModels() {
                const url = document.getElementById('apiUrl').value.trim();
                const key = document.getElementById('apiKey').value.trim();

                if (!url || !key) {
                    showApiStatus('请填写有效的API URL和API Key', 'error');
                    return;
                }

                showApiStatus('正在向服务器请求模型列表...', '');
                const modelSelect = document.getElementById('modelSelect');
                modelSelect.innerHTML = '<option value="">正在拉取...</option>';
                modelSelect.disabled = true;

                try {
                    const response = await fetch(`${url}/models`, {
                        method: 'GET',
                        headers: {
                            'Authorization': `Bearer ${key}`
                        }
                    });

                    if (!response.ok) {
                        const errorData = await response.json().catch(() => null);
                        const errorMessage = errorData?.error?.message || `服务器返回错误: ${response.status}`;
                        throw new Error(errorMessage);
                    }

                    const data = await response.json();

                    const models = (data.data || data).map(model => model.id).filter(id => id);

                    if (models.length > 0) {
                        modelSelect.innerHTML = models.map(m => `<option value="${m}">${m}</option>`).join('');
                        showApiStatus(`成功拉取 ${models.length} 个模型！`, 'success');
                    } else {
                        modelSelect.innerHTML = '<option value="">未找到可用模型</option>';
                        showApiStatus('API连接成功，但未返回任何模型列表。', 'error');
                    }

                } catch (error) {
                    console.error('拉取模型失败:', error);
                    modelSelect.innerHTML = '<option value="">拉取失败</option>';
                    showApiStatus(`拉取失败: ${error.message}。请检查URL、Key和网络连接。`, 'error');
                } finally {
                    modelSelect.disabled = false;
                }
            }


            function saveApiConfig() {
                const name = document.getElementById('configName').value.trim();
                const url = document.getElementById('apiUrl').value.trim();
                const key = document.getElementById('apiKey').value.trim();
                const model = document.getElementById('modelSelect').value;

                if (!name || !url || !key) {
                    showApiStatus('请填写所有必填项', 'error');
                    return;
                }

                const configData = {name, url, key, model};

                if (globalConfig.activeApiConfig !== null && globalConfig.apiConfigs[globalConfig.activeApiConfig]) {
                    globalConfig.apiConfigs[globalConfig.activeApiConfig] = configData;
                    showSuccessModal('更新成功', `配置 "${name}" 已被更新！`);
                } else {
                    globalConfig.apiConfigs.push(configData);
                    globalConfig.activeApiConfig = globalConfig.apiConfigs.length - 1;
                    showSuccessModal('保存成功', `配置 "${name}" 已被添加并激活！`);
                }

                saveGlobalConfig();
                renderApiConfigs();
            }


            function applyApiConfig(index) {
                globalConfig.activeApiConfig = index;
                const config = globalConfig.apiConfigs[index];

                document.getElementById('configName').value = config.name;
                document.getElementById('apiUrl').value = config.url;
                document.getElementById('apiKey').value = config.key;
                if (config.model) {
                    document.getElementById('modelSelect').innerHTML = `<option value="${config.model}">${config.model}</option>`;
                }

                showApiStatus(`已应用配置: ${config.name}`, 'success');
                renderApiConfigs();
            }

            function showApiStatus(message, type) {
                const status = document.getElementById('apiStatus');
                status.textContent = message;
                status.style.color = type === 'error' ? '#dc3545' : '#28a745';
            }

            function openConfig(type) {
                const configId = type === 'database' ? 'databaseConfig' : 'storageConfig';
                document.getElementById(configId).classList.add('show');

                if (type === 'database') {
                    document.getElementById('supabaseUrl').value = globalConfig.database.supabaseUrl;
                    document.getElementById('supabaseKey').value = globalConfig.database.supabaseKey;
                    document.getElementById('tableName').value = globalConfig.database.tableName;
                } else {
                    document.getElementById('bucketName').value = globalConfig.storage.bucketName;
                    document.getElementById('uploadPath').value = globalConfig.storage.uploadPath;
                    document.getElementById('maxFileSize').value = globalConfig.storage.maxFileSize;
                }
            }

            function closeConfig(type) {
                const configId = type === 'database' ? 'databaseConfig' : 'storageConfig';
                document.getElementById(configId).classList.remove('show');
            }

            function saveConfig(type) {
                if (type === 'database') {
                    globalConfig.database.supabaseUrl = document.getElementById('supabaseUrl').value;
                    globalConfig.database.supabaseKey = document.getElementById('supabaseKey').value;
                    globalConfig.database.tableName = document.getElementById('tableName').value;

                    const client = initSupabaseClient();
                    if (client) {
                        const status = document.getElementById('dbStatus');
                        status.textContent = '数据库已初始化，可以使用 dbAPI 进行操作';
                        status.style.color = '#28a745';

                        console.log('Supabase已初始化！');
                        console.log('使用方法：');
                        console.log('1. 保存数据: await dbAPI.saveData({ key: "value" })');
                        console.log('2. 获取数据: await dbAPI.getData()');
                    } else {
                        const status = document.getElementById('dbStatus');
                        status.textContent = '请填写完整的URL和Key';
                        status.style.color = '#dc3545';
                    }
                } else {
                    globalConfig.storage.bucketName = document.getElementById('bucketName').value;
                    globalConfig.storage.uploadPath = document.getElementById('uploadPath').value;
                    globalConfig.storage.maxFileSize = document.getElementById('maxFileSize').value;

                    const status = document.getElementById('storageStatus');
                    status.textContent = '云存储配置已保存，上传文件时自动使用此配置';
                    status.style.color = '#28a745';

                    console.log('云存储已配置！');
                    console.log('使用方法：');
                    console.log('await storageAPI.uploadFile(file, "custom-path.png")');
                }

                setTimeout(() => closeConfig(type), 2000);
            }

            function openBeautify() {
                document.getElementById('beautifyPage').classList.add('show');
                renderAppPreviews();
                renderWallpaperThumbnails();
                const currentWallpaper = localStorage.getItem('phoneWallpaper');
                updateWallpaperActiveState(currentWallpaper);
            }


            function closeBeautify() {
                document.getElementById('beautifyPage').classList.remove('show');
            }

            function openWidgetManager() {
                document.getElementById('widgetManager').classList.add('show');
                renderSavedWidgets();
            }

            function closeWidgetManager() {
                document.getElementById('widgetManager').classList.remove('show');
            }

            function renderSavedWidgets() {
                const container = document.getElementById('savedWidgetsList');
                container.innerHTML = '';

                if (globalConfig.savedWidgets.length === 0) {
                    container.innerHTML = '<div style="text-align: center; padding: 40px; color: #999;">暂无已删除的组件</div>';
                    return;
                }

                globalConfig.savedWidgets.forEach((widget, index) => {
                    const item = document.createElement('div');
                    item.className = 'saved-widget-item';
                    item.innerHTML = `
                    <div class="saved-widget-name">${widget.name}</div>
                    <div style="display: flex; gap: 8px; margin-top: 8px;">
                        <button class="restore-btn" onclick="restoreWidget(${index})">恢复到桌面</button>
                        <button class="delete-saved-btn" onclick="deleteSavedWidget(${index})">永久删除</button>
                    </div>
                `;
                    container.appendChild(item);
                });
            }

            function restoreWidget(index) {
                const widget = globalConfig.savedWidgets[index];
                if (!widget) return;

                if (widget.type === 'time') {
                    const section = document.querySelector('.time-weather-section');
                    section.insertAdjacentHTML('afterbegin', widget.html);
                } else if (widget.type === 'weather') {
                    const section = document.querySelector('.time-weather-section');
                    const timeCard = document.getElementById('timeCard');
                    if (timeCard) {
                        timeCard.insertAdjacentHTML('afterend', widget.html);
                    } else {
                        section.insertAdjacentHTML('beforeend', widget.html);
                    }
                } else if (widget.type === 'widget') {
                    const pageNum = widget.id.includes('widget2') ? 2 : 1;
                    const grid = document.getElementById(`grid${pageNum}`);
                    grid.insertAdjacentHTML('beforeend', widget.html);

                    const restoredElement = grid.querySelector(`[data-id="${widget.id}"]`);
                    if (restoredElement) {
                        addDragListeners(restoredElement, false);
                    }
                }

                const deletedComponents = JSON.parse(localStorage.getItem('deletedComponents') || '[]');
                const componentIndex = deletedComponents.indexOf(widget.id);

                if (componentIndex > -1) {
                    deletedComponents.splice(componentIndex, 1);
                }

                globalConfig.savedWidgets.splice(index, 1);

                try {
                    localStorage.setItem('deletedComponents', JSON.stringify(deletedComponents));
                    localStorage.setItem('savedWidgets', JSON.stringify(globalConfig.savedWidgets));
                    console.log(`${widget.name} 已恢复到桌面`);
                } catch (e) {
                    console.error('保存数据失败:', e);
                }

                renderSavedWidgets();
            }

            function deleteSavedWidget(index) {
                const widget = globalConfig.savedWidgets[index];
                if (!widget) return;

                if (confirm(`确定要永久删除"${widget.name}"吗？此操作无法撤销。`)) {
                    globalConfig.savedWidgets.splice(index, 1);

                    localStorage.setItem('savedWidgets', JSON.stringify(globalConfig.savedWidgets));

                    renderSavedWidgets();

                    console.log(`${widget.name} 已永久删除`);
                }
            }

            function openContacts() {
                document.getElementById('contactsPage').classList.add('show');
                renderContacts(contactsData);
            }

            function closeContacts() {
                document.getElementById('contactsPage').classList.remove('show');
                document.getElementById('contactsSearch').value = '';

                // 如果是从某个世界进入通讯录的，返回时应该回到世界选择页面
                if (currentWorldId) {
                    // 延迟一下，让通讯录关闭动画完成
                    setTimeout(() => {
                        openWorldSelect();
                        currentWorldId = null; // 清除当前世界ID
                        localStorage.removeItem('currentWorldId'); // 清除本地存储
                    }, 300);
                }
            }


            // ========== 开始：请粘贴这段全新的 JavaScript 代码 ==========

            function toggleContactMenu(event) {
                // 阻止事件冒泡，防止点击事件被页面的其他部分捕获，导致菜单立即关闭
                event.stopPropagation();

                const menu = document.getElementById('contactMenu');
                // 使用 classList.toggle() 来切换 'show' 类
                // 如果菜单没有 'show' 类，就给它加上；如果已经有了，就把它移除。
                // 这正是“切换”的含义。
                menu.classList.toggle('show');
            }

            // ========== 结束：粘贴代码 ==========


            // ========== 开始：请用这个【修正版】函数替换旧的 renderContacts 函数 ==========
            function renderContacts(contacts) {
                const container = document.getElementById('contactsList');
                const chatHistory = JSON.parse(localStorage.getItem('phoneChatHistory') || '{}');

                container.innerHTML = '';
                if (contacts.length === 0) {
                    container.innerHTML = '<div style="text-align: center; padding: 40px; color: #999;">未找到联系人</div>';
                    return;
                }

                contacts.forEach(contact => {
                    const item = document.createElement('div');
                    item.className = 'contact-item';

                    const contactMessages = chatHistory[contact.id] || [];
                    let lastMessageText = contact.status;
                    if (contactMessages.length > 0) {
                        const lastMessage = contactMessages[contactMessages.length - 1];
                        // 修正：如果最后一条消息是图片，显示占位符
                        if (lastMessage.text && lastMessage.text.includes('<img')) {
                            lastMessageText = '[图片]';
                        } else {
                            lastMessageText = lastMessage.text;
                        }
                    }

                    // --- ↓↓↓ 核心修正点 ↓↓↓ ---
                    // 1. 判断头像是 URL 还是 Emoji
                    const isUrl = contact.avatar && (String(contact.avatar).startsWith('http') || String(contact.avatar).startsWith('data:'));

                    // 2. 根据判断结果生成不同的 HTML
                    // 修正示例
                    const avatarContent = isUrl
                        ? `<div class="contact-avatar"><img src="${contact.avatar}" alt="${escapeHTML(contact.name)}"></div>`
                        : `<div class="contact-avatar">${escapeHTML(contact.avatar)}</div>`;


                    item.innerHTML = `
            ${avatarContent}
            <div class="contact-info">
                <div class="contact-name">${escapeHTML(contact.name)}</div>
                <div class="contact-status">${escapeHTML(lastMessageText)}</div>
            </div>
            ${contact.badge > 0 ? `<div class="contact-badge">${contact.badge}</div>` : ''}
        `;

                    item.style.cursor = 'pointer';
                    item.onclick = () => openChat(contact);
                    container.appendChild(item);
                });
            }

            function createNewContact() {
                const menu = document.getElementById('contactMenu');
                if (menu) menu.classList.remove('show');

                // 获取弹窗元素
                const modal = document.getElementById('characterCardModal');
                // 生成新ID并存储
                const newId = 'ID' + Math.floor(100000 + Math.random() * 900000);
                modal.dataset.editingId = newId;

                // 如果当前有选中的世界，则标记联系人属于该世界
                if (currentWorldId) {
                    modal.dataset.currentWorldId = currentWorldId;
                } else {
                    modal.removeAttribute('data-currentWorldId');
                }

                // --- 重置表单 (逻辑不变) ---
                document.getElementById('char-name').value = '';
                document.getElementById('char-persona').value = '';
                // ... (其他重置代码保持不变) ...
                document.getElementById('avatar-preview').src = 'data:image/gif;base64,R0lGODlhAQABAAD/ACwAAAAAAQABAAACADs=';
                const maleRadio = document.querySelector('.character-gender-selection input[value="male"]');
                if (maleRadio) maleRadio.checked = true;

                document.getElementById('user-name').value = userProfile.name || '我';
                document.getElementById('user-persona').value = userProfile.persona || '';
                const userAvatar = userProfile.avatar;
                const isUserUrl = userAvatar && (userAvatar.startsWith('http') || userAvatar.startsWith('data:'));
                document.getElementById('user-avatar-preview').src = isUserUrl ? userAvatar : 'data:image/gif;base64,R0lGODlhAQABAAD/ACwAAAAAAQABAAACADs=';

                openCharacterCardPage();
            }


            // ========== 结束：替换完成 ==========


            function selectExistingContact() {
                const menu = document.getElementById('contactMenu');
                menu.classList.remove('show');
                alert('打开选择已有联系人页面');
            }

            document.addEventListener('click', function (e) {
                // --- 优化开始 ---

                // 1. 处理悬浮球菜单的外部点击
                const floatingMenu = document.getElementById('floatingBallMenu');
                const ball = document.getElementById('floatingBall');
                if (floatingMenu && ball && !floatingMenu.contains(e.target) && !ball.contains(e.target)) {
                    closeFloatingBallMenu();
                }

                // 2. 处理联系人菜单的外部点击
                const contactMenu = document.getElementById('contactMenu');
                const addBtn = document.querySelector('.add-contact-btn');
                if (contactMenu && addBtn && !contactMenu.contains(e.target) && !addBtn.contains(e.target)) {
                    contactMenu.classList.remove('show');
                }

                // --- 优化结束 ---
            });


            function applyCustomWidget() {
                const code = document.getElementById('widgetCodeInput').value.trim();

                if (!code) {
                    alert('请输入组件代码');
                    return;
                }

                const targetWidget = document.querySelector('[data-id="widget2"]');

                if (!targetWidget) {
                    alert('未找到目标 Widget，请先恢复原始组件');
                    return;
                }

                const alreadySaved = globalConfig.savedWidgets.some(w => w.id === 'widget2');

                if (!alreadySaved) {
                    globalConfig.savedWidgets.push({
                        id: 'widget2',
                        type: 'widget',
                        name: 'Widget（原始）',
                        html: targetWidget.outerHTML,
                        timestamp: Date.now()
                    });

                    localStorage.setItem('savedWidgets', JSON.stringify(globalConfig.savedWidgets));
                    console.log('原始 Widget 已保存到"已删除组件"列表');
                }

                const widgetScene = targetWidget.querySelector('.widget-scene');
                if (widgetScene) {
                    widgetScene.innerHTML = code;
                    alert('自定义组件已应用！');
                    console.log('自定义组件代码已应用到桌面');
                } else {
                    alert('Widget 结构异常，请检查');
                }
            }

            function renderAppPreviews() {
                const container = document.getElementById('appPreviewList');
                container.innerHTML = '';

                const dockSection = document.createElement('div');
                dockSection.innerHTML = '<div class="section-title">DOCK栏图标</div>';
                container.appendChild(dockSection);

                for (let i = 0; i < 4; i++) {
                    const item = document.createElement('div');
                    item.className = 'app-preview-item';

                    const currentIcon = globalConfig.dockIcons[i];
                    const isUrl = currentIcon.startsWith('http') || currentIcon.startsWith('data:');
                    const iconDisplay = isUrl
                        ? `<img src="${currentIcon}" alt="Dock ${i + 1}">`
                        : currentIcon;

                    item.innerHTML = `
            <div class="preview-header">
                <div class="preview-icon" id="preview-dock-${i}">
                    ${iconDisplay}
                </div>
                <div class="preview-name">Dock 图标 ${i + 1}</div>
            </div>
            <div class="upload-section">
                <label class="upload-btn">
                    📁 上传文件
                    <input type="file" class="file-input" accept="image/*" onchange="handleDockUpload(event, ${i})">
                </label>
                <div class="url-input-btn" onclick="toggleDockUrlInput(${i})">🔗 URL填写</div>
            </div>
            <div class="url-input-box" id="dock-url-box-${i}">
                <input type="text" class="url-input-field" id="dock-url-input-${i}" placeholder="输入图片URL">
                <button class="confirm-btn" onclick="applyDockUrl(${i})">确认</button>
            </div>
            <div class="status-message" id="dock-status-${i}"></div>
        `;

                    container.appendChild(item);
                }

                const divider = document.createElement('div');
                divider.innerHTML = '<div class="section-title">应用图标</div>';
                container.appendChild(divider);

                const allApps = [...appsPage1.filter(app => !app.isWidget), ...appsPage2.filter(app => !app.isWidget && !app.isFolder)];

                allApps.forEach(app => {
                    const item = document.createElement('div');
                    item.className = 'app-preview-item';

                    const customIcon = globalConfig.customIcons[app.id];
                    const iconDisplay = customIcon
                        ? `<img src="${customIcon}" alt="${app.label}">`
                        : app.icon;

                    item.innerHTML = `
                    <div class="preview-header">
                        <div class="preview-icon" id="preview-${app.id}">
                            ${iconDisplay}
                        </div>
                        <div class="preview-name">${app.label}</div>
                    </div>
                    <div class="upload-section">
                        <label class="upload-btn">
                            📁 上传文件
                            <input type="file" class="file-input" accept="image/*" onchange="handleFileUpload(event, '${app.id}')">
                        </label>
                        <div class="url-input-btn" onclick="toggleUrlInput('${app.id}')">🔗 URL填写</div>
                    </div>
                    <div class="url-input-box" id="url-box-${app.id}">
                        <input type="text" class="url-input-field" id="url-input-${app.id}" placeholder="输入图片URL">
                        <button class="confirm-btn" onclick="applyUrlIcon('${app.id}')">确认</button>
                    </div>
                    <div class="status-message" id="status-${app.id}"></div>
                `;

                    container.appendChild(item);
                });
            }

            function toggleUrlInput(appId) {
                const urlBox = document.getElementById(`url-box-${appId}`);
                urlBox.classList.toggle('show');
            }

            async function handleFileUpload(event, appId) {
                const file = event.target.files[0];
                if (!file) return;

                const maxSize = globalConfig.storage.maxFileSize * 1024 * 1024;
                if (file.size > maxSize) {
                    showStatus(appId, `文件太大 最大${globalConfig.storage.maxFileSize}MB`, 'error');
                    return;
                }

                if (globalConfig.database.client) {
                    showStatus(appId, '正在上传到云存储...', '');
                    const result = await storageAPI.uploadFile(file, `${appId}-${Date.now()}.${file.name.split('.').pop()}`);

                    if (result.success) {
                        applyCustomIcon(appId, result.url);
                        showStatus(appId, '已上传到云存储');
                    } else {
                        showStatus(appId, '上传失败，使用本地预览', 'error');
                        const reader = new FileReader();
                        reader.onload = (e) => {
                            applyCustomIcon(appId, e.target.result);
                        };
                        reader.readAsDataURL(file);
                    }
                } else {
                    const reader = new FileReader();
                    reader.onload = (e) => {
                        applyCustomIcon(appId, e.target.result);
                        showStatus(appId, '文件已加载（本地预览）');
                    };
                    reader.readAsDataURL(file);
                }
            }

            function applyUrlIcon(appId) {
                const urlInput = document.getElementById(`url-input-${appId}`);
                const url = urlInput.value.trim();

                if (!url) {
                    showStatus(appId, '请输入URL', 'error');
                    return;
                }

                applyCustomIcon(appId, url);
                showStatus(appId, 'URL图标已应用');
                urlInput.value = '';
                toggleUrlInput(appId);
            }

            function applyCustomIcon(appId, iconUrl) {
                globalConfig.customIcons[appId] = iconUrl;

                const previewEl = document.getElementById(`preview-${appId}`);
                previewEl.innerHTML = `<img src="${iconUrl}" alt="">`;

                updateMainIcon(appId, iconUrl);
                saveCustomIconsToLocalStorage();
                console.log(`已将 ${appId} 的新图标保存到 LocalStorage`);
                if (globalConfig.database.client) {
                    dbAPI.saveData({
                        app_id: appId,
                        icon_url: iconUrl,
                        updated_at: new Date().toISOString()
                    }).then(result => {
                        if (result.success) {
                            console.log(`图标配置已同步到数据库: ${appId}`);
                        }
                    });
                }
            }

            function toggleDockUrlInput(index) {
                const urlBox = document.getElementById(`dock-url-box-${index}`);
                urlBox.classList.toggle('show');
            }

            async function handleDockUpload(event, index) {
                const file = event.target.files[0];
                if (!file) return;

                const maxSize = globalConfig.storage.maxFileSize * 1024 * 1024;
                if (file.size > maxSize) {
                    showDockStatus(index, `文件太大 最大${globalConfig.storage.maxFileSize}MB`, 'error');
                    return;
                }

                if (globalConfig.database.client) {
                    showDockStatus(index, '正在上传到云存储...', '');
                    const result = await storageAPI.uploadFile(file, `dock-${index}-${Date.now()}.${file.name.split('.').pop()}`);

                    if (result.success) {
                        applyDockIcon(index, result.url);
                        showDockStatus(index, '已上传到云存储');
                    } else {
                        showDockStatus(index, '上传失败,使用本地预览', 'error');
                        const reader = new FileReader();
                        reader.onload = (e) => {
                            applyDockIcon(index, e.target.result);
                        };
                        reader.readAsDataURL(file);
                    }
                } else {
                    const reader = new FileReader();
                    reader.onload = (e) => {
                        applyDockIcon(index, e.target.result);
                        showDockStatus(index, '文件已加载(本地预览)');
                    };
                    reader.readAsDataURL(file);
                }
            }

            function applyDockUrl(index) {
                const urlInput = document.getElementById(`dock-url-input-${index}`);
                const url = urlInput.value.trim();

                if (!url) {
                    showDockStatus(index, '请输入URL', 'error');
                    return;
                }

                applyDockIcon(index, url);
                showDockStatus(index, 'URL图标已应用');
                urlInput.value = '';
                toggleDockUrlInput(index);
            }

            function applyDockIcon(index, iconUrl) {
                globalConfig.dockIcons[index] = iconUrl;

                const previewEl = document.getElementById(`preview-dock-${index}`);
                if (previewEl) {
                    previewEl.innerHTML = `<img src="${iconUrl}" alt="">`;
                }

                const dockIcon = document.querySelectorAll('.dock-icon')[index];
                if (dockIcon) {
                    dockIcon.innerHTML = `<img src="${iconUrl}" style="width: 100%; height: 100%; object-fit: cover; border-radius: 14px;" alt="">`;
                }

                localStorage.setItem('phoneDockIcons', JSON.stringify(globalConfig.dockIcons));
                console.log(`Dock图标 ${index} 已保存`);
            }

            function showDockStatus(index, message, type = 'success') {
                const statusEl = document.getElementById(`dock-status-${index}`);
                if (statusEl) {
                    statusEl.textContent = message;
                    statusEl.className = 'status-message' + (type === 'error' ? ' error' : '');
                    setTimeout(() => {
                        statusEl.textContent = '';
                    }, 3000);
                }
            }


            function updateMainIcon(appId, iconUrl) {
                const appElements = document.querySelectorAll(`[data-id="${appId}"]`);
                appElements.forEach(el => {
                    const iconWrapper = el.querySelector('.icon-wrapper');
                    if (iconWrapper && !el.classList.contains('folder')) {
                        iconWrapper.innerHTML = `<img src="${iconUrl}" alt="">`;
                    }
                });
            }

            function showStatus(appId, message, type = 'success') {
                const statusEl = document.getElementById(`status-${appId}`);
                statusEl.textContent = message;
                statusEl.className = 'status-message' + (type === 'error' ? ' error' : '');
                setTimeout(() => {
                    statusEl.textContent = '';
                }, 3000);
            }

            function deleteTimeCard() {
                const timeCard = document.getElementById('timeCard');
                if (!timeCard) return;

                globalConfig.savedWidgets.push({
                    id: 'timeCard',
                    type: 'time',
                    name: '时间卡片',
                    html: timeCard.outerHTML,
                    timestamp: Date.now()
                });

                timeCard.remove();

                localStorage.setItem('savedWidgets', JSON.stringify(globalConfig.savedWidgets));

                console.log('时间卡片已删除并保存');

                const deletedComponents = JSON.parse(localStorage.getItem('deletedComponents') || '[]');
                if (!deletedComponents.includes('timeCard')) {
                    deletedComponents.push('timeCard');
                    localStorage.setItem('deletedComponents', JSON.stringify(deletedComponents));
                }
            }

            function deleteWeatherCard() {
                const weatherCard = document.getElementById('weatherCard');
                if (!weatherCard) return;

                globalConfig.savedWidgets.push({
                    id: 'weatherCard',
                    type: 'weather',
                    name: '天气卡片',
                    html: weatherCard.outerHTML,
                    timestamp: Date.now()
                });

                weatherCard.remove();

                localStorage.setItem('savedWidgets', JSON.stringify(globalConfig.savedWidgets));

                console.log('天气卡片已删除并保存');
                const deletedComponents = JSON.parse(localStorage.getItem('deletedComponents') || '[]');
                if (!deletedComponents.includes('weatherCard')) {
                    deletedComponents.push('weatherCard');
                    localStorage.setItem('deletedComponents', JSON.stringify(deletedComponents));
                }
            }

            function deleteWidget(widgetElement) {
                if (!widgetElement) return;

                const widgetId = widgetElement.dataset.id;

                globalConfig.savedWidgets.push({
                    id: widgetId,
                    type: 'widget',
                    name: widgetElement.querySelector('.app-label')?.textContent || 'Widget',
                    html: widgetElement.outerHTML,
                    timestamp: Date.now()
                });

                widgetElement.remove();

                localStorage.setItem('savedWidgets', JSON.stringify(globalConfig.savedWidgets));

                console.log(`Widget ${widgetId} 已删除并保存`);
                const deletedComponents = JSON.parse(localStorage.getItem('deletedComponents') || '[]');
                if (!deletedComponents.includes(widgetId)) {
                    deletedComponents.push(widgetId);
                    localStorage.setItem('deletedComponents', JSON.stringify(deletedComponents));
                }
            }

            // ▼▼▼ 请用下面这个完整的、修正后的函数，替换掉您文件中旧的 createElement 函数 ▼▼▼

            function createElement(app, grid) {
                const el = document.createElement('div');

                if (app.isWidget) {
                    // 只为 widget2 创建数码像素猫组件
                    if (app.id === 'widget2') {
                        el.className = 'cat-widget';
                        Object.assign(el.dataset, {id: app.id, row: app.row, col: app.col});
                        el.dataset.colspan = app.colspan;
                        el.dataset.rowspan = app.rowspan;

                        el.innerHTML = `
            <div class="delete-widget-btn" onclick="deleteWidget(this.parentElement)">×</div>

            <!-- 状态数据条 -->
            <div class="cat-stats-container">
                <div class="cat-stat-item" data-stat="happiness" onclick="editCatStat(event, 'happiness')">
                    <div class="cat-stat-label">
                        <span>😊 开心度</span>
                        <span class="cat-stat-value" id="stat-happiness-value">85%</span>
                    </div>
                    <div class="cat-stat-bar-bg">
                        <div class="cat-stat-bar-fill" id="stat-happiness-bar" style="width: 85%"></div>
                    </div>
                </div>

                <div class="cat-stat-item" data-stat="hunger" onclick="editCatStat(event, 'hunger')">
                    <div class="cat-stat-label">
                        <span>🍖 饱食度</span>
                        <span class="cat-stat-value" id="stat-hunger-value">70%</span>
                    </div>
                    <div class="cat-stat-bar-bg">
                        <div class="cat-stat-bar-fill" id="stat-hunger-bar" style="width: 70%"></div>
                    </div>
                </div>

                <div class="cat-stat-item" data-stat="energy" onclick="editCatStat(event, 'energy')">
                    <div class="cat-stat-label">
                        <span>⚡ 精力值</span>
                        <span class="cat-stat-value" id="stat-energy-value">60%</span>
                    </div>
                    <div class="cat-stat-bar-bg">
                        <div class="cat-stat-bar-fill" id="stat-energy-bar" style="width: 60%"></div>
                    </div>
                </div>

                <div class="cat-stat-item" data-stat="cleanliness" onclick="editCatStat(event, 'cleanliness')">
                    <div class="cat-stat-label">
                        <span>✨ 清洁度</span>
                        <span class="cat-stat-value" id="stat-cleanliness-value">90%</span>
                    </div>
                    <div class="cat-stat-bar-bg">
                        <div class="cat-stat-bar-fill" id="stat-cleanliness-bar" style="width: 90%"></div>
                    </div>
                </div>
            </div>

            <!-- 数码像素猫主体 -->
            <div class="pixel-cat-body"></div>

            <!-- 猫咪对话气泡 -->
            <div class="cat-speech-bubble" onclick="editCatSpeech(event)">喵~ 今天也要开心喔！🌸</div>
        `;
                    } else {
                        return; // 其他widget暂不创建
                    }
                } else {
                    // 普通图标和文件夹的逻辑保持不变
                    el.className = app.isFolder ? 'app-icon folder' : 'app-icon';
                    Object.assign(el.dataset, {id: app.id, row: app.row, col: app.col});

                    const customIcon = globalConfig.customIcons[app.id];
                    let content;
                    const initialIcon = app.icon;
                    const isInitialIconUrl = initialIcon && (initialIcon.startsWith('http') || initialIcon.startsWith('data:'));

                    if (customIcon) {
                        content = `<img src="${customIcon}" alt="${app.label}">`;
                    } else if (isInitialIconUrl) {
                        content = `<img src="${initialIcon}" alt="${app.label}">`;
                    } else if (app.isFolder) {
                        content = app.icons.slice(0, 9).map(icon => {
                            const isUrl = icon && (icon.startsWith('http') || icon.startsWith('data:'));
                            const miniIconContent = isUrl ? `<img src="${icon}" alt="">` : icon;
                            return `<div class="folder-mini-icon">${miniIconContent}</div>`;
                        }).join('');
                    } else {
                        content = app.icon;
                    }

                    el.innerHTML = `
            <div class="icon-wrapper">${content}</div>
            <div class="app-label">${app.label}</div>
            ${app.badge ? `<span class="badge">${app.badge}</span>` : ''}`;
                }

                // 定位、添加事件监听并添加到网格中
                positionElement(el, app.row, app.col, app.colspan || 1, app.rowspan || 1);
                addDragListeners(el, app.clickable);
                grid.appendChild(el);

                // 针对文件夹，异步获取颜色并应用
                if (app.isFolder) {
                    const firstImageUrl = app.icons.find(icon => icon && (icon.startsWith('http') || icon.startsWith('data:')));
                    if (firstImageUrl) {
                        getAverageColorFromImageUrl(firstImageUrl, (colorGradient) => {
                            if (el && el.isConnected && colorGradient) {
                                const iconWrapper = el.querySelector('.icon-wrapper');
                                if (iconWrapper) {
                                    iconWrapper.style.background = colorGradient;
                                }
                            }
                        });
                    }
                }
            }


            function addDragListeners(el, clickable) {
                let lastDragEndTime = 0;
                // ✅ 新增：如果是小猫组件，增加长按时间，防止误触
                const longPressDelay = el.classList.contains('cat-widget') ? 500 : 350;
                const startInteraction = (e) => {
                    if (state.isSwipingPage) return;

                    state.hasDragged = false;
                    const touch = getTouch(e);
                    state.dragStart = {x: touch.clientX, y: touch.clientY};

                    state.longPressTimer = setTimeout(() => {
                        state.draggedElement = el;
                        state.isEditMode = true;
                        state.isDragging = true;
                        el.classList.add('dragging');
                        document.body.style.cursor = 'grabbing';
                        showEditHint(true);
                        showDeleteButtons(true);
                    }, longPressDelay); // ✅ 使用动态延迟时间
                };

                const endInteraction = () => {
                    clearTimeout(state.longPressTimer);
                    if (state.hasDragged) {
                        lastDragEndTime = Date.now();
                    }
                };

                el.addEventListener('mousedown', (e) => {
                    e.preventDefault();
                    startInteraction(e);
                });
                el.addEventListener('touchstart', startInteraction, {passive: true});

                el.addEventListener('mouseup', endInteraction);
                el.addEventListener('mouseleave', endInteraction);
                el.addEventListener('touchend', endInteraction);

                // ▼▼▼▼▼ 从这里开始修改 ▼▼▼▼▼
                el.addEventListener('click', (e) => {
                    const timeSinceLastDrag = Date.now() - lastDragEndTime;
                    if (!state.hasDragged && !state.isEditMode && timeSinceLastDrag > 300) {
                        e.stopPropagation();

                        // 【新增】判断点击的是否为文件夹
                        if (el.classList.contains('folder')) {
                            const pageKey = el.parentElement.id === 'grid1' ? 'page1' : 'page2';
                            const appId = el.dataset.id;
                            const folderData = state.appLayouts[pageKey].find(app => app.id === appId);
                            if (folderData) {
                                openFolder(folderData);
                            }
                        }
                        // 【修改】将原来的if改为else if
                        else if (clickable) {
                            if (el.dataset.id === 'settings') {
                                openSettings();
                            } else if (el.dataset.id === 'worldbook') {
                                openWorldbook();
                            }
                        }
                    }
                });
                // ▲▲▲▲▲ 修改到这里结束 ▲▲▲▲▲
            }

            function isOccupied(pageKey, targetRow, targetCol, draggedId) {
                const apps = state.appLayouts[pageKey];
                for (const app of apps) {
                    if (app.id === draggedId) {
                        continue;
                    }
                    const appColSpan = app.colspan || 1;
                    const appRowSpan = app.rowspan || 1;
                    const inHorizontalRange = targetCol >= app.col && targetCol < (app.col + appColSpan);
                    const inVerticalRange = targetRow >= app.row && targetRow < (app.row + appRowSpan);

                    if (inHorizontalRange && inVerticalRange) {
                        return true;
                    }
                }
                return false;
            }


            function handleMove(e) {
                if (!state.draggedElement) return;

                const touch = getTouch(e);
                const distance = Math.sqrt(
                    Math.pow(touch.clientX - state.dragStart.x, 2) +
                    Math.pow(touch.clientY - state.dragStart.y, 2)
                );

                if (distance > 5 && !state.hasDragged) {
                    state.hasDragged = true;
                    clearTimeout(state.longPressTimer);
                    if (!state.isDragging) {
                        state.isEditMode = true;
                        state.isDragging = true;
                        state.draggedElement.classList.add('dragging');
                        document.body.style.cursor = 'grabbing';
                        showEditHint(true);
                        state.draggedElement.style.transition = 'none';
                    }
                }

                if (!state.isDragging) return;

                if (e.cancelable) e.preventDefault();

                const deltaX = touch.clientX - state.dragStart.x;
                const deltaY = touch.clientY - state.dragStart.y;
                state.draggedElement.style.transform = `translate(${deltaX}px, ${deltaY}px) scale(1.08)`;
            }

            function handleEnd(e) {
                // ✅ 新增的“守卫”逻辑：
                // 如果 dragGhost 存在，说明当前是“从收藏夹拖出”的操作，
                // 那么 handleEnd 函数不应该执行任何操作，直接返回。
                if (dragGhost) {
                    return;
                }
                clearTimeout(state.longPressTimer);
                document.body.style.cursor = 'default';

                if (state.isDragging && state.draggedElement) {
                    const panel = document.getElementById('iconDockPanel');
                    const touch = getChangedTouch(e);

                    if (panel && panel.classList.contains('show')) {
                        const panelRect = panel.getBoundingClientRect();

                        if (touch.clientX >= panelRect.left && touch.clientX <= panelRect.right &&
                            touch.clientY >= panelRect.top && touch.clientY <= panelRect.bottom) {
                            addIconToDockPanel(state.draggedElement);
                            finishDrag(true);
                            return;
                        }
                    }
                }

                if (state.isDragging && state.draggedElement) {
                    const draggedEl = state.draggedElement;
                    const originalTransition = draggedEl.style.transition;
                    draggedEl.style.transition = 'none';
                    draggedEl.style.transform = '';

                    const grid = draggedEl.parentElement;
                    const gridRect = grid.getBoundingClientRect();

                    const ROW_HEIGHT_PX = 94;
                    const GAP_PX = 14;
                    const DOCK_HEIGHT_PX = 80;

                    const touch = getChangedTouch(e);
                    const dropX = touch.clientX - gridRect.left;
                    const dropY = touch.clientY - gridRect.top;

                    let col = Math.floor(dropX / (gridRect.width / 4));
                    let row = Math.floor(dropY / (ROW_HEIGHT_PX + GAP_PX));

                    const colspan = parseInt(draggedEl.dataset.colspan) || 1;
                    col = Math.max(0, Math.min(col, 4 - colspan));
                    row = Math.max(0, Math.min(row, 6 - 1));

                    const dropYInScreen = touch.clientY;
                    if (dropYInScreen > gridRect.top + gridRect.height - DOCK_HEIGHT_PX) {
                        revertPosition(draggedEl, originalTransition);
                    } else {
                        const pageKey = grid.id === 'grid1' ? 'page1' : 'page2';
                        if (isOccupied(pageKey, row, col, draggedEl.dataset.id)) {
                            revertPosition(draggedEl, originalTransition);
                        } else {
                            updateAndSavePosition(draggedEl, row, col);
                        }
                    }

                    state.lastDragEndTime = Date.now();
                }

                // ✨ 核心修复 ✨
                // 只有在拖动图标时，才立即退出编辑模式
                // 如果只是长按激活，则保持编辑模式
                finishDrag(state.hasDragged);
            }


            function finishDrag(exitImmediately) {
                if (state.draggedElement) {
                    state.draggedElement.classList.remove('dragging');
                    state.draggedElement.style.transition = '';
                }

                state.isDragging = false;
                state.draggedElement = null;

                // ✅ 修改：只有在实际发生拖拽后才重置 hasDragged
                if (exitImmediately) {
                    state.hasDragged = false;
                }

                // ✅ 核心修复：只在明确要求立即退出时，才延迟关闭编辑模式
                if (exitImmediately && state.hasDragged) {
                    setTimeout(() => {
                        if (state.isEditMode && !state.isDragging) {
                            state.isEditMode = false;
                            showEditHint(false);
                            showDeleteButtons(false);
                        }
                    }, 500);
                }
                // ✅ 如果只是长按激活（没有拖拽），则保持编辑模式不退出
            }


            function revertPosition(el, originalTransition = '') {
                const originalRow = parseInt(el.dataset.row);
                const originalCol = parseInt(el.dataset.col);
                const colspan = parseInt(el.dataset.colspan) || 1;
                const rowspan = parseInt(el.dataset.rowspan) || 1;

                el.style.transition = 'all 0.25s cubic-bezier(0.175, 0.885, 0.32, 1.275)';
                positionElement(el, originalRow, originalCol, colspan, rowspan);

                setTimeout(() => {
                    el.style.transition = originalTransition;
                }, 250);
            }


            function updateAndSavePosition(el, newRow, newCol) {
                const appId = el.dataset.id;
                const pageKey = el.parentElement.id === 'grid1' ? 'page1' : 'page2';

                const appData = state.appLayouts[pageKey].find(app => app.id === appId);
                if (appData) {
                    appData.row = newRow;
                    appData.col = newCol;
                }

                el.dataset.row = newRow;
                el.dataset.col = newCol;

                const colspan = parseInt(el.dataset.colspan) || 1;
                const rowspan = parseInt(el.dataset.rowspan) || 1;
                positionElement(el, newRow, newCol, colspan, rowspan);

                saveLayoutToLocalStorage();
                console.log(`已保存 ${appId} 到新位置: (${newRow}, ${newCol})`);
            }

            function saveLayoutToLocalStorage() {
                localStorage.setItem('phoneAppLayouts', JSON.stringify(state.appLayouts));
            }

            function saveCustomIconsToLocalStorage() {
                localStorage.setItem('phoneCustomIcons', JSON.stringify(globalConfig.customIcons));
            }


            function showPage(pageNum) {
                state.currentPage = pageNum;
                pagesWrapper.style.transform = `translateX(-${(pageNum - 1) * 50}%)`;
                document.querySelectorAll('.dot').forEach((dot, i) =>
                    dot.classList.toggle('active', i === pageNum - 1));

                const hint1 = document.getElementById('editHint1');
                const hint2 = document.getElementById('editHint2');

                if (pageNum === 1) {
                    hint1.style.display = 'block';
                    hint2.style.display = 'none';
                } else {
                    hint1.style.display = 'none';
                    hint2.style.display = 'block';
                }
            }


            // 【新增】一个专门用于在 requestAnimationFrame 中更新样式的函数
            function updateSwipeTransform() {
                if (!state.swipeMoveScheduled) {
                    return;
                }
                pagesWrapper.style.transform = `translateX(${state.lastSwipeTranslateX}%)`;
                state.swipeMoveScheduled = false; // 更新完成后，重置标志
            }

            // ============ 开始：请将这个全新的代码块完整粘贴到你的 <script> 中 ============

            // 这是一个统一的“滑动结束”处理器，它会清理自身绑定的事件
            function swipeEndHandler(e) {
                // 解除在 document 上绑定的事件，这是防止冲突的关键！
                document.removeEventListener('mousemove', swipeMoveHandler);
                document.removeEventListener('mouseup', swipeEndHandler);
                document.removeEventListener('touchmove', swipeMoveHandler);
                document.removeEventListener('touchend', swipeEndHandler);

                if (!state.isSwipingPage) return;

                // --- 动画和翻页逻辑 (这部分和我们上次修复的逻辑一致) ---
                const diff = getChangedTouch(e).clientX - state.swipeStart.x;
                const timeElapsed = Date.now() - state.swipeStart.time;
                const velocity = timeElapsed > 0 ? Math.abs(diff) / timeElapsed : 0;

                pagesWrapper.classList.remove('no-transition');

                let targetPage = state.currentPage;
                if (Math.abs(diff) > 30 || velocity > 0.2) {
                    if (diff > 0 && state.currentPage === 2) {
                        targetPage = 1;
                    } else if (diff < 0 && state.currentPage === 1) {
                        targetPage = 2;
                    }
                }

                // 使用 setTimeout 确保动画无缝衔接
                setTimeout(() => {
                    showPage(targetPage);
                }, 0);

                state.isSwipingPage = false;
            }

            // 这是一个统一的“滑动中”处理器
            function swipeMoveHandler(e) {
                if (!state.isSwipingPage) return;

                // 阻止默认行为（如浏览器返回）
                if (e.cancelable) {
                    e.preventDefault();
                }

                const touch = getTouch(e);
                const diffX = touch.clientX - state.swipeStart.x;

                const percentDiff = (diffX / screen.offsetWidth) * 50;
                const newTransform = Math.max(-50, Math.min(0, state.initialTransform + percentDiff));

                // 使用 rAF 优化性能
                if (!state.swipeMoveScheduled) {
                    state.lastSwipeTranslateX = newTransform;
                    state.swipeMoveScheduled = true;
                    requestAnimationFrame(updateSwipeTransform);
                }
            }

            // ============ 开始：请用这个全新的、修复了点击冲突的函数替换旧的 swipeStartHandler ============

            function swipeStartHandler(e) {
                // ▼ ▼ ▼ 核心修复点在这里 ▼ ▼ ▼
                // 检查事件的目标元素是否是我们不希望触发滑动的区域
                if (e.target.closest('.page-dots, .dock')) {
                    // 如果是，说明用户想点击按钮而不是滑动页面，
                    // 那么我们什么都不做，直接返回，让按钮的 onclick 事件正常执行。
                    return;
                }
                // ▲ ▲ ▲ 修复结束 ▲ ▲ ▲

                // --- 后续的滑动判断逻辑保持不变 ---
                if (Date.now() - state.lastDragEndTime < 300) return;
                if (e.target.closest('#iconDockPanel, #floatingBall, .cat-widget, .contacts-page, .chat-page, .settings-page, .config-page, .beautify-page, .modal-overlay, #codeSandboxModal')) {
                    return;
                }
                if (state.isDraggingFromDock || state.isEditMode || state.isDragging) return;

                // 初始化滑动状态
                const touch = getTouch(e);
                state.swipeStart = {x: touch.clientX, time: Date.now()};
                state.isSwipingPage = true;
                state.initialTransform = -(state.currentPage - 1) * 50;
                pagesWrapper.classList.add('no-transition');

                // 动态绑定监听器
                if (e.type === 'touchstart') {
                    document.addEventListener('touchmove', swipeMoveHandler, {passive: false});
                    document.addEventListener('touchend', swipeEndHandler);
                } else { // mousedown
                    document.addEventListener('mousemove', swipeMoveHandler);
                    document.addEventListener('mouseup', swipeEndHandler);
                }
            }

            // ============ 结束：替换代码 ============


            // 这个 rAF 更新函数保持不变
            function updateSwipeTransform() {
                if (!state.swipeMoveScheduled) {
                    return;
                }
                pagesWrapper.style.transform = `translateX(${state.lastSwipeTranslateX}%)`;
                state.swipeMoveScheduled = false;
            }

            // ============ 结束：粘贴代码 ============


            document.addEventListener('touchmove', handleMove, {passive: false});
            document.addEventListener('mousemove', handleMove);
            document.addEventListener('touchend', (e) => handleEnd(e));
            document.addEventListener('mouseup', (e) => handleEnd(e));
            // 在 initializeApp 函数中添加这两行
            screen.addEventListener('touchstart', swipeStartHandler, {passive: true});
            screen.addEventListener('mousedown', swipeStartHandler);

            screen.addEventListener('click', (e) => {
                if (e.target.closest('.chat-page, .contacts-page, .settings-page, .config-page, .beautify-page, .modal-overlay')) {
                    return;
                }

                // ✅ 修改：点击任何非组件区域都退出编辑模式
                if (!e.target.closest('.app-icon') &&
                    !e.target.closest('.widget') &&
                    !e.target.closest('.cat-widget') && // 确保这行存在
                    !e.target.closest('.time-card') &&
                    !e.target.closest('.weather-card') &&
                    !e.target.closest('[class*="delete-"]')) {
                    exitEditMode();
                }
            });


            function initializeLayout() {
                // 加载壁纸
                const savedWallpaper = localStorage.getItem('phoneWallpaper');
                if (savedWallpaper) {
                    applyWallpaper(savedWallpaper);
                }
                // 【核心修复 - 第1步】:
                // 在所有操作之前，首先加载收藏夹图标数据
                const savedDockedIcons = localStorage.getItem('phoneDockedIcons');
                let dockedIconIds = new Set(); // 使用 Set 数据结构，查询效率更高
                if (savedDockedIcons) {
                    try {
                        // 解析收藏夹数据，并提取所有图标的 ID
                        const dockedIconsData = JSON.parse(savedDockedIcons);
                        dockedIconsData.forEach(icon => dockedIconIds.add(icon.id));
                    } catch (e) {
                        console.error("解析收藏夹图标ID失败", e);
                    }
                }
                // 加载桌面布局
                const savedLayouts = localStorage.getItem('phoneAppLayouts');
                if (savedLayouts) {
                    try {
                        const loadedLayouts = JSON.parse(savedLayouts);

                        // 【核心修复 - 第2步】:
                        // 将收藏夹图标ID集合传递给 mergeAppLayouts 函数
                        state.appLayouts.page1 = mergeAppLayouts(appsPage1, loadedLayouts.page1 || [], dockedIconIds);
                        state.appLayouts.page2 = mergeAppLayouts(appsPage2, loadedLayouts.page2 || [], dockedIconIds);
                        console.log('成功从 LocalStorage 加载布局并合并新功能');
                    } catch (e) {
                        console.error('解析 LocalStorage 布局失败，使用默认布局', e);
                    }
                }
                // Dock栏图标加载（这部分逻辑不变，但为了完整性放在这里）
                const savedDockIcons = localStorage.getItem('phoneDockIcons');
                let dockIconsToRender = globalConfig.dockIcons;
                if (savedDockIcons) {
                    try {
                        dockIconsToRender = JSON.parse(savedDockIcons);
                        console.log('成功从 LocalStorage 加载Dock图标');
                    } catch (e) {
                        console.error('解析 Dock 图标失败', e);
                    }
                }
                const dockContainer = document.querySelector('.dock');
                dockContainer.innerHTML = '';
                dockIconsToRender.forEach((icon, index) => {
                    const dockIcon = document.createElement('div');
                    dockIcon.className = 'dock-icon';
                    dockIcon.dataset.index = index;
                    if (icon && (icon.startsWith('http') || icon.startsWith('data:'))) {
                        dockIcon.innerHTML = `<img src="${icon}" style="width: 100%; height: 100%; object-fit: cover; border-radius: 14px;" alt="">`;
                    } else if (icon) {
                        dockIcon.textContent = icon;
                    }
                    if (index === 0) {
                        dockIcon.onclick = openContacts;
                    } else if (index === 2) {
                        dockIcon.onclick = openWorldSelect;
                    }
                    dockContainer.appendChild(dockIcon);
                });
                // 其他设置加载（保持不变）
                const savedIcons = localStorage.getItem('phoneCustomIcons');
                if (savedIcons) {
                    try {
                        globalConfig.customIcons = JSON.parse(savedIcons);
                    } catch (e) {
                    }
                }
                const savedWidgets = localStorage.getItem('savedWidgets');
                if (savedWidgets) {
                    try {
                        globalConfig.savedWidgets = JSON.parse(savedWidgets);
                    } catch (e) {
                    }
                }
                const deletedComponents = JSON.parse(localStorage.getItem('deletedComponents') || '[]');
                // 渲染桌面
                [['grid1', state.appLayouts.page1], ['grid2', state.appLayouts.page2]].forEach(([id, apps]) => {
                    const grid = document.getElementById(id);
                    grid.innerHTML = '';
                    apps.forEach(app => {
                        if (app.isWidget && deletedComponents.includes(app.id)) {
                            return;
                        }
                        createElement(app, grid);
                    });
                });

                // 处理已删除的组件（保持不变）
                if (deletedComponents.includes('timeCard')) {
                    document.getElementById('timeCard')?.remove();
                }
                if (deletedComponents.includes('weatherCard')) {
                    document.getElementById('weatherCard')?.remove();
                }
                loadSavedMoodAndWeather();
            }

            function mergeAppLayouts(defaultApps, savedApps, dockedIconIds) {
                const merged = [...savedApps];
                const savedIds = new Set(savedApps.map(app => app.id));
                // 将默认布局中新增的应用添加进来
                defaultApps.forEach(defaultApp => {
                    // 【核心修复 - 第3步】:
                    // 增加一个判断条件：!dockedIconIds.has(defaultApp.id)
                    // 只有当图标既不在当前桌面，也不在收藏夹时，才把它添加回来
                    if (!savedIds.has(defaultApp.id) && !dockedIconIds.has(defaultApp.id)) {
                        merged.push(defaultApp);
                        console.log(`新增或恢复了应用: ${defaultApp.label}`);
                    }
                });
                return merged;
            }


            document.getElementById('chatInput').addEventListener('keydown', function (event) {
                if (event.key === 'Enter' && !event.shiftKey) {
                    event.preventDefault();

                    addMessageToList();
                }
            });

            // ========== 开始：用这个全新的JS代码块替换旧的 openAvatarActions 和相关函数 ==========

            /**
             * 打开头像操作菜单，并记录当前操作的目标是哪个头像
             * @param {'contact' | 'user'} target - 'contact' 表示对方头像, 'user' 表示用户头像
             */
            function openAvatarActions(target) {
                currentAvatarTarget = target; // 记录当前操作目标
                document.getElementById('avatarActionSheet').classList.add('show');
            }

            /**
             * 关闭头像操作菜单
             */
            function closeAvatarActions() {
                document.getElementById('avatarActionSheet').classList.remove('show');
            }

            /**
             * 触发隐藏的文件上传输入框
             */
            function triggerFileUpload() {
                document.getElementById('avatar-input').click();
                closeAvatarActions();
            }

            /**
             * 弹出输入框让用户填写图片URL
             */
            function promptForUrl() {
                const url = prompt("请输入图片URL:", "https://");
                if (url) {
                    const img = new Image();
                    img.onload = function () {
                        // 根据之前记录的目标，更新正确的头像预览
                        const previewId = currentAvatarTarget === 'user' ? 'user-avatar-preview' : 'avatar-preview';
                        document.getElementById(previewId).src = url;
                        console.log(`已将 ${previewId} 的头像更新为: ${url}`);
                    };
                    img.onerror = function () {
                        alert("无法加载该URL的图片，请检查链接是否正确。");
                    };
                    img.src = url;
                }
                closeAvatarActions();
            }

            // ========== 结束：替换完成 ==========


            function triggerFileUpload() {
                document.getElementById('avatar-input').click();
                closeAvatarActions();
            }

            function promptForUrl() {
                const url = prompt("请输入图片URL:", "https://");
                if (url) {
                    const img = new Image();
                    img.onload = function () {
                        // 根据记录的目标更新对应的头像预览
                        const previewId = currentAvatarTarget === 'user' ? 'user-avatar-preview' : 'avatar-preview';
                        document.getElementById(previewId).src = url;
                    };
                    img.onerror = function () {
                        alert("无法加载该URL的图片，请检查链接。");
                    };
                    img.src = url;
                }
                closeAvatarActions();
            }

            // ▼▼▼ 步骤2：用这个新版本完整替换旧的 openChat 函数 ▼▼▼

            /**
             * [最终版] 打开聊天页面，并能根据联系人类型自动切换主题
             * @param {object} contact - 要聊天的联系人对象
             */
            function openChat(contact) {
                if (!contact) return;
                currentChatContact = contact;

                const chatPage = document.getElementById('chatPage');
                const contactNameEl = document.getElementById('chatContactName');
                const messagesEl = document.getElementById('chatMessages');

                // 1. 核心逻辑：检查当前联系人是否在“密友列表”中
                const isSweetheart = sweetheartContactsData.some(sweetheart => sweetheart.id === contact.id);

                // 2. 根据检查结果，动态添加或移除主题class
                if (isSweetheart) {
                    // 如果是密友，添加 'sweetheart-mode' 类
                    chatPage.classList.add('sweetheart-mode');
                    console.log(`正在以密友模式打开与 ${contact.name} 的聊天`);
                } else {
                    // 如果不是，确保移除该类，恢复为普通模式
                    chatPage.classList.remove('sweetheart-mode');
                    console.log(`正在以普通模式打开与 ${contact.name} 的聊天`);
                }

                // 后续的渲染逻辑保持不变...
                contactNameEl.textContent = contact.name;
                messagesEl.innerHTML = '';

                requestAnimationFrame(() => {
                    chatPage.classList.add('show');
                });

                const chatHistory = JSON.parse(localStorage.getItem('phoneChatHistory') || '{}');
                const contactMessages = chatHistory[contact.id] || [];

                if (contactMessages.length === 0) {
                    // 为不同模式设置不同的欢迎语
                    const welcomeMessage = isSweetheart
                        ? `和密友 ${contact.name} 的悄悄话开始了...💖`
                        : `你和 ${contact.name} 开始聊天了`;

                    // 使用你的 _createMessageDOM 函数来创建系统消息（如果支持的话）
                    // 这里简化处理，直接插入一个提示
                    const systemMessageEl = document.createElement('div');
                    systemMessageEl.textContent = welcomeMessage;
                    systemMessageEl.style.textAlign = 'center';
                    systemMessageEl.style.fontSize = '12px';
                    systemMessageEl.style.color = '#aaa';
                    systemMessageEl.style.margin = '10px 0';
                    messagesEl.appendChild(systemMessageEl);

                } else {
                    contactMessages.forEach((message, index) => {
                        const messageRow = _createMessageDOM(contact.id, message, index);
                        messagesEl.appendChild(messageRow);
                    });
                }

                setTimeout(() => {
                    messagesEl.scrollTop = messagesEl.scrollHeight;
                }, 50);
            }

            // 同时，为了保险起见，我们也在 closeChat 函数中确保清除主题
            function closeChat() {
                const chatPage = document.getElementById('chatPage');
                chatPage.classList.remove('show');
                // 在动画结束后，移除主题类，以防影响下次打开
                setTimeout(() => {
                    chatPage.classList.remove('sweetheart-mode');
                }, 350);
            }


            function closeChat() {
                const chatPage = document.getElementById('chatPage');
                chatPage.classList.remove('show');
            }

            // ========== 开始：粘贴这个全新的、支持识图的 callApi 函数 ==========
            async function callApi(messages) {
                // 1. 检查 API 配置
                if (globalConfig.activeApiConfig === null || !globalConfig.apiConfigs[globalConfig.activeApiConfig]) {
                    return {success: false, message: '请先在“设置”中配置并选择一个有效的API。'};
                }
                const config = globalConfig.apiConfigs[globalConfig.activeApiConfig];

                // 2. [核心改造] 检查是否选择了视觉模型
                const isVisionModel = config.model.includes('vision') || config.model.includes('4o');
                if (!isVisionModel) {
                    console.warn(`当前模型 ${config.model} 可能不支持识图。为获得最佳效果，请在设置中选用 gpt-4o 或 gpt-4-vision-preview 等模型。`);
                }

                // 3. 构建请求体
                const requestBody = {
                    model: config.model,
                    messages: messages,
                    // 如果是视觉模型，可以设置更高的 max_tokens 来获取更详细的描述
                    max_tokens: isVisionModel ? 4096 : 2048
                };

                // 4. 发送 API 请求
                try {
                    const response = await fetch(`${config.url}/chat/completions`, {
                        method: 'POST',
                        headers: {
                            'Content-Type': 'application/json',
                            'Authorization': `Bearer ${config.key}`
                        },
                        body: JSON.stringify(requestBody)
                    });

                    if (!response.ok) {
                        const errorData = await response.json().catch(() => ({message: '无法解析API错误信息'}));
                        throw new Error(`API 请求失败，状态码: ${response.status} - ${errorData.error ? errorData.error.message : response.statusText}`);
                    }

                    const data = await response.json();
                    const replyContent = data.choices[0]?.message?.content;

                    if (!replyContent) {
                        throw new Error('API返回的数据格式不正确，未能找到回复内容。');
                    }

                    return {success: true, message: replyContent.trim()};

                } catch (error) {
                    console.error('调用API时出错:', error);
                    return {success: false, message: `网络或API错误: ${error.message}`};
                }
            }

            /**
             * [全新版本] 发送消息，会检查并打包引用信息
             */
            function addMessageToList() {
                const inputEl = document.getElementById('chatInput');
                const messagesEl = document.getElementById('chatMessages');
                const messageText = inputEl.value.trim();

                // 如果没有新输入内容，且没有引用内容，则不发送
                if (!messageText && !currentQuoteData) return;

                // 如果只输入了空格，也不发送
                if (!messageText.trim() && !currentQuoteData) {
                    inputEl.value = '';
                    return;
                }

                // 构造要保存的消息对象
                const messagePayload = {
                    sender: 'user',
                    text: messageText,
                };

                // 如果存在引用数据，将其附加到消息对象上
                if (currentQuoteData) {
                    messagePayload.quote = currentQuoteData;
                }

                // 保存消息并获取其新索引
                const newIndex = saveMessage(currentChatContact.id, messagePayload);

                // 在界面上渲染这条新消息
                const messageRow = _createMessageDOM(currentChatContact.id, messagePayload, newIndex);
                messagesEl.appendChild(messageRow);

                // 清理工作
                inputEl.value = ''; // 清空输入框
                document.querySelector('.chat-input-area').classList.remove('has-text'); // 更新发送按钮状态
                cancelQuote(); // 取消引用状态并隐藏预览条

                renderContacts(contactsData); // 更新联系人列表的最后消息
                messagesEl.scrollTop = messagesEl.scrollHeight; // 滚动到底部
                inputEl.focus();
            }


            /**
             * [最终修正版] 获取AI回复，并自动注入角色、世界和世界书的完整上下文
             */
            async function getAiReply() {
                if (!currentChatContact) return;

                const messagesEl = document.getElementById('chatMessages');
                const getReplyBtn = document.getElementById('getReplyBtn');

                getReplyBtn.disabled = true;
                chatInput.disabled = true;

                const chatHistory = JSON.parse(localStorage.getItem('phoneChatHistory') || '{}');
                const historyMessages = chatHistory[currentChatContact.id] || [];

                if (historyMessages.length === 0) {
                    console.log("没有历史消息，不请求AI回复。");
                    getReplyBtn.disabled = false;
                    chatInput.disabled = false;
                    return;
                }

                // --- ▼▼▼ 这是修正和增强的核心区域 ▼▼▼ ---

                // 1. 整合用户设定（System Prompt）
                let systemPrompts = [];
                if (userProfile.persona && userProfile.persona.trim() !== '') {
                    systemPrompts.push(`[关于我(用户)的设定]:\n${userProfile.persona}`);
                }

                // 2. 整合角色设定
                const persona = (currentChatContact.status && currentChatContact.status.trim() !== '')
                    ? currentChatContact.status
                    : '你是一个乐于助人的助手。';
                systemPrompts.push(`[关于你(AI)的角色设定]:\n${persona}`);

                // 3. 【新】调用我们修正后的函数，获取并添加世界书内容
                const worldbookContext = gatherWorldbookContext();
                if (worldbookContext) {
                    systemPrompts.push(worldbookContext); // 添加世界书背景
                }

                // 将所有系统指令合并成一个，用换行符分隔
                const combinedSystemPrompt = systemPrompts.join('\n\n');

                // ★★★【验证步骤】★★★
                // 你可以在浏览器开发者工具的控制台看到最终发送给AI的系统指令
                console.log("即将发送给AI的系统指令(System Prompt):\n", combinedSystemPrompt);

                // 4. 构建最终发送给API的消息列表
                const apiMessages = [{role: 'system', content: combinedSystemPrompt}];
                historyMessages.forEach(msg => {
                    apiMessages.push({
                        role: msg.sender === 'user' ? 'user' : 'assistant',
                        content: msg.text
                    });
                });

                // --- ▲▲▲ 修改结束 ▲▲▲ ---

                // 后续的API调用和UI更新逻辑保持不变
                const thinkingBubble = createMessageBubble('...', 'received');
                messagesEl.appendChild(thinkingBubble);
                messagesEl.scrollTop = messagesEl.scrollHeight;

                const result = await callApi(apiMessages);
                thinkingBubble.remove();

                let responseText, newIndex;
                if (result.success) {
                    responseText = result.message;
                    newIndex = saveMessage(currentChatContact.id, {sender: 'contact', text: responseText});
                } else {
                    // 创建一个用户友好的错误消息
                    responseText = `[网络错误] 唔...连接AI服务器失败了，请检查网络或API设置再试一次哦。(${result.message})`;
                    newIndex = saveMessage(currentChatContact.id, {
                        sender: 'contact',
                        text: responseText // 直接保存友好的错误消息
                    });
                }


                const messageRow = _createMessageDOM(currentChatContact.id, {
                    sender: 'contact',
                    text: responseText
                }, newIndex);
                if (!result.success) {
                    messageRow.querySelector('.chat-bubble').style.backgroundColor = '#ffebee';
                    messageRow.querySelector('.chat-bubble').style.color = '#c62828';
                }
                messagesEl.appendChild(messageRow);

                renderContacts(contactsData);
                messagesEl.scrollTop = messagesEl.scrollHeight;
                getReplyBtn.disabled = false;
                chatInput.disabled = false;
                chatInput.focus();
            }


            /**
             * [修复版] 保存消息到localStorage
             * @param {string|number} contactId - 联系人ID
             * @param {object} message - 消息对象，可能包含 sender, text, quote 等字段
             * @returns {number} 新消息的索引
             */
            function saveMessage(contactId, message) {
                const chatHistory = JSON.parse(localStorage.getItem('phoneChatHistory') || '{}');
                if (!chatHistory[contactId]) {
                    chatHistory[contactId] = [];
                }

                // ✅ 核心修复：保存完整的消息对象，而不仅仅是 sender 和 text
                // 这样 quote 字段（如果存在）也会被保存
                const messageToSave = {
                    sender: message.sender,
                    text: message.text
                };

                // 如果消息中包含引用信息，也一并保存
                if (message.quote) {
                    messageToSave.quote = message.quote;
                }

                chatHistory[contactId].push(messageToSave);
                try {
                    localStorage.setItem('phoneChatHistory', JSON.stringify(chatHistory));
                } catch (e) {
                    console.error('保存失败:', e);
                    alert('存储空间不足，请清理数据');
                }

                return chatHistory[contactId].length - 1;
            }


            // ========== 开始：粘贴这个【修正版】的 editCurrentContact 函数 ==========
            function editCurrentContact() {
                if (!currentChatContact) return;

                // 获取弹窗元素
                const modal = document.getElementById('characterCardModal');
                // 将正在编辑的联系人ID存储到弹窗的data属性中
                modal.dataset.editingId = currentChatContact.id;

                // --- 填充表单数据 (逻辑不变) ---
                document.getElementById('char-name').value = currentChatContact.name;
                document.getElementById('char-persona').value = currentChatContact.status;
                // ... (其他填充代码保持不变) ...
                const contactAvatar = currentChatContact.avatar;
                const isContactUrl = contactAvatar && (contactAvatar.startsWith('http') || contactAvatar.startsWith('data:'));
                document.getElementById('avatar-preview').src = isContactUrl ? contactAvatar : 'data:image/gif;base64,R0lGODlhAQABAAD/ACwAAAAAAQABAAACADs=';

                document.getElementById('user-name').value = userProfile.name;
                document.getElementById('user-persona').value = userProfile.persona;
                const userAvatar = userProfile.avatar;
                const isUserUrl = userAvatar && (userAvatar.startsWith('http') || userAvatar.startsWith('data:'));
                document.getElementById('user-avatar-preview').src = isUserUrl ? userAvatar : 'data:image/gif;base64,R0lGODlhAQABAAD/ACwAAAAAAQABAAACADs=';

                // ▼▼▼ 添加此行 ▼▼▼
                renderCharacterWorldbooksList(currentChatContact.boundWorldbooks || []);

                openCharacterCardPage();
            }


            function showSuccessModal(title = '操作成功', message = '你的设置已保存。', duration = 1500) {
                const modal = document.getElementById('successModal');
                const modalTitle = document.getElementById('successModalTitle');
                const modalMessage = document.getElementById('successModalMessage');

                modalTitle.textContent = title;
                modalMessage.textContent = message;

                modal.style.display = 'flex';

                setTimeout(() => modal.classList.add('show'), 10);

                setTimeout(() => {
                    modal.classList.remove('show');
                    setTimeout(() => modal.style.display = 'none', 300);
                }, duration);
            }

            function deleteApiConfig(index) {
                const configToDelete = globalConfig.apiConfigs[index];
                if (!configToDelete) return;

                if (confirm(`你确定要删除配置 "${configToDelete.name}" 吗？`)) {
                    globalConfig.apiConfigs.splice(index, 1);

                    if (globalConfig.activeApiConfig === index) {
                        globalConfig.activeApiConfig = null;
                        clearApiForm();
                    } else if (globalConfig.activeApiConfig > index) {
                        globalConfig.activeApiConfig--;
                    }

                    console.log(`配置 "${configToDelete.name}" 已删除。`);

                    saveGlobalConfig();
                    renderApiConfigs();

                    showSuccessModal('删除成功', `配置 "${configToDelete.name}" 已被移除。`);
                }
            }

            /**
             * [新增] 保存密友列表到localStorage
             */
            function saveSweetheartContacts() {
                try {
                    localStorage.setItem('phoneSweetheartContactsData', JSON.stringify(sweetheartContactsData));
                } catch (e) {
                    console.error('保存密友列表到 localStorage 失败:', e);
                }
            }


            function saveGlobalConfig() {
                try {
                    const configToSave = {
                        apiConfigs: globalConfig.apiConfigs,
                        activeApiConfig: globalConfig.activeApiConfig,
                    };
                    localStorage.setItem('phoneGlobalConfig', JSON.stringify(configToSave));
                } catch (e) {
                    console.error('保存全局配置到 localStorage 失败:', e);
                }
            }

            function loadGlobalConfig() {
                try {
                    const savedConfig = localStorage.getItem('phoneGlobalConfig');
                    if (savedConfig) {
                        const parsedConfig = JSON.parse(savedConfig);
                        Object.assign(globalConfig, parsedConfig);
                        console.log('成功从 localStorage 加载API配置。');
                    }
                } catch (e) {
                    console.error('从 localStorage 加载API配置失败:', e);
                }
            }

            function openChatSettings() {
                document.getElementById('chatSettingsPage').classList.add('show');
            }

            function closeChatSettings() {
                document.getElementById('chatSettingsPage').classList.remove('show');
            }

            function clearCurrentChatHistory() {
                if (!currentChatContact) return; // 安全检查，确保当前有聊天对象

                // 弹出确认框，防止用户误操作
                if (confirm(`确定要清空与 "${currentChatContact.name}" 的所有聊天记录吗？`)) {
                    // 从 localStorage 读取聊天记录
                    const chatHistory = JSON.parse(localStorage.getItem('phoneChatHistory') || '{}');

                    // 如果存在当前联系人的记录，就删除它
                    if (chatHistory[currentChatContact.id]) {
                        delete chatHistory[currentChatContact.id];
                        // 将修改后的数据存回 localStorage
                        try {
                            localStorage.setItem('phoneChatHistory', JSON.stringify(chatHistory));
                        } catch (e) {
                            console.error('保存失败:', e);
                            alert('存储空间不足，请清理数据');
                        }

                        // 重新加载聊天界面，使其显示为空
                        openChat(currentChatContact);

                        // 关闭设置页并显示成功提示
                        closeChatSettings();
                        showSuccessModal('操作成功', '聊天记录已清空。');
                    }
                }
            }


            /* --- 复制并粘贴这段代码 --- */
            function applyCodeScrollSetting(isEnabled) {
                if (isEnabled) {
                    document.body.classList.add('code-scrolling-enabled');
                } else {
                    document.body.classList.remove('code-scrolling-enabled');
                }
            }

            /* ------------------------- */


            // ========== 开始：这是你需要粘贴的新JS代码 ==========

            /**
             * 应用聊天背景图的核心函数
             * @param {string} imageUrl - 图片的URL或Base64数据。如果为空字符串，则恢复默认背景。
             */
            function applyChatBackground(imageUrl) {
                const chatPage = document.getElementById('chatPage');
                if (imageUrl) {
                    // 设置背景图片
                    chatPage.style.backgroundImage = `url('${imageUrl}')`;
                    chatPage.style.backgroundSize = 'cover';
                    chatPage.style.backgroundPosition = 'center';
                    localStorage.setItem('chatBackground', imageUrl);
                    showChatBgStatus('背景已应用');
                } else {
                    // 恢复默认背景
                    chatPage.style.backgroundImage = '';
                    localStorage.removeItem('chatBackground');
                    showSuccessModal('操作成功', '已恢复为默认背景。');
                }
            }

            /**
             * 从本地文件上传处理函数
             * @param {Event} event - 文件输入框的change事件对象
             */
            function handleChatBgUpload(event) {
                const file = event.target.files[0];
                if (!file) return;

                // 使用FileReader将图片转为Base64，以便保存和预览
                const reader = new FileReader();
                reader.onload = (e) => {
                    applyChatBackground(e.target.result);
                };
                reader.onerror = () => {
                    showChatBgStatus('读取文件失败', 'error');
                };
                reader.readAsDataURL(file);
            }

            /**
             * 切换URL输入框的显示/隐藏
             */
            function toggleChatBgUrlInput() {
                const urlBox = document.getElementById('chat-bg-url-box');
                urlBox.classList.toggle('show');
            }

            /**
             * 从URL输入框应用背景图
             */
            function applyChatBgFromUrl() {
                const urlInput = document.getElementById('chat-bg-url-input');
                const url = urlInput.value.trim();
                if (url) {
                    applyChatBackground(url);
                    urlInput.value = '';
                    toggleChatBgUrlInput(); // 应用后自动隐藏输入框
                } else {
                    showChatBgStatus('请输入有效的URL', 'error');
                }
            }

            /**
             * 在UI上显示状态消息
             * @param {string} message - 要显示的消息
             * @param {string} type - 消息类型 ('success' 或 'error')
             */
            function showChatBgStatus(message, type = 'success') {
                const statusEl = document.getElementById('chat-bg-status');
                statusEl.textContent = message;
                statusEl.className = 'status-message' + (type === 'error' ? ' error' : '');
                setTimeout(() => {
                    statusEl.textContent = '';
                }, 3000);
            }

            /**
             * 加载已保存的聊天背景图 (在应用初始化时调用)
             */
            function loadChatBackground() {
                const savedBg = localStorage.getItem('chatBackground');
                if (savedBg) {
                    applyChatBackground(savedBg);
                }
            }

            /* ========== 开始：粘贴这段全新的JS代码块 ========== */
            function applyChatStyle(style) {
                const chatPage = document.getElementById('chatPage');
                const selector = document.getElementById('messageStyleSelector');

                if (style === 'simple') {
                    chatPage.classList.add('simple-style');
                } else {
                    chatPage.classList.remove('simple-style');
                }

                // 更新UI选择器状态
                if (selector) {
                    selector.querySelectorAll('.segmented-option').forEach(opt => {
                        opt.classList.toggle('active', opt.dataset.style === style);
                    });
                }

                // 保存选择
                localStorage.setItem('chatMessageStyle', style);
            }


            function setupStyleSelector() {
                const selector = document.getElementById('messageStyleSelector');
                if (selector) {
                    selector.addEventListener('click', (event) => {
                        const target = event.target.closest('.segmented-option');
                        if (target && !target.classList.contains('active')) {
                            const newStyle = target.dataset.style;
                            applyChatStyle(newStyle);
                        }
                    });
                }
            }

            function applyFullscreenSetting(isEnabled) {
                if (isEnabled) {
                    document.body.classList.add('fullscreen-enabled');
                } else {
                    document.body.classList.remove('fullscreen-enabled');
                }
            }

            /* ========== 开始：用这段全新的代码替换旧的 setupAttachmentMenu 函数 ========== */

            function setupAttachmentMenu() {
                // 1. 获取所有相关的 DOM 元素
                const showMenuBtn = document.getElementById('showAttachmentMenuBtn');
                const menu = document.getElementById('attachmentMenu');
                const fileInput = document.getElementById('fileInput');
                const imageInput = document.getElementById('imageInput'); // 图片上传暂时只做前端预览
                const uploadFileBtn = document.getElementById('uploadFileBtn');
                const uploadImageBtn = document.getElementById('uploadImageBtn');

                // 2. 点击“+”按钮时，切换菜单的显示/隐藏
                showMenuBtn.addEventListener('click', (event) => {
                    event.stopPropagation();
                    menu.classList.toggle('show');
                });

                // 3. 点击“上传文件”菜单项时，触发隐藏的文件选择框
                uploadFileBtn.addEventListener('click', () => {
                    fileInput.click();
                    menu.classList.remove('show');
                });

                // 4. 点击“上传图片”菜单项（暂时只做预览，不上传）
                uploadImageBtn.addEventListener('click', () => {
                    imageInput.click();
                    menu.classList.remove('show');
                });

                // 5. 【核心改造】当用户选择了文件后，上传文件并获取AI回复
                fileInput.addEventListener('change', async (event) => {
                    const file = event.target.files[0];
                    if (!file) return;

                    // a. 先在界面上显示“文件已发送”
                    const userMessageText = `📎 文件已发送: ${file.name}`;
                    simulateSendingMessage(userMessageText);

                    // b. 显示一个“AI正在思考”的提示
                    const messagesEl = document.getElementById('chatMessages');
                    const thinkingBubble = _createMessageDOM(currentChatContact.id, {
                        sender: 'contact',
                        text: '正在读取和分析文件...'
                    }, -1);
                    messagesEl.appendChild(thinkingBubble);
                    messagesEl.scrollTop = messagesEl.scrollHeight;

                    try {
                        // c. 调用函数将文件发送到我们的后端（Edge Function）
                        const aiResponse = await uploadFileAndGetAiResponse(file);

                        // d. 移除思考提示，显示AI的真实回复
                        thinkingBubble.remove();
                        const newIndex = saveMessage(currentChatContact.id, {
                            sender: 'contact',
                            text: aiResponse
                        });
                        const messageRow = _createMessageDOM(currentChatContact.id, {
                            sender: 'contact',
                            text: aiResponse
                        }, newIndex);
                        messagesEl.appendChild(messageRow);

                    } catch (error) {
                        // e. 如果出错，显示错误信息
                        thinkingBubble.remove();
                        const errorText = `处理文件失败: ${error.message}`;
                        const newIndex = saveMessage(currentChatContact.id, {
                            sender: 'contact',
                            text: errorText
                        });
                        const messageRow = _createMessageDOM(currentChatContact.id, {
                            sender: 'contact',
                            text: errorText
                        }, newIndex);
                        messageRow.querySelector('.chat-bubble').style.backgroundColor = '#ffebee';
                        messageRow.querySelector('.chat-bubble').style.color = '#c62828';
                        messagesEl.appendChild(messageRow);
                    } finally {
                        messagesEl.scrollTop = messagesEl.scrollHeight;
                        event.target.value = ''; // 重置input
                    }
                });

                // 图片选择的逻辑保持不变，仅作本地预览
                // ========== 开始：粘贴这个全新的 imageInput 事件监听器 ==========
                imageInput.addEventListener('change', (event) => {
                    const file = event.target.files[0];
                    if (!file || !currentChatContact) {
                        event.target.value = ''; // 重置 input 以便下次能选择相同文件
                        return;
                    }

                    const reader = new FileReader();
                    reader.onload = async function (e) {
                        const base64Image = e.target.result;

                        // 1. [UI] 先在用户侧显示发送的图片
                        const imageHtmlForDisplay = `<img src="${base64Image}" style="max-width: 150px; border-radius: 10px;" alt="${file.name}">`;
                        simulateSendingMessage(imageHtmlForDisplay);

                        // 2. [UI] 显示 "AI 正在分析..." 的提示
                        const messagesEl = document.getElementById('chatMessages');
                        const thinkingBubble = _createMessageDOM(currentChatContact.id, {
                            sender: 'contact',
                            text: '正在分析图片...'
                        }, -1);
                        // 使用-1索引表示这是临时消息
                        messagesEl.appendChild(thinkingBubble);
                        messagesEl.scrollTop = messagesEl.scrollHeight;

                        // 3. [核心] 构建发送给 Vision API 的消息体
                        const visionMessage = {
                            role: 'user',
                            content: [
                                {
                                    type: 'text',
                                    // ========== 开始：仅修改 visionMessage 对象中的这一行 ==========
                                    text: document.getElementById('chatInput').value.trim() || '这张图片里有什么？请详细描述一下。'
                                    // 这是给AI的指令
                                },
                                {
                                    type: 'image_url',
                                    image_url: {
                                        url: base64Image
                                    }
                                }
                            ]
                        };
                        // 4. [API] 调用API
                        // 我们只把这条识图消息发给AI，不一定需要带上之前的聊天记录，这样更专注
                        const result = await callApi([visionMessage]);
                        document.getElementById('chatInput').value = '';
                        chatInputArea.classList.remove('has-text');
                        // 6. [UI] 移除"正在分析"的提示
                        thinkingBubble.remove();

                        let aiResponseText;
                        if (result.success) {
                            aiResponseText = result.message;
                        } else {
                            aiResponseText = `抱歉，图片识别失败了: ${result.message}`;
                        }

                        // 6. [数据] 保存AI的回复
                        const newIndex = saveMessage(currentChatContact.id, {
                            sender: 'contact',
                            text: aiResponseText
                        });

                        // 7. [UI] 显示AI的最终回复
                        const messageRow = _createMessageDOM(currentChatContact.id, {
                            sender: 'contact',
                            text: aiResponseText
                        }, newIndex);

                        // 如果是错误信息，给个特殊样式
                        if (!result.success) {
                            messageRow.querySelector('.chat-bubble').style.backgroundColor = '#ffebee';
                            messageRow.querySelector('.chat-bubble').style.color = '#c62828';
                        }

                        messagesEl.appendChild(messageRow);
                        messagesEl.scrollTop = messagesEl.scrollHeight;

                        // 8. 更新联系人列表的最后消息
                        renderContacts(contactsData);
                    };

                    reader.readAsDataURL(file); // 读取图片文件为 Base64
                    event.target.value = ''; // 读取后立即清空，确保下次还能触发 change 事件
                });
// ========== 结束：粘贴全新的 imageInput 事件监听器 ==========


                // 7. 关闭菜单的逻辑
                document.addEventListener('click', () => {
                    if (menu.classList.contains('show')) {
                        menu.classList.remove('show');
                    }
                });
                menu.addEventListener('click', (event) => event.stopPropagation());
            }

            /**
             * 【核心函数】上传文件到后端并等待AI响应
             * @param {File} file 用户选择的文件对象
             * @returns {Promise<string>} AI的回复文本
             */
            async function uploadFileAndGetAiResponse(file) {
                // 假设你的 Supabase Edge Function 地址是这个
                // 你需要先创建这个 Function，见第2步
                const functionUrl = `${globalConfig.database.supabaseUrl}/functions/v1/analyze-file`;
                const supabaseKey = globalConfig.database.supabaseKey;

                if (!functionUrl || !supabaseKey) {
                    throw new Error("Supabase 配置不完整，请在设置中检查 URL 和 Key。");
                }

                // 使用 FormData 来包装文件，适合文件上传
                const formData = new FormData();
                formData.append('file', file);

                // 获取当前聊天记录作为上下文
                const chatHistory = JSON.parse(localStorage.getItem('phoneChatHistory') || '{}');
                const historyMessages = chatHistory[currentChatContact.id] || [];

                // 将历史记录和角色设定一起发送给后端
                formData.append('chatHistory', JSON.stringify(historyMessages));
                formData.append('persona', currentChatContact.status || '你是一个乐于助人的AI助手');

                const response = await fetch(functionUrl, {
                    method: 'POST',
                    headers: {
                        'Authorization': `Bearer ${supabaseKey}`
                        // 注意：当使用 FormData 时，浏览器会自动设置 Content-Type，不要手动设置
                    },
                    body: formData
                });

                if (!response.ok) {
                    const errorData = await response.json();
                    throw new Error(errorData.error || '服务器返回错误');
                }

                const result = await response.json();
                return result.reply;
            }

            /* ========== 结束：替换代码 ========== */


            // 创建一个辅助函数来模拟发送消息，避免代码重复
            function simulateSendingMessage(messageText) {
                const messagesEl = document.getElementById('chatMessages');
                if (!messageText || !currentChatContact) return;

                // 保存消息记录
                const newIndex = saveMessage(currentChatContact.id, {sender: 'user', text: messageText});

                // 创建并显示消息 DOM
                const messageRow = _createMessageDOM(currentChatContact.id, {
                    sender: 'user',
                    text: messageText
                }, newIndex);
                messagesEl.appendChild(messageRow);

                // 更新联系人列表的最后消息并滚动到底部
                renderContacts(contactsData);
                messagesEl.scrollTop = messagesEl.scrollHeight;
            }

            /* ========== 结束：粘贴 JavaScript 代码块 ========== */

            /* ========== 开始：粘贴悬浮球的全新JavaScript逻辑 ========== */
            // ========== 开始：粘贴这段【最终修正版】的悬浮球JS逻辑 ==========

            function initializeFloatingBall() {
                const ball = document.getElementById('floatingBall');
                const phone = document.querySelector('.phone');

                if (!ball || !phone) return;

                let isDragging = false;
                let hasMoved = false; // 同样用于区分点击和拖拽
                let startX, startY;
                let initialLeft, initialTop;

                // 智能吸附到边缘的函数（保持不变）
                const snapToEdge = () => {
                    const phoneRect = phone.getBoundingClientRect();
                    const ballRect = ball.getBoundingClientRect();
                    const screenInnerWidth = phoneRect.width - 24;
                    let currentLeft = parseFloat(ball.style.left || 0);

                    if (currentLeft + ballRect.width / 2 < screenInnerWidth / 2) {
                        ball.style.left = '12px';
                    } else {
                        ball.style.left = `${phoneRect.width - ballRect.width - 12}px`;
                    }
                };

                // 【 handleClick 函数被简化 】
                // 它现在只负责核心的点击业务，不再做判断
                const handleClick = () => {
                    console.log('悬浮球被点击了!');
                    toggleFloatingBallMenu(); // 打开或关闭菜单
                };

                const startDrag = (e) => {
                    // e.preventDefault() 会阻止后续的 click 事件，但我们这里不能阻止，否则桌面端的 click 会失效。
                    // 我们在 touchend 中有选择地阻止。

                    isDragging = true;
                    hasMoved = false; // 每次开始时重置
                    ball.classList.add('dragging');

                    const touch = e.touches ? e.touches[0] : e;
                    startX = touch.clientX;
                    startY = touch.clientY;

                    const ballRect = ball.getBoundingClientRect();
                    const phoneRect = phone.getBoundingClientRect();
                    initialLeft = ballRect.left - phoneRect.left;
                    initialTop = ballRect.top - phoneRect.top;

                    // 统一使用 left/top 定位，后续计算更简单
                    ball.style.left = `${initialLeft}px`;
                    ball.style.top = `${initialTop}px`;
                    ball.style.right = 'auto';
                    ball.style.bottom = 'auto';

                    document.addEventListener('mousemove', onDrag);
                    document.addEventListener('touchmove', onDrag, {passive: false});
                    document.addEventListener('mouseup', endDrag);
                    document.addEventListener('touchend', endDrag);
                };

                const onDrag = (e) => {
                    if (!isDragging) return;

                    // 【优化】移动距离超过一个微小阈值才判定为拖拽
                    const touch = e.touches ? e.touches[0] : e;
                    if (!hasMoved && (Math.abs(touch.clientX - startX) > 5 || Math.abs(touch.clientY - startY) > 5)) {
                        hasMoved = true;
                    }

                    // 只有真正拖动时才阻止页面滚动
                    if (hasMoved && e.cancelable) e.preventDefault();

                    const deltaX = touch.clientX - startX;
                    const deltaY = touch.clientY - startY;

                    const phoneRect = phone.getBoundingClientRect();
                    const ballRect = ball.getBoundingClientRect();

                    let newLeft = initialLeft + deltaX;
                    let newTop = initialTop + deltaY;

                    // 更可靠的边界检测
                    const minX = 12;
                    const maxX = phoneRect.width - ballRect.width - 12;
                    const minY = 12;
                    const maxY = phoneRect.height - ballRect.height - 12;

                    newLeft = Math.max(minX, Math.min(newLeft, maxX));
                    newTop = Math.max(minY, Math.min(newTop, maxY));

                    ball.style.left = `${newLeft}px`;
                    ball.style.top = `${newTop}px`;
                };

                // 【 endDrag 函数是修复的核心 】
                const endDrag = (e) => {
                    if (!isDragging) return;

                    // 1. 如果没有拖动，就判定为 "Tap"（轻点）
                    if (!hasMoved) {
                        // [关键修复] 如果是触摸事件，我们主动阻止默认行为。
                        // 这能有效防止大约300ms后浏览器自动触发的 `click` 事件，从而避免了双重调用。
                        if (e.type === 'touchend') {
                            e.preventDefault();
                        }
                        handleClick(); // 手动执行点击逻辑
                    } else {
                        // 2. 如果拖动了，执行吸附边缘的逻辑
                        snapToEdge();
                    }

                    // 3. 清理工作
                    isDragging = false;
                    ball.classList.remove('dragging');

                    document.removeEventListener('mousemove', onDrag);
                    document.removeEventListener('touchmove', onDrag);
                    document.removeEventListener('mouseup', endDrag);
                    document.removeEventListener('touchend', endDrag);
                };

                // 【 绑定事件 】
                // 我们同时监听 mousedown 和 touchstart，它们都调用 startDrag
                ball.addEventListener('mousedown', startDrag);
                ball.addEventListener('touchstart', startDrag, {passive: false});

                // 我们为桌面端保留 click 事件。因为在 touchend 中 preventDefault() 了，
                // 所以在移动端，这个 click 事件将不会被触发，完美解决了冲突。
                ball.addEventListener('click', (e) => {
                    // 为了防止极少数情况下 touchend 的 preventDefault 失效，增加一个判断：
                    // 如果是拖拽过的，就不要执行点击。
                    if (hasMoved) {
                        e.stopPropagation();
                        return;
                    }
                    // 对于桌面端，因为没有 touchend，所以会正常执行 handleClick
                    if (e.detail > 0) { // e.detail > 0 确保这是真正的用户鼠标点击
                        handleClick();
                    }
                });
            }

            // ========== 结束：粘贴【最终修正版】的悬浮球JS逻辑 ==========


            // ========== 开始：粘贴这个全新的 JavaScript 函数 ==========

            /**
             * 清空所有本地存储的数据
             * 这是一个危险操作，执行前会要求用户确认。
             */
            function clearAllData() {
                // 1. 弹出确认框，给用户最后一次反悔的机会
                const confirmation = confirm(
                    "⚠️ 警告！\n\n你确定要清空所有数据吗？\n\n此操作将不可逆转地删除：\n- 所有API、数据库和云存储设置\n- 所有联系人、密友和聊天记录\n- 所有自定义图标、壁纸和组件\n- 所有世界书和分组\n- 其他所有个性化配置\n\n应用将恢复到初始状态。"
                );

                // 2. 检查用户的选择
                if (confirmation) {
                    // 3. 如果用户点击“确定”，则清空 localStorage
                    localStorage.clear();

                    // 4. 显示一个操作成功的提示
                    alert("所有数据已成功清除。应用即将重新加载。");

                    // 5. 重新加载页面，让应用以全新的状态启动
                    location.reload();
                } else {
                    // 如果用户点击“取消”，则不做任何事
                    console.log("用户取消了清空所有数据的操作。");
                }
            }

            // ========== 结束：粘贴代码 ==========


            /* ========== 开始：粘贴这个全新的 JavaScript 函数 ========== */

            /**
             * 根据传入的状态，显示或隐藏悬浮球
             * @param {boolean} isEnabled - true 为显示, false 为隐藏
             */
            function applyFloatingBallSetting(isEnabled) {
                const ball = document.getElementById('floatingBall');
                if (ball) {
                    ball.style.display = isEnabled ? 'flex' : 'none';
                }
            }

            // ========== 图标收藏栏功能 ==========

            let dockedIcons = []; // 存储在栏目中的图标数据

            /**
             * 打开/关闭悬浮球菜单
             */
            function toggleFloatingBallMenu() {
                const menu = document.getElementById('floatingBallMenu');
                menu.classList.toggle('show');
            }

            /**
             * 关闭悬浮球菜单
             */
            function closeFloatingBallMenu() {
                const menu = document.getElementById('floatingBallMenu');
                menu.classList.remove('show');
            }

            /**
             * 打开/关闭图标收藏栏
             */
            function toggleIconDockPanel() {
                const panel = document.getElementById('iconDockPanel');
                panel.classList.toggle('show');
                closeFloatingBallMenu();

                // 如果是打开状态，渲染图标
                if (panel.classList.contains('show')) {
                    renderDockedIcons();
                }
            }

            /**
             * 关闭图标收藏栏
             */
            function closeIconDockPanel() {
                const panel = document.getElementById('iconDockPanel');
                panel.classList.remove('show');
            }

            /**
             * 渲染栏目中的图标
             */
            function renderDockedIcons() {
                const container = document.getElementById('dockPanelContent');

                if (dockedIcons.length === 0) {
                    container.innerHTML = '<div class="dock-panel-empty">拖动图标到这里收藏</div>';
                    return;
                }

                container.innerHTML = '';

                dockedIcons.forEach((iconData, index) => {
                    const iconEl = document.createElement('div');
                    iconEl.className = 'dock-panel-icon';
                    iconEl.dataset.iconId = iconData.id;
                    iconEl.dataset.sourceGrid = iconData.sourceGrid;
                    iconEl.dataset.dockIndex = index;

                    // 构建图标HTML
                    const customIcon = globalConfig.customIcons[iconData.id];
                    let iconContent;

                    if (customIcon) {
                        iconContent = `<img src="${customIcon}" alt="${iconData.label}">`;
                    } else if (iconData.icon && (iconData.icon.startsWith('http') || iconData.icon.startsWith('data:'))) {
                        iconContent = `<img src="${iconData.icon}" alt="${iconData.label}">`;
                    } else {
                        iconContent = iconData.icon || '📱';
                    }

                    iconEl.innerHTML = `
            <div class="icon-wrapper">${iconContent}</div>
            <div class="app-label">${iconData.label}</div>
        `;

                    // 添加长按拖出功能
                    addDockIconDragListeners(iconEl, iconData);

                    // 点击功能
                    iconEl.addEventListener('click', (e) => {
                        if (!iconData.clickable) return;
                        if (iconData.id === 'settings') {
                            closeIconDockPanel();
                            openSettings();
                        } else if (iconData.id === 'worldbook') {
                            closeIconDockPanel();
                            openWorldbook();
                        }
                    });

                    container.appendChild(iconEl);
                });
            }

            /**
             * 为栏目中的图标添加拖出功能
             */
            function addDockIconDragListeners(el, iconData) {
                let longPressTimer = null;
                let startPos = {x: 0, y: 0};
                let isDraggingFromDock = false;

                const startDrag = (e) => {
                    const touch = e.touches ? e.touches[0] : e;
                    startPos = {x: touch.clientX, y: touch.clientY};

                    longPressTimer = setTimeout(() => {
                        isDraggingFromDock = true;
                        el.style.opacity = '0.5';
                        createDragGhost(iconData, touch.clientX, touch.clientY);
                    }, 500);
                };

                const endDrag = () => {
                    clearTimeout(longPressTimer);
                    if (isDraggingFromDock) {
                        el.style.opacity = '';
                        isDraggingFromDock = false;
                    }
                };

                el.addEventListener('mousedown', startDrag);
                el.addEventListener('touchstart', startDrag, {passive: true});
                el.addEventListener('mouseup', endDrag);
                el.addEventListener('touchend', endDrag);
            }

            let dragGhost = null;
            let ghostIconData = null;

            /**
             * 创建拖动的幽灵元素
             */
            function createDragGhost(iconData, x, y) {
                // 🔧 新增：设置全局拖拽标志
                state.isDraggingFromDock = true;
                // 移除旧的幽灵元素
                if (dragGhost) {
                    dragGhost.remove();
                }

                ghostIconData = iconData;

                dragGhost = document.createElement('div');
                dragGhost.className = 'app-icon dragging';
                dragGhost.style.position = 'fixed';
                dragGhost.style.zIndex = '3000';
                dragGhost.style.pointerEvents = 'none';
                dragGhost.style.left = `${x}px`;
                dragGhost.style.top = `${y}px`;
                dragGhost.style.transform = 'translate(-50%, -50%) scale(1.1)';

                const customIcon = globalConfig.customIcons[iconData.id];
                let iconContent;

                if (customIcon) {
                    iconContent = `<img src="${customIcon}" alt="">`;
                } else if (iconData.icon && (iconData.icon.startsWith('http') || iconData.icon.startsWith('data:'))) {
                    iconContent = `<img src="${iconData.icon}" alt="">`;
                } else {
                    iconContent = iconData.icon || '📱';
                }

                dragGhost.innerHTML = `
        <div class="icon-wrapper">${iconContent}</div>
        <div class="app-label">${iconData.label}</div>
    `;

                document.body.appendChild(dragGhost);

                // 添加移动和释放事件
                document.addEventListener('mousemove', moveDragGhost);
                document.addEventListener('touchmove', moveDragGhost, {passive: false});
                document.addEventListener('mouseup', dropDragGhost);
                document.addEventListener('touchend', dropDragGhost);
            }

            /**
             * 移动幽灵元素
             */
            function moveDragGhost(e) {
                if (!dragGhost) return;

                if (e.cancelable) e.preventDefault();

                const touch = e.touches ? e.touches[0] : e;
                dragGhost.style.left = `${touch.clientX}px`;
                dragGhost.style.top = `${touch.clientY}px`;
            }

            /**
             * 释放幽灵元素
             */
            function dropDragGhost(e) {
                if (!dragGhost || !ghostIconData) {
                    cleanupDragGhost();
                    return;
                }

                const touch = e.changedTouches ? e.changedTouches[0] : e;

                // 检测是否释放在页面区域
                const grids = [document.getElementById('grid1'), document.getElementById('grid2')];
                let droppedOnGrid = false;

                grids.forEach((grid, pageIndex) => {
                    const rect = grid.getBoundingClientRect();
                    if (touch.clientX >= rect.left && touch.clientX <= rect.right &&
                        touch.clientY >= rect.top && touch.clientY <= rect.bottom) {
                        droppedOnGrid = true;

                        // 将图标从栏目移回页面
                        moveIconBackToGrid(ghostIconData, grid, touch.clientX - rect.left, touch.clientY - rect.top, pageIndex + 1);
                    }
                });
                state.lastDragEndTime = Date.now(); // ✅ 新增：无论是否成功放下，都记录拖拽结束时间
                cleanupDragGhost();
            }

            /**
             * 清理拖拽状态
             */
            function cleanupDragGhost() {
                if (dragGhost) {
                    dragGhost.remove();
                    dragGhost = null;
                }
                ghostIconData = null;
                // 🔧 新增：清除拖拽标志
                state.isDraggingFromDock = false;
                document.removeEventListener('mousemove', moveDragGhost);
                document.removeEventListener('touchmove', moveDragGhost);
                document.removeEventListener('mouseup', dropDragGhost);
                document.removeEventListener('touchend', dropDragGhost);
            }

            /**
             * 将图标从栏目移回网格
             */
            function moveIconBackToGrid(iconData, grid, dropX, dropY, pageNum) {
                const ROW_HEIGHT_PX = 94;
                const GAP_PX = 14;
                const gridRect = grid.getBoundingClientRect();

                let col = Math.floor(dropX / (gridRect.width / 4));
                let row = Math.floor(dropY / (ROW_HEIGHT_PX + GAP_PX));

                col = Math.max(0, Math.min(col, 3));
                row = Math.max(0, Math.min(row, 5));

                const pageKey = `page${pageNum}`;

                // 检查位置是否被占用
                if (isOccupied(pageKey, row, col, iconData.id)) {
                    showSuccessModal('提示', '该位置已被占用，请拖到其他位置', 1500);
                    return;
                }

                // 从栏目中移除
                const dockIndex = dockedIcons.findIndex(icon => icon.id === iconData.id);
                if (dockIndex !== -1) {
                    dockedIcons.splice(dockIndex, 1);
                    saveDockedIcons();
                }

                // 添加回网格
                const appData = {
                    ...iconData,
                    row,
                    col
                };

                state.appLayouts[pageKey].push(appData);
                saveLayoutToLocalStorage();

                // 重新渲染
                const el = createElement(appData, grid);
                renderDockedIcons();

                showSuccessModal('移动成功', `已将"${iconData.label}"移动到第${pageNum}页`, 1500);
            }

            /**
             * 保存栏目图标到localStorage
             */
            function saveDockedIcons() {
                try {
                    localStorage.setItem('phoneDockedIcons', JSON.stringify(dockedIcons));
                } catch (e) {
                    console.error('保存栏目图标失败:', e);
                }
            }

            /**
             * 加载栏目图标
             */
            function loadDockedIcons() {
                try {
                    const saved = localStorage.getItem('phoneDockedIcons');
                    if (saved) {
                        dockedIcons = JSON.parse(saved);
                        console.log('成功加载栏目图标，共', dockedIcons.length, '个');
                    }
                } catch (e) {
                    console.error('加载栏目图标失败:', e);
                }
            }

            /**
             * 将图标添加到栏目
             */
            function addIconToDockPanel(element) {
                const iconId = element.dataset.id;
                const grid = element.parentElement;
                const pageKey = grid.id === 'grid1' ? 'page1' : 'page2';

                // 查找图标数据
                const appData = state.appLayouts[pageKey].find(app => app.id === iconId);
                if (!appData) {
                    console.error('未找到图标数据:', iconId);
                    return;
                }

                // 检查是否已在栏目中
                if (dockedIcons.some(icon => icon.id === iconId)) {
                    showSuccessModal('提示', '该图标已在收藏栏中', 1500);
                    return;
                }

                // 保存源网格信息
                const iconData = {
                    ...appData,
                    sourceGrid: pageKey,
                    sourceRow: appData.row,
                    sourceCol: appData.col
                };

                // 添加到栏目
                dockedIcons.push(iconData);
                saveDockedIcons();

                // 从原页面移除
                state.appLayouts[pageKey] = state.appLayouts[pageKey].filter(app => app.id !== iconId);
                saveLayoutToLocalStorage();
                element.remove();

                // 刷新栏目显示
                renderDockedIcons();

                showSuccessModal('添加成功', `已将"${iconData.label}"添加到收藏栏`, 1500);
            }


            // ========== 开始：新增的密友列表相关函数 ==========

            /**
             * 打开密友列表页面
             */
            function openSweetheartList() {
                document.getElementById('sweetheartListPage').classList.add('show');
                // 每次打开时都重新渲染列表，以保证数据最新
                renderSweetheartList();
            }

            /**
             * 关闭密友列表页面
             */
            function closeSweetheartList(isNavigatingBack = false) {
                document.getElementById('sweetheartListPage').classList.remove('show');

                // 只有在明确是“返回”操作时，才跳转回世界选择页面
                if (isNavigatingBack && currentWorldId) {
                    setTimeout(() => {
                        openWorldSelect();
                    }, 300);
                }
            }


            /**
             * 渲染密友列表
             * (这里我们复用现有的 contactsData 数据源，但使用全新的外观)
             */
            /**
             * [最终修正版] 渲染密友列表
             */
            function renderSweetheartList() {
                const container = document.getElementById('sweetheartListContainer');
                const chatHistory = JSON.parse(localStorage.getItem('phoneChatHistory') || '{}');

                container.innerHTML = '';

                // 根据当前世界筛选联系人
                let contactsToShow = [];

                if (currentWorldId) {
                    // 如果有选中的世界，显示该世界的联系人
                    const world = worldsData.find(w => w.id === currentWorldId);
                    if (world && world.contacts) {
                        contactsToShow = sweetheartContactsData.filter(contact =>
                            world.contacts.includes(String(contact.id))
                        );
                    }
                } else {
                    // 如果没有选中世界，显示所有密友
                    contactsToShow = sweetheartContactsData;
                }

                if (contactsToShow.length === 0) {
                    container.innerHTML = '<div style="text-align: center; padding: 60px 20px; color: #A1887F; font-size: 14px; line-height: 1.6;">这个世界还没有联系人，<br/>点击右上角添加一个吧 ✨</div>';
                    return;
                }

                contactsToShow.forEach(contact => {
                    const item = document.createElement('div');
                    item.className = 'sweetheart-item';

                    item.onclick = () => {
                        // 明确告知这不是“返回”操作
                        closeSweetheartList(false);
                        // 稍微增加延迟，让关闭动画更流畅
                        setTimeout(() => openChat(contact), 350);
                    };


                    const contactMessages = chatHistory[contact.id] || [];
                    let lastMessageText = contact.status;
                    if (contactMessages.length > 0) {
                        const lastMessage = contactMessages[contactMessages.length - 1];
                        if (lastMessage.text && lastMessage.text.includes('<img')) {
                            lastMessageText = '[图片]';
                        } else {
                            lastMessageText = lastMessage.text;
                        }
                    }

                    const isUrl = contact.avatar && (String(contact.avatar).startsWith('http') || String(contact.avatar).startsWith('data:'));
                    const avatarContent = isUrl
                        ? `<img src="${escapeHTML(contact.avatar)}" alt="${escapeHTML(contact.name)}">`
                        : `<span>${escapeHTML(contact.avatar)}</span>`;

                    item.innerHTML = `
            <div class="sweetheart-avatar">${avatarContent}</div>
            <div class="sweetheart-info">
                <div class="sweetheart-name">${escapeHTML(contact.name)}</div>
                <div class="sweetheart-status">${escapeHTML(lastMessageText)}</div>
            </div>
        `;

                    container.appendChild(item);
                });
            }


            // ========== 结束：新增的密友列表相关函数 ==========

            /**
             * [新增] 添加一个新的密友
             */
            /**
             * [修正版] 添加一个新的密友，直接打开粉色卡片
             */
            function addNewSweetheartContact() {
                openSweetheartCardModal();
            }


            // ========== 世界书功能 - 开始 ==========

            // 世界书数据存储
            let worldbookData = [];
            let selectedCategory = null; // 当前选择的分组
            let selectedGroup = null; // 选中的分类
            let currentEditingWorldbookId = null;

            /**
             * 打开世界书主页面
             */
            function openWorldbook() {
                document.getElementById('worldbookPage').classList.add('show');
                renderWorldbookList();
            }

            /**
             * 关闭世界书主页面
             */
            function closeWorldbook() {
                document.getElementById('worldbookPage').classList.remove('show');
            }

            /**
             * 渲染世界书列表
             */
            function renderWorldbookList() {
                const emptyEl = document.getElementById('worldbookEmpty');
                const listEl = document.getElementById('worldbookList');

                if (worldbookData.length === 0) {
                    emptyEl.style.display = 'flex';
                    listEl.style.display = 'none';
                } else {
                    emptyEl.style.display = 'none';
                    listEl.style.display = 'flex';

                    listEl.innerHTML = '';
                    worldbookData.forEach(entry => {
                        const item = document.createElement('div');
                        item.className = 'worldbook-item';
                        item.onclick = () => editWorldbookEntry(entry.id);

                        const groupNames = {
                            'worldview': '世界观',
                            'rules': '行为规范',
                            'knowledge': '知识库'
                        };

                        // 获取分组名称
                        let categoryName = '未分组';
                        if (entry.category && entry.category !== 'uncategorized') {
                            const cat = categoriesData.find(c => c.id === entry.category);
                            categoryName = cat ? cat.name : '未分组';
                        }

                        const preview = (entry.content || '暂无内容').substring(0, 60);

                        item.innerHTML = `
                <div class="worldbook-item-title">${escapeHTML(entry.title)}</div>
                <div class="worldbook-item-category">${escapeHTML(groupNames[entry.group] || '未分类')} · ${escapeHTML(categoryName)}</div>
                <div class="worldbook-item-preview">${escapeHTML(preview)}${preview.length >= 60 ? '...' : ''}</div>
            `;

                        listEl.appendChild(item);
                    });
                }
            }


            /**
             * 打开世界书弹窗（新建模式）
             */
            function openWorldbookModal() {
                currentEditingWorldbookId = null;
                selectedGroup = null;
                selectedCategory = null;

                document.getElementById('worldbookModalTitle').textContent = '新建世界书';
                document.getElementById('wbTitleInput').value = '';  // ← 改这里
                document.getElementById('wbContentInput').value = ''; // ← 改这里

                // 重置分类
                document.getElementById('groupSelected').textContent = '请选择分类';
                document.querySelectorAll('#groupOptions .category-option').forEach(opt => {
                    opt.classList.remove('selected');
                });

                // 重置分组
                document.getElementById('categorySelected').textContent = '请选择分组';
                updateCategoryOptions();

                document.getElementById('wbContentLabel').textContent = '内容'; // ← 改这里
                document.getElementById('worldbookDeleteBtn').style.display = 'none';
                document.getElementById('worldbookModal').classList.add('show');
            }


            /**
             * 编辑世界书条目
             */
            // 请用这个新版本替换旧的 editWorldbookEntry 函数
            function editWorldbookEntry(entryId) {
                const entry = worldbookData.find(e => e.id === entryId);
                if (!entry) return;

                currentEditingWorldbookId = entryId;
                selectedGroup = entry.group; // 确保 selectedGroup 被正确赋值
                selectedCategory = entry.category;

                document.getElementById('worldbookModalTitle').textContent = '编辑世界书';
                document.getElementById('wbTitleInput').value = entry.title;
                document.getElementById('wbContentInput').value = entry.content || '';

                // 设置分类
                const groupNames = {
                    'worldview': '世界观',
                    'rules': '行为规范',
                    'knowledge': '知识库'
                };
                // V V V 修正点在这里 V V V
                document.getElementById('groupSelected').textContent = groupNames[entry.group] || '请选择分类';
                document.querySelectorAll('#groupOptions .category-option').forEach(opt => {
                    opt.classList.toggle('selected', opt.dataset.group === entry.group);
                });

                // 设置分组（这部分逻辑保持不变）
                updateCategoryOptions();
                const categoryName = categoriesData.find(c => c.id === entry.category)?.name || '请选择分组';
                document.getElementById('categorySelected').textContent = categoryName;
                document.querySelectorAll('#categoryOptions .category-option').forEach(opt => {
                    opt.classList.toggle('selected', opt.dataset.category === entry.category);
                });

                document.getElementById('worldbookDeleteBtn').style.display = 'block';
                document.getElementById('worldbookModal').classList.add('show');
            }


            /**
             * 关闭世界书弹窗
             */
            function closeWorldbookModal() {
                document.getElementById('worldbookModal').classList.remove('show');
                currentEditingWorldbookId = null;
            }

            /**
             * 保存世界书条目
             */
            function saveWorldbookEntry() {
                const title = document.getElementById('wbTitleInput').value.trim();     // ← 改这里
                const content = document.getElementById('wbContentInput').value.trim(); // ← 改这里

                if (!title) {
                    alert('请填写世界书名称！');
                    return;
                }

                if (!selectedGroup) {
                    alert('请选择分类！');
                    return;
                }

                const entryData = {
                    id: currentEditingWorldbookId || 'WB' + Date.now(),
                    title,
                    group: selectedGroup,
                    category: selectedCategory || 'uncategorized',
                    content,
                    timestamp: Date.now()
                };

                if (currentEditingWorldbookId) {
                    const index = worldbookData.findIndex(e => e.id === currentEditingWorldbookId);
                    if (index !== -1) {
                        worldbookData[index] = entryData;
                    }
                } else {
                    worldbookData.push(entryData);
                }

                saveWorldbookToStorage();
                renderWorldbookList();
                closeWorldbookModal();
                showSuccessModal('保存成功', '世界书已更新！');
            }


            /**
             * 删除世界书条目
             */
            function deleteWorldbookEntry() {
                if (!currentEditingWorldbookId) return;

                if (confirm('确定要删除这个世界书条目吗？')) {
                    worldbookData = worldbookData.filter(e => e.id !== currentEditingWorldbookId);
                    saveWorldbookToStorage();
                    renderWorldbookList();
                    closeWorldbookModal();
                    showSuccessModal('删除成功', '世界书条目已移除。');
                }
            }

            /**
             * 保存世界书数据到 localStorage
             */
            function saveWorldbookToStorage() {
                try {
                    localStorage.setItem('phoneWorldbookData', JSON.stringify(worldbookData));
                } catch (e) {
                    console.error('保存世界书数据失败:', e);
                }
            }

            /**
             * 从 localStorage 加载世界书数据
             */
            function loadWorldbookData() {
                try {
                    const saved = localStorage.getItem('phoneWorldbookData');
                    if (saved) {
                        worldbookData = JSON.parse(saved);
                        console.log('成功加载世界书数据，共', worldbookData.length, '条');
                    }
                } catch (e) {
                    console.error('加载世界书数据失败:', e);
                }
            }

            /**
             * 初始化分组选择器
             */
            function setupCategorySelector() {
                // 分组选择器
                const groupSelector = document.getElementById('groupSelector');
                const groupSelectedEl = document.getElementById('groupSelected');
                const groupOptionsEl = document.getElementById('groupOptions');

                groupSelectedEl.addEventListener('click', (e) => {
                    e.stopPropagation();
                    groupSelector.classList.toggle('active');
                    // 关闭分组选择器
                    document.getElementById('categorySelector').classList.remove('active');
                });

                groupOptionsEl.addEventListener('click', (e) => {
                    const option = e.target.closest('.category-option');
                    if (!option) return;

                    const group = option.dataset.group;
                    selectedGroup = group;

                    groupSelectedEl.textContent = option.textContent;
                    document.querySelectorAll('#groupOptions .category-option').forEach(opt => {
                        opt.classList.remove('selected');
                    });
                    option.classList.add('selected');

                    const labels = {
                        'worldview': '世界观',
                        'rules': '行为规范',
                        'knowledge': '知识库'
                    };
                    document.getElementById('wbContentLabel').textContent = labels[group];
                    document.getElementById('worldbookContent').placeholder = `填写${labels[group]}的内容...`;

                    groupSelector.classList.remove('active');
                });

                // 分组选择器
                const categorySelector = document.getElementById('categorySelector');
                const categorySelectedEl = document.getElementById('categorySelected');
                const categoryOptionsEl = document.getElementById('categoryOptions');

                categorySelectedEl.addEventListener('click', (e) => {
                    e.stopPropagation();
                    categorySelector.classList.toggle('active');
                    // 关闭分组选择器
                    groupSelector.classList.remove('active');
                });

                categoryOptionsEl.addEventListener('click', (e) => {
                    const option = e.target.closest('.category-option');
                    if (!option) return;

                    const category = option.dataset.category;
                    selectedCategory = category;

                    categorySelectedEl.textContent = option.textContent;
                    document.querySelectorAll('#categoryOptions .category-option').forEach(opt => {
                        opt.classList.remove('selected');
                    });
                    option.classList.add('selected');

                    categorySelector.classList.remove('active');
                });

                // 点击其他地方关闭所有选择器
                document.addEventListener('click', () => {
                    groupSelector.classList.remove('active');
                    categorySelector.classList.remove('active');
                });
            }


            /**
             * 打开分组管理（暂时用简单提示，后续可扩展）
             */
            function openCategoryManage(event) {
                event.stopPropagation();
                alert('分组管理功能开发中...');
            }

            // ========== 分类管理功能 - 开始 ==========

            /**
             * 打开分类管理页面
             */
            function openClassificationManage(event) {
                if (event) event.stopPropagation();
                document.getElementById('classificationManagePage').classList.add('show');
                renderClassificationList(); // 打开时渲染列表
            }

            /**
             * 关闭分类管理页面
             */
            function closeClassificationManage() {
                document.getElementById('classificationManagePage').classList.remove('show');
            }

            /**
             * 渲染分类列表（世界观、行为规范、知识库）
             */
            function renderClassificationList() {
                const listEl = document.getElementById('classificationList');
                const emptyEl = document.getElementById('classificationEmpty');

                // 1. 定义我们的三个核心分类
                const coreClassifications = [
                    {key: 'worldview', name: '世界观', icon: '🌍'},
                    {key: 'rules', name: '行为规范', icon: '📜'},
                    {key: 'knowledge', name: '知识库', icon: '📚'}
                ];

                let hasContent = false;
                listEl.innerHTML = ''; // 清空旧内容

                // 2. 遍历每个核心分类
                coreClassifications.forEach(classification => {
                    // 找出所有属于当前分类的世界书条目
                    const worldbooksInCategory = worldbookData.filter(wb => wb.group === classification.key);

                    if (worldbooksInCategory.length > 0) {
                        hasContent = true;
                    }

                    const count = worldbooksInCategory.length;

                    // 3. 创建分类的 DOM 结构（复用分组管理的样式）
                    const item = document.createElement('div');
                    item.className = 'category-item';
                    item.dataset.classificationId = classification.key; // 使用 key 作为唯一标识

                    item.innerHTML = `
            <div class="category-item-header" onclick="toggleClassificationExpand('${classification.key}')">
                <div class="category-item-icon">${classification.icon}</div>
                <div class="category-item-info">
                    <div class="category-item-name">${escapeHTML(classification.name)}</div>
                    <div class="category-item-count">${count} 个世界书</div>
                </div>
                <div class="category-item-arrow">›</div>
            </div>
            <div class="category-worldbooks" id="worldbooks-clf-${classification.key}">
                ${worldbooksInCategory.length === 0
                        ? '<div style="padding: 20px; text-align: center; color: #BCAAA4; font-size: 13px;">暂无世界书</div>'
                        : worldbooksInCategory.map(wb => `
                        <div class="worldbook-mini-item" onclick="editWorldbookFromClassification('${wb.id}')">
                            <div class="worldbook-mini-title">${escapeHTML(wb.title)}</div>
                            <div class="worldbook-mini-preview">${escapeHTML((wb.content || '').substring(0, 40))}...</div>
                        </div>
                    `).join('')}
            </div>
        `;
                    listEl.appendChild(item);
                });

                // 4. 根据是否有内容，决定显示列表还是空状态提示
                if (hasContent || worldbookData.length > 0) { // 只要有世界书就显示分类列表
                    emptyEl.style.display = 'none';
                    listEl.style.display = 'flex';
                } else {
                    emptyEl.style.display = 'flex';
                    listEl.style.display = 'none';
                }
            }

            /**
             * 切换分类的展开/收起
             */
            function toggleClassificationExpand(classificationKey) {
                const item = document.querySelector(`[data-classification-id="${classificationKey}"]`);
                if (item) {
                    item.classList.toggle('expanded');
                }
            }

            /**
             * 从分类管理页面跳转到编辑世界书
             */
            function editWorldbookFromClassification(worldbookId) {
                closeClassificationManage();
                // 延迟执行，等待页面关闭动画完成
                setTimeout(() => {
                    openWorldbook();
                    // 再次延迟，等待世界书页面打开
                    setTimeout(() => editWorldbookEntry(worldbookId), 100);
                }, 300);
            }

            // ========== 分类管理功能 - 结束 ==========


            // ========== 分组管理功能 - 开始 ==========

            // 分组数据存储
            let categoriesData = [];
            let currentEditingCategoryId = null;

            /**
             * 打开分组管理页面
             */
            function openCategoryManage(event) {
                if (event) event.stopPropagation();
                document.getElementById('categoryManagePage').classList.add('show');
                renderCategoryList();
            }

            /**
             * 关闭分组管理页面
             */
            function closeCategoryManage() {
                document.getElementById('categoryManagePage').classList.remove('show');
            }

            /**
             * 动态更新分组选择器的选项
             */
            function updateCategoryOptions() {
                const optionsEl = document.getElementById('categoryOptions');
                if (!optionsEl) return;

                optionsEl.innerHTML = '';

                // 添加"未分组"选项
                const uncategorizedOption = document.createElement('div');
                uncategorizedOption.className = 'category-option';
                uncategorizedOption.dataset.category = 'uncategorized';
                uncategorizedOption.textContent = '未分组';
                optionsEl.appendChild(uncategorizedOption);

                // 添加自定义分组
                categoriesData.forEach(category => {
                    const option = document.createElement('div');
                    option.className = 'category-option';
                    option.dataset.category = category.id;
                    option.textContent = category.name;
                    optionsEl.appendChild(option);
                });
            }


            /**
             * 渲染分组列表
             */
            function renderCategoryList() {
                const emptyEl = document.getElementById('categoryEmpty');
                const listEl = document.getElementById('categoryList');

                if (categoriesData.length === 0) {
                    emptyEl.style.display = 'flex';
                    listEl.style.display = 'none';
                } else {
                    emptyEl.style.display = 'none';
                    listEl.style.display = 'flex';

                    listEl.innerHTML = '';
                    categoriesData.forEach(category => {
                        const item = createCategoryItem(category);
                        listEl.appendChild(item);
                    });
                }
            }

            /**
             * 创建分组项DOM元素
             */
            function createCategoryItem(category) {
                const item = document.createElement('div');
                item.className = 'category-item';
                item.dataset.categoryId = category.id;

                // 统计该分组下的世界书数量
                const worldbooksInCategory = worldbookData.filter(wb => wb.category === category.id);
                const count = worldbooksInCategory.length;

                item.innerHTML = `
        <div class="category-item-header" onclick="toggleCategoryExpand('${category.id}')">
            <div class="category-item-icon">📂</div>
            <div class="category-item-info">
                <div class="category-item-name">${escapeHTML(category.name)}</div>
                <div class="category-item-count">${count} 个世界书</div>
            </div>
            <div class="category-item-arrow">›</div>
        </div>
        <div class="category-worldbooks" id="worldbooks-${category.id}">
            ${worldbooksInCategory.length === 0
                    ? '<div style="padding: 20px; text-align: center; color: #BCAAA4; font-size: 13px;">暂无世界书</div>'
                    : worldbooksInCategory.map(wb => `
                    <div class="worldbook-mini-item" onclick="editWorldbookFromCategory('${wb.id}')">
                        <div class="worldbook-mini-title">${escapeHTML(wb.title)}</div>
                        <div class="worldbook-mini-preview">${escapeHTML((wb.content || '').substring(0, 40))}...</div>
                    </div>
                `).join('')}
        </div>
    `;

                return item;
            }

            /**
             * 切换分组展开/收起
             */
            function toggleCategoryExpand(categoryId) {
                const item = document.querySelector(`[data-category-id="${categoryId}"]`);
                if (!item) return;

                item.classList.toggle('expanded');
            }

            /**
             * 从分组管理页面编辑世界书
             */
            function editWorldbookFromCategory(worldbookId) {
                closeCategoryManage();
                setTimeout(() => {
                    openWorldbook();
                    setTimeout(() => editWorldbookEntry(worldbookId), 100);
                }, 300);
            }

            /**
             * 打开新建分组弹窗
             */
            function openNewCategoryModal() {
                currentEditingCategoryId = null;

                document.getElementById('categoryModalTitle').textContent = '新建分组';
                document.getElementById('categoryNameInput').value = '';
                document.getElementById('categoryDescInput').value = '';
                document.getElementById('categoryDeleteBtn').style.display = 'none';

                document.getElementById('categoryModal').classList.add('show');
            }

            /**
             * 编辑分组
             */
            function editCategory(categoryId) {
                const category = categoriesData.find(c => c.id === categoryId);
                if (!category) return;

                currentEditingCategoryId = categoryId;

                document.getElementById('categoryModalTitle').textContent = '编辑分组';
                document.getElementById('categoryNameInput').value = category.name;
                document.getElementById('categoryDescInput').value = category.description || '';
                document.getElementById('categoryDeleteBtn').style.display = 'block';

                document.getElementById('categoryModal').classList.add('show');
            }

            /**
             * 关闭分组弹窗
             */
            function closeCategoryModal() {
                document.getElementById('categoryModal').classList.remove('show');
                currentEditingCategoryId = null;
            }

            /**
             * 保存分组
             */
            function saveCategory() {
                const name = document.getElementById('categoryNameInput').value.trim();
                const description = document.getElementById('categoryDescInput').value.trim();

                if (!name) {
                    alert('请填写分组名称！');
                    return;
                }

                const categoryData = {
                    id: currentEditingCategoryId || 'CAT' + Date.now(),
                    name,
                    description,
                    timestamp: Date.now()
                };

                if (currentEditingCategoryId) {
                    // 编辑模式
                    const index = categoriesData.findIndex(c => c.id === currentEditingCategoryId);
                    if (index !== -1) {
                        categoriesData[index] = categoryData;
                    }
                } else {
                    // 新建模式
                    categoriesData.push(categoryData);
                }

                saveCategoriesToStorage();
                renderCategoryList();
                updateWorldbookCategorySelector(); // 更新世界书弹窗的分组选项
                closeCategoryModal();
                showSuccessModal('保存成功', '分组已更新！');
            }

            /**
             * 删除分组
             */
            function deleteCategory() {
                if (!currentEditingCategoryId) return;

                // 检查是否有世界书使用此分组
                const worldbooksUsingCategory = worldbookData.filter(wb => wb.category === currentEditingCategoryId);

                if (worldbooksUsingCategory.length > 0) {
                    if (!confirm(`此分组下有 ${worldbooksUsingCategory.length} 个世界书，删除后这些世界书将变为未分组状态，确定删除吗？`)) {
                        return;
                    }

                    // 将使用此分组的世界书改为未分组
                    worldbooksUsingCategory.forEach(wb => {
                        wb.category = 'uncategorized';
                    });
                    saveWorldbookToStorage();
                }

                categoriesData = categoriesData.filter(c => c.id !== currentEditingCategoryId);
                saveCategoriesToStorage();
                renderCategoryList();
                updateWorldbookCategorySelector();
                closeCategoryModal();
                showSuccessModal('删除成功', '分组已移除。');
            }

            /**
             * 保存分组到localStorage
             */
            function saveCategoriesToStorage() {
                try {
                    localStorage.setItem('phoneCategoriesData', JSON.stringify(categoriesData));
                } catch (e) {
                    console.error('保存分组数据失败:', e);
                }
            }

            /**
             * 从localStorage加载分组
             */
            function loadCategoriesData() {
                try {
                    const saved = localStorage.getItem('phoneCategoriesData');
                    if (saved) {
                        categoriesData = JSON.parse(saved);
                        console.log('成功加载分组数据，共', categoriesData.length, '条');
                    }
                } catch (e) {
                    console.error('加载分组数据失败:', e);
                }
            }

            /**
             * 更新世界书弹窗的分组选择器
             */
            function updateWorldbookCategorySelector() {
                const optionsEl = document.getElementById('categoryOptions');
                if (!optionsEl) return;

                optionsEl.innerHTML = '';

                // 添加"未分组"选项
                const uncategorizedOption = document.createElement('div');
                uncategorizedOption.className = 'category-option';
                uncategorizedOption.dataset.category = 'uncategorized';
                uncategorizedOption.textContent = '未分组';
                optionsEl.appendChild(uncategorizedOption);

                // 添加自定义分组
                categoriesData.forEach(category => {
                    const option = document.createElement('div');
                    option.className = 'category-option';
                    option.dataset.category = category.id;
                    option.textContent = category.name;
                    optionsEl.appendChild(option);
                });
            }

            // ========== 分组管理功能 - 结束 ==========
            /**
             * [最终修正版] 根据当前聊天上下文，收集所有相关的世界书内容
             * @returns {string} - 格式化后的世界书内容字符串
             */
            // ▼▼▼ 第5步：用这个新版本替换旧的 gatherWorldbookContext 函数 ▼▼▼
            /**
             * [最终增强版] 根据当前聊天上下文，收集所有相关的世界书内容
             * @returns {string} - 格式化后的世界书内容字符串
             */
            function gatherWorldbookContext() {
                if (!currentChatContact) return '';

                const relevantWorldbookIds = new Set();

                // 1. 查找当前聊天对象(无论是密友还是普通联系人)的数据
                // 我们在两个数据源里都找一下
                const sweetheartData = sweetheartContactsData.find(c => c.id === currentChatContact.id);
                const regularContactData = contactsData.find(c => c.id === currentChatContact.id);

                // 2. 从密友数据中添加绑定的世界书
                if (sweetheartData && sweetheartData.boundWorldbooks && sweetheartData.boundWorldbooks.length > 0) {
                    sweetheartData.boundWorldbooks.forEach(id => relevantWorldbookIds.add(id));
                }

                // 3. [核心新增] 从普通联系人数据中添加绑定的世界书
                if (regularContactData && regularContactData.boundWorldbooks && regularContactData.boundWorldbooks.length > 0) {
                    regularContactData.boundWorldbooks.forEach(id => relevantWorldbookIds.add(id));
                }

                // 4. 从当前所在的世界添加绑定的世界书
                if (currentWorldId) {
                    const world = worldsData.find(w => w.id === currentWorldId);
                    if (world && world.worldbooks && world.worldbooks.length > 0) {
                        world.worldbooks.forEach(id => relevantWorldbookIds.add(id));
                    }
                }

                if (relevantWorldbookIds.size === 0) {
                    return ''; // 没有绑定的世界书，直接返回
                }

                // 5. 根据收集到的ID，查找内容并格式化
                const contextEntries = [];
                relevantWorldbookIds.forEach(id => {
                    const entry = worldbookData.find(wb => wb.id === id);
                    if (entry && entry.content) {
                        const categoryName = categoriesData.find(c => c.id === entry.category)?.name || '通用';
                        contextEntries.push(`### ${categoryName}: ${entry.title}\n${entry.content}`);
                    }
                });

                if (contextEntries.length > 0) {
                    const finalContext = "[背景设定，必须严格遵守]\n---\n" + contextEntries.join('\n\n') + "\n---";
                    console.log("[AI Context] 已加载世界书上下文:\n", finalContext); // 方便调试
                    return finalContext;
                }

                return '';
            }

            // ▲▲▲ 函数替换结束 ▲▲▲

            // ========== 世界书功能 - 结束 ==========

            // ========== 新增：文件夹操作函数 ==========
            // ▼▼▼ 使用这个【全新版本】替换旧的 openFolder 函数 ▼▼▼
            function openFolder(folderData) {
                const overlay = document.getElementById('folderOverlay');
                const headerEl = document.querySelector('.folder-header'); // 获取头部容器
                const nameEl = document.getElementById('folderName');
                const gridEl = document.getElementById('folderContentGrid');

                if (!overlay || !nameEl || !gridEl || !headerEl) return;

                // 1. 存储当前文件夹信息，以便保存时使用
                headerEl.dataset.folderId = folderData.id;
                headerEl.dataset.pageKey = folderData.id.startsWith('widget') ? 'page2' : (document.getElementById('grid1').contains(document.querySelector(`[data-id="${folderData.id}"]`))) ? 'page1' : 'page2';


                // 2. 设置文件夹名称
                nameEl.textContent = folderData.label;

                // 3. 清空上次的内容
                gridEl.innerHTML = '';

                // 4. 动态创建并填入新图标
                folderData.icons.forEach(icon => {
                    const appIconEl = document.createElement('div');
                    appIconEl.className = 'app-icon';

                    const isUrl = icon.startsWith('http') || icon.startsWith('data:');
                    const iconContent = isUrl ? `<img src="${icon}" alt="">` : icon;

                    appIconEl.innerHTML = `
            <div class="icon-wrapper">${iconContent}</div>
            <div class="app-label" style="color: #333; text-shadow: none;">App</div>
        `;
                    gridEl.appendChild(appIconEl);
                });

                // 5. 【核心新增】为标题绑定点击事件，进入编辑模式
                nameEl.onclick = enterFolderNameEditMode;

                // 6. 显示浮层
                overlay.classList.add('show');
            }


            function closeFolder() {
                const overlay = document.getElementById('folderOverlay');
                const headerEl = document.querySelector('.folder-header');
                if (overlay) {
                    overlay.classList.remove('show');
                }
                // 【新增】确保关闭时退出编辑模式
                if (headerEl) {
                    headerEl.classList.remove('is-editing');
                }
            }

            // ========== 新增：文件夹名称编辑相关函数 ==========

            /**
             * 进入文件夹名称编辑模式
             */
            function enterFolderNameEditMode() {
                const headerEl = document.querySelector('.folder-header');
                const nameEl = document.getElementById('folderName');
                const inputEl = document.getElementById('folderNameInput');

                if (!headerEl || !nameEl || !inputEl) return;

                // 切换到编辑状态
                headerEl.classList.add('is-editing');

                // 将当前名称填入输入框并聚焦
                inputEl.value = nameEl.textContent;
                inputEl.focus();
                inputEl.select(); // 全选文本，方便用户直接输入

                // 绑定事件：按Enter键保存，点击别处（失焦）也保存
                inputEl.onkeydown = handleFolderNameKeyDown;
                inputEl.onblur = saveFolderName;
            }

            /**
             * 处理输入框的键盘事件
             * @param {KeyboardEvent} event
             */
            function handleFolderNameKeyDown(event) {
                if (event.key === 'Enter') {
                    event.preventDefault(); // 阻止回车键的默认行为（如表单提交）
                    saveFolderName();
                } else if (event.key === 'Escape') {
                    // 按下ESC键，取消编辑
                    document.querySelector('.folder-header').classList.remove('is-editing');
                }
            }

            /**
             * 保存文件夹名称
             */
            function saveFolderName() {
                const headerEl = document.querySelector('.folder-header');
                const inputEl = document.getElementById('folderNameInput');
                const nameEl = document.getElementById('folderName');

                if (!headerEl.classList.contains('is-editing')) return; // 如果不是编辑模式，则不执行

                const newName = inputEl.value.trim();
                const folderId = headerEl.dataset.folderId;
                const pageKey = headerEl.dataset.pageKey;

                if (newName && folderId && pageKey) {
                    // 更新UI
                    nameEl.textContent = newName;

                    // 更新数据源 (state.appLayouts)
                    const folderData = state.appLayouts[pageKey].find(app => app.id === folderId);
                    if (folderData) {
                        folderData.label = newName;

                        // 更新桌面上的文件夹图标标签
                        const mainFolderIconEl = document.querySelector(`.page [data-id="${folderId}"] .app-label`);
                        if (mainFolderIconEl) {
                            mainFolderIconEl.textContent = newName;
                        }

                        // 持久化保存到localStorage
                        saveLayoutToLocalStorage();
                        console.log(`文件夹 "${folderId}" 已重命名为 "${newName}"`);
                    }
                }

                // 退出编辑模式
                headerEl.classList.remove('is-editing');

            }

            /**
             * [新增] 辅助函数：从图片URL获取一个柔和的渐变背景
             * @param {string} imageUrl - 图片的URL
             * @param {function(string|null)} callback - 回调函数，参数为计算出的渐变背景字符串或 null
             */
            function getAverageColorFromImageUrl(imageUrl, callback) {
                const img = new Image();
                img.crossOrigin = "Anonymous"; // 关键！允许跨域加载图片，否则会失败

                img.onload = () => {
                    const canvas = document.createElement('canvas');
                    const ctx = canvas.getContext('2d');
                    canvas.width = img.width;
                    canvas.height = img.height;

                    ctx.drawImage(img, 0, 0);

                    let data;
                    try {
                        // 从 Canvas 读取像素数据
                        data = ctx.getImageData(0, 0, canvas.width, canvas.height).data;
                    } catch (e) {
                        console.error("无法从 Canvas 获取图片数据，可能是图片服务器的CORS跨域策略导致。请确保图片允许被跨域访问。", e);
                        callback(null); // 出错时回调 null
                        return;
                    }

                    let r = 0, g = 0, b = 0;
                    // 为了提高性能，我们只对部分像素点进行采样，而不是计算所有像素
                    const pixelCount = data.length / 4;
                    const step = Math.max(1, Math.floor(pixelCount / 1000)); // 最多采样1000个点

                    let count = 0;
                    for (let i = 0; i < data.length; i += 4 * step) {
                        // 忽略过于透明或接近纯白的像素，避免它们冲淡颜色
                        if (data[i + 3] < 128 || (data[i] > 240 && data[i + 1] > 240 && data[i + 2] > 240)) {
                            continue;
                        }
                        r += data[i];
                        g += data[i + 1];
                        b += data[i + 2];
                        count++;
                    }

                    if (count === 0) { // 如果图片是全透明或纯白色
                        callback(null);
                        return;
                    }

                    // 计算RGB平均值
                    r = Math.floor(r / count);
                    g = Math.floor(g / count);
                    b = Math.floor(b / count);

                    // 为了让颜色更柔和、更符合您界面的可爱风格，我们将其与白色混合以提高亮度
                    const lightenFactor = 0.4; // 混合40%的白色
                    const finalR = Math.floor(r * (1 - lightenFactor) + 255 * lightenFactor);
                    const finalG = Math.floor(g * (1 - lightenFactor) + 255 * lightenFactor);
                    const finalB = Math.floor(b * (1 - lightenFactor) + 255 * lightenFactor);

                    // 创建两个用于渐变的颜色，一个亮一些，一个稍暗，模仿原始的渐变效果
                    const color1 = `rgba(${finalR}, ${finalG}, ${finalB}, 0.9)`;
                    const color2 = `rgba(${Math.max(0, finalR - 20)}, ${Math.max(0, finalG - 20)}, ${Math.max(0, finalB - 20)}, 0.8)`;

                    // 生成最终的线性渐变字符串
                    const gradient = `linear-gradient(135deg, ${color1}, ${color2})`;

                    callback(gradient);
                };

                img.onerror = () => {
                    console.warn("加载图片失败，无法提取颜色:", imageUrl);
                    callback(null); // 图片加载失败，回调 null
                };

                img.src = imageUrl;
            }

            /**
             * 编辑小猫的状态
             */
            function editCatStatus(event) {
                event.stopPropagation();
                const statusEl = event.target;
                const currentStatus = statusEl.textContent.replace('心情: ', '');

                const newStatus = prompt('请输入小猫的状态（例如：开心 😊、困困 😴、饿饿 🍖）', currentStatus);

                if (newStatus !== null && newStatus.trim()) {
                    statusEl.textContent = '心情: ' + newStatus.trim();
                    // 保存到 localStorage
                    localStorage.setItem('catWidgetStatus', newStatus.trim());
                }
            }

            /**
             * 编辑猫咪状态数值
             */
            function editCatStat(event, statName) {
                event.stopPropagation();
                event.preventDefault();  // ✅ 新增：阻止默认行为

                const statLabels = {
                    'happiness': '😊 开心度',
                    'hunger': '🍖 饱食度',
                    'energy': '⚡ 精力值',
                    'cleanliness': '✨ 清洁度'
                };

                const valueEl = document.getElementById(`stat-${statName}-value`);
                const barEl = document.getElementById(`stat-${statName}-bar`);

                const currentValue = parseInt(valueEl.textContent);

                const newValue = prompt(
                    `请输入${statLabels[statName]}的数值（0-100）：`,
                    currentValue
                );

                if (newValue !== null) {
                    let numValue = parseInt(newValue);

                    // 数值验证
                    if (isNaN(numValue)) {
                        alert('请输入有效的数字！');
                        return;
                    }

                    // 限制范围
                    numValue = Math.max(0, Math.min(100, numValue));

                    // 更新UI
                    valueEl.textContent = numValue + '%';
                    barEl.style.width = numValue + '%';

                    // 保存到localStorage
                    saveCatStats(statName, numValue);

                    // 根据数值显示不同反馈
                    showStatFeedback(statName, numValue);
                }
            }

            /**
             * 保存猫咪状态到localStorage
             */
            function saveCatStats(statName, value) {
                const stats = JSON.parse(localStorage.getItem('catWidgetStats') || '{}');
                stats[statName] = value;
                localStorage.setItem('catWidgetStats', JSON.stringify(stats));
            }

            /**
             * 根据状态值显示反馈
             */
            function showStatFeedback(statName, value) {
                const bubble = document.querySelector('.cat-speech-bubble');
                if (!bubble) return;

                const feedbacks = {
                    'happiness': {
                        high: '喵~ 好开心呀！✨',
                        medium: '今天心情还不错~ 😊',
                        low: '有点不开心... 😿'
                    },
                    'hunger': {
                        high: '吃饱饱啦！🍖✨',
                        medium: '还能再吃一点~ 😋',
                        low: '好饿啊... 给我吃的！😿'
                    },
                    'energy': {
                        high: '精力充沛！冲鸭！⚡',
                        medium: '还行，可以玩会儿~ 😺',
                        low: '好累... 想睡觉了 😴'
                    },
                    'cleanliness': {
                        high: '干干净净真舒服！✨',
                        medium: '该洗澡澡了~ 🛁',
                        low: '脏兮兮的... 快帮我洗澡！💦'
                    }
                };

                let level = 'high';
                if (value < 30) level = 'low';
                else if (value < 70) level = 'medium';

                bubble.textContent = feedbacks[statName][level];
                localStorage.setItem('catWidgetSpeech', bubble.textContent);
            }

            /**
             * 加载猫咪状态数据
             */
            function loadCatStats() {
                const savedStats = localStorage.getItem('catWidgetStats');
                if (!savedStats) return;

                try {
                    const stats = JSON.parse(savedStats);

                    Object.keys(stats).forEach(statName => {
                        const value = stats[statName];
                        const valueEl = document.getElementById(`stat-${statName}-value`);
                        const barEl = document.getElementById(`stat-${statName}-bar`);

                        if (valueEl && barEl) {
                            valueEl.textContent = value + '%';
                            barEl.style.width = value + '%';
                        }
                    });
                } catch (e) {
                    console.error('加载猫咪状态失败:', e);
                }
            }


            /**
             * 编辑小猫说的话
             */
            function editCatSpeech(event) {
                event.stopPropagation();
                event.preventDefault();  // ✅ 新增：阻止默认行为
                const bubbleEl = event.target;
                const currentSpeech = bubbleEl.textContent;

                const newSpeech = prompt('小猫想说什么呢？', currentSpeech);

                if (newSpeech !== null && newSpeech.trim()) {
                    bubbleEl.textContent = newSpeech.trim();
                    // 保存到 localStorage
                    localStorage.setItem('catWidgetSpeech', newSpeech.trim());
                }
            }

            /**
             * 加载小猫组件的保存数据
             */
            /**
             * 加载小猫组件的保存数据
             */
            function loadCatWidgetData() {
                const savedStatus = localStorage.getItem('catWidgetStatus');
                const savedSpeech = localStorage.getItem('catWidgetSpeech');

                // 加载状态文字（已废弃，但保留兼容性）
                if (savedStatus) {
                    const statusEl = document.querySelector('.cat-status');
                    if (statusEl) statusEl.textContent = '心情: ' + savedStatus;
                }

                // 加载对话内容
                if (savedSpeech) {
                    const bubbleEl = document.querySelector('.cat-speech-bubble');
                    if (bubbleEl) bubbleEl.textContent = savedSpeech;
                }

                // ✨ 新增：加载状态条数据
                loadCatStats();
            }


            function initializeApp() {
                // ===== 第一步：获取DOM元素（加上安全检查）=====
                const chatInput = document.getElementById('chatInput');
                const chatInputArea = document.querySelector('.chat-input-area');

                // 检查元素是否存在
                if (!chatInput || !chatInputArea) {
                    console.error('❌ 关键元素未找到，请检查HTML结构');
                    return; // 提前退出，避免后续错误
                }

                // ===== 第二步：初始化输入框状态 =====
                chatInputArea.classList.remove('has-text');

                // ===== 第三步：加载所有数据 =====
                loadWorldsData();
                currentWorldId = localStorage.getItem('currentWorldId');
                updateBattery();
                loadLocationSettings();
                loadUserProfile();
                loadWorldbookData();
                loadCategoriesData();

                // ===== 第四步：初始化UI组件 =====
                setupCategorySelector();
                updateCategoryOptions();
                updateWorldbookCategorySelector();
                setupAttachmentMenu();
                setupStyleSelector();

                // ===== 第五步：应用保存的设置 =====
                applyChatStyle(localStorage.getItem('chatMessageStyle') || 'bubble');
                loadChatBackground();
                loadGlobalConfig();
                loadDockedIcons();

                // ===== 第六步：加载联系人数据 =====
                const savedContacts = localStorage.getItem('phoneContactsData');
                if (savedContacts) {
                    try {
                        contactsData = JSON.parse(savedContacts);
                        console.log('✅ 成功加载联系人列表');
                    } catch (e) {
                        console.error('❌ 解析联系人数据失败:', e);
                    }
                }

                const savedSweetheartContacts = localStorage.getItem('phoneSweetheartContactsData');
                if (savedSweetheartContacts) {
                    try {
                        sweetheartContactsData = JSON.parse(savedSweetheartContacts);
                        console.log('✅ 成功加载密友列表');
                    } catch (e) {
                        console.error('❌ 解析密友数据失败:', e);
                    }
                } else {
                    // 如果是首次使用，保存默认密友列表
                    saveSweetheartContacts();
                    console.log('✅ 已初始化默认密友列表');
                }


                // ===== 第七步：绑定聊天输入框事件（现在是安全的）=====
                chatInput.addEventListener('input', function () {
                    if (this.value.trim().length > 0) {
                        chatInputArea.classList.add('has-text');
                    } else {
                        chatInputArea.classList.remove('has-text');
                    }
                });

                // ===== 第八步：初始化其他开关和设置 =====
                const codeScrollToggle = document.getElementById('codeScrollToggle');
                if (codeScrollToggle) {
                    const savedScrollSetting = localStorage.getItem('codeScrollEnabled') === 'true';
                    codeScrollToggle.checked = savedScrollSetting;
                    applyCodeScrollSetting(savedScrollSetting);

                    codeScrollToggle.addEventListener('change', function () {
                        applyCodeScrollSetting(this.checked);
                        localStorage.setItem('codeScrollEnabled', this.checked);
                    });
                }

                // ===== 消息操作菜单 =====
                const actionSheet = document.getElementById('messageActionSheet');
                if (actionSheet) {
                    actionSheet.addEventListener('click', function (event) {
                        const button = event.target.closest('.action-option');
                        if (!button) return;

                        const {contactId, index} = actionSheet.dataset;
                        const messageIndex = parseInt(index, 10);

                        if (contactId === undefined || isNaN(messageIndex)) {
                            hideMessageActionSheet();
                            return;
                        }

                        switch (button.id) {
                            case 'deleteMessageBtn':
                                deleteMessage(contactId, messageIndex);
                                break;
                            case 'copyMessageBtn':
                                copyMessage(contactId, messageIndex);
                                break;
                            case 'regenerateMessageBtn':
                                regenerateAiResponse(contactId, messageIndex);
                                break;
                            case 'quoteMessageBtn':
                                quoteMessage(contactId, messageIndex);
                                break;
                        }

                        if (button.id !== 'regenerateMessageBtn') {
                            hideMessageActionSheet();
                        }
                    });
                }

                // ===== 全屏模式 =====
                const fullscreenToggle = document.getElementById('fullscreenToggle');
                if (fullscreenToggle) {
                    const savedFullscreenSetting = localStorage.getItem('fullscreenEnabled') === 'true';
                    fullscreenToggle.checked = savedFullscreenSetting;
                    applyFullscreenSetting(savedFullscreenSetting);

                    fullscreenToggle.addEventListener('change', function () {
                        applyFullscreenSetting(this.checked);
                        localStorage.setItem('fullscreenEnabled', this.checked);
                    });
                }

                // ===== 悬浮球 =====
                const floatingBallToggle = document.getElementById('floatingBallToggle');
                if (floatingBallToggle) {
                    const savedFloatingBallSetting = localStorage.getItem('floatingBallEnabled') === 'true';
                    floatingBallToggle.checked = savedFloatingBallSetting;
                    applyFloatingBallSetting(savedFloatingBallSetting);

                    floatingBallToggle.addEventListener('change', function () {
                        applyFloatingBallSetting(this.checked);
                        localStorage.setItem('floatingBallEnabled', this.checked);
                    });
                }

                // ===== 初始化悬浮球和布局 =====
                initializeFloatingBall();
                initializeLayout();
                renderApiConfigs();

                if (globalConfig.activeApiConfig !== null && globalConfig.apiConfigs[globalConfig.activeApiConfig]) {
                    applyApiConfig(globalConfig.activeApiConfig);
                }

                console.log('%c🎉 应用初始化完成！', 'color: #667eea; font-size: 16px; font-weight: bold;');
                // 新增：加载小猫组件数据
                setTimeout(loadCatWidgetData, 500); // 延迟加载，确保DOM已渲染
            }


            initializeApp();
        </script>
</body>
</html>